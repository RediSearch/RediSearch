name: Common Flow for Tests

# Documentation: https://redislabs.atlassian.net/wiki/spaces/DX/pages/3967844669/RediSearch+CI+refactor

on:
  workflow_call:
    inputs:
      env:
        default: "ubuntu-latest"
        type: string
      container:
        type: string
      san:
        type: string
      get-redis:
        type: string
      test-config:
        description: 'Test configuration environment variable (e.g. "CONFIG=tls" or "QUICK=1")'
        required: true
        type: string
      coordinator:
        type: boolean
        default: true
      standalone:
        type: boolean
        default: true
      pre-steps-script:
        type: string
        description: 'Script to run before any other steps (extremely basic dependency needs only)'
      rejson:
        type: boolean
        default: true
        description: 'Enable tests with RedisJSON'
      rejson-branch:
        type: string
        default: '2.4'
        description: 'Branch to use when building RedisJSON for tests'
      test-timeout:
        type: number
        default: 50

env:
  REDISEARCH_MT_BUILD: ${{ vars.REDISEARCH_MT_BUILD }}
  REJSON: ${{ inputs.rejson && 1 || 0 }}  # convert the boolean input to numeric
  VERBOSE_UTESTS: 1

jobs:
  common-flow:
    name: Test ${{ inputs.container || inputs.env }}, Redis ${{ inputs.get-redis || 'unstable' }}
    runs-on: ${{ inputs.env }}
    container: ${{ inputs.container || null }}
    # Nothing to do if both are `false`, skip
    if: ${{ inputs.standalone || inputs.coordinator }}
    defaults:
      run:
        shell: bash -l -eo pipefail {0}
    steps:
      - name: Pre-steps Dependencies
        if: inputs.pre-steps-script
        run: ${{ inputs.pre-steps-script }}

      - name: Get Installation Mode
        id: mode
        run: |
          [[ -z "${{ inputs.container }}" ]] && echo "mode=sudo" >> $GITHUB_OUTPUT || echo "mode=" >> $GITHUB_OUTPUT
      - name: Check if node20 is Supported
        id: node20 # TODO: Remove this when node20 is supported on all platforms, or when we drop support for these platforms
        run: |
          for platform in ubuntu:xenial ubuntu:bionic centos:7 amazonlinux:2; do
            if [[ "${{ inputs.container }}" == "$platform" ]]; then
              echo "supported=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          done
          echo "supported=true" >> $GITHUB_OUTPUT
      - name: Full checkout (node20)
        if: steps.node20.outputs.supported == 'true'
        uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Full checkout (node20 not supported)
        if: steps.node20.outputs.supported == 'false'
        run: |
          # Execute the logic based on the detected platform
          echo "Detected platform: ${{ inputs.container }}"
          case "${{ inputs.container }}" in
            ubuntu:xenial | ubuntu:bionic | centos:7 | amazonlinux:2)

              if [[ ${{ inputs.container }} == centos:7 ]]; then
                # Install git (platform-specific package management)
                echo "Installing prerequisites for ${{ inputs.container }}..."
                # http://mirror.centos.org/centos/7/ is deprecated, so we have to disable mirrorlists
                # and change the baseurl in the repo file to the working mirror (from mirror.centos.org to vault.centos.org)
                for file in /etc/yum.repos.d/*.repo; do
                  sed -i 's/^mirrorlist=/#mirrorlist=/g' $file
                  sed -i 's/^#[[:space:]]*baseurl=http:\/\/mirror/baseurl=http:\/\/vault/g' $file
                done
                yum update -y
                yum install -y git
              fi

              # Configure the safe directory
              git config --global --add safe.directory /__w/${{ github.repository }}

              # Checkout
              REPO_URL="https://github.com/${{ github.repository }}.git"

              # Initialize a Git repository
              git init
              git remote add origin "$REPO_URL"

              # Fetch and checkout ref
              git fetch origin "${{ github.ref }}" || {
                echo "Failed to fetch ref: '${{ github.ref }}'";
                exit 1;
              }
              git checkout FETCH_HEAD  # Check out the fetched ref

              # Update submodules
              git submodule update --init --recursive
              ;;
            *)
              echo "Unsupported platform: '${{ inputs.container }}'"
              exit 1
              ;;
          esac
      - name: Setup
        working-directory: .install
        run: |
          ./install_script.sh ${{ steps.mode.outputs.mode }}
      - name: Setup tests dependencies
        run: |
          .install/test_deps/common_installations.sh ${{ steps.mode.outputs.mode }}
          .install/test_deps/install_rust.sh
      - name: Install LLVM for sanitizer
        if: inputs.san == 'address'
        working-directory: .install
        run: |
          . ./install_llvm.sh ${{ steps.mode.outputs.mode }}
          CLANG_BIN=$(find /usr/bin /usr/local/bin -name "clang-$LLVM_VERSION" 2>/dev/null)
          echo "Using LLVM version: $LLVM_VERSION"
          echo "CC=$CLANG_BIN" >> $GITHUB_ENV
          echo "CXX=$(dirname $CLANG_BIN)/clang++-$LLVM_VERSION" >> $GITHUB_ENV
          echo "LD=$CLANG_BIN" >> $GITHUB_ENV
      - name: Get Redis (node20)
        if: ${{ steps.node20.outputs.supported == 'true' }}
        uses: actions/checkout@v4
        with:
          repository: redis/redis
          ref: ${{ inputs.get-redis }}
          path: redis
      - name: Get Redis (node20 not supported)
        if: ${{ steps.node20.outputs.supported == 'false' }}
        run: |
          REPO_URL="https://github.com/redis/redis.git"
          DEST_DIR="redis"  # Directory to clone into

          # Clone the repository (shallow clone without tags)
          git clone $REPO_URL $DEST_DIR
          cd $DEST_DIR

          # Checkout the REF
          git fetch origin ${{ inputs.get-redis }}
          git checkout ${{ inputs.get-redis }}
      - name: Build Redis
        working-directory: redis
        run: |
          ${{ steps.mode.outputs.mode }} SANITIZER=${{ inputs.san }} BUILD_TLS=yes make install
      - name: Set Artifact Names
        # Artifact names have to be unique, so we base them on the environment.
        # We also remove invalid characters from the name.
        id: artifact-names
        run: | # Invalid characters include: Double quote ", Colon :, Less than <, Greater than >, Vertical bar |, Asterisk *, Question mark ?
          echo "name=$(echo "${{ inputs.container || inputs.env }} ${{ runner.arch }} ${{ format('{0}', inputs.san == 'address' && 'sanitizer' || '') }}- Redis ${{ inputs.get-redis || 'unstable' }}" | \
                       sed -e 's/[":\/\\<>\|*?]/_/g' -e 's/__*/_/g' -e 's/^_//' -e 's/_$//')" >> $GITHUB_OUTPUT

      - name: Build Standalone
        if: ${{ inputs.standalone }}
        env:
          SAN: ${{ inputs.san }}
          ENABLE_ASSERT: 1
        run: ./build.sh TESTS
      - name: Build Coordinator
        if: ${{ inputs.coordinator }}
        env:
          SAN: ${{ inputs.san }}
          COORD: 1
          ENABLE_ASSERT: 1
        run: ./build.sh TESTS
      - name: Unit tests
        timeout-minutes: ${{ fromJSON(inputs.test-timeout) }}
        id: unit_tests
        if: ${{ inputs.standalone }}
        continue-on-error: true
        env:
          SAN: ${{ inputs.san }}
          LOG: 1
          CLEAR_LOGS: 0
          ENABLE_ASSERT: 1
        run: make unit-tests  # todo: replace with ./build.sh RUN_UNIT_TESTS
      - name: Flow tests (standalone)
        timeout-minutes: ${{ fromJSON(inputs.test-timeout) }}
        id: standalone_tests
        if: ${{ inputs.standalone }}
        continue-on-error: true
        env:
          SAN: ${{ inputs.san }}
          LOG: 1
          CLEAR_LOGS: 0
          REJSON: ${{ env.REJSON }}
          REJSON_BRANCH: ${{ inputs.rejson-branch }}
          ENABLE_ASSERT: 1
        run: ./build.sh RUN_PYTEST ${{ inputs.test-config }}
      - name: Unit tests (coordinator)
        id: coordinator_unit_tests
        if: ${{ inputs.coordinator }}
        continue-on-error: true
        env:
          SAN: ${{ inputs.san }}
          LOG: 1
          CLEAR_LOGS: 0
          COORD: 1
          ENABLE_ASSERT: 1
        run: make unit-tests   # todo: replace with ./build.sh RUN_UNIT_TESTS
      - name: Flow tests (coordinator)
        timeout-minutes: ${{ fromJSON(inputs.test-timeout) }}
        id: coordinator_tests
        if: ${{ inputs.coordinator }}
        continue-on-error: true
        env:
          SAN: ${{ inputs.san }}
          LOG: 1
          CLEAR_LOGS: 0
          COORD: 1
          REJSON: ${{ env.REJSON }}
          REJSON_BRANCH: ${{ inputs.rejson-branch }}
          ENABLE_ASSERT: 1
        run: ./build.sh RUN_PYTEST ${{ inputs.test-config }}

      # Using version 4 if node20 is supported, since it is MUCH faster (15m vs 25s)
      - name: Upload Artifacts (node20)
        # Upload artifacts only if node20 is supported and tests failed (including sanitizer failures)
        if: >
          steps.node20.outputs.supported == 'true' &&
          (steps.unit_tests.outcome == 'failure' || steps.standalone_tests.outcome == 'failure' || steps.coordinator_tests.outcome == 'failure' || steps.coordinator_unit_tests.outcome == 'failure')
        uses: actions/upload-artifact@v4
        with:
          name: Test Logs ${{ steps.artifact-names.outputs.name }}
          path: tests/**/logs/*.log*
          if-no-files-found: ignore
      - name: Upload Artifacts (node20 not supported) (temporarily disabled)
        if: >
          steps.node20.outputs.supported == 'false' &&
          (steps.unit_tests.outcome == 'failure' || steps.standalone_tests.outcome == 'failure' || steps.coordinator_tests.outcome == 'failure')
        run: echo "Currently not available..."

      - name: Fail flow if tests failed
        if: steps.unit_tests.outcome == 'failure' || steps.standalone_tests.outcome == 'failure' || steps.coordinator_tests.outcome == 'failure' || steps.coordinator_unit_tests.outcome == 'failure'
        run: |
          echo "Unit Tests: ${{ steps.unit_tests.outcome }}"
          echo "Standalone: ${{ steps.standalone_tests.outcome }}"
          echo "Coordinator: ${{ steps.coordinator_tests.outcome }}"
          echo "Coordinator Unit Tests: ${{ steps.coordinator_unit_tests.outcome }}"
          exit 1
