name: Common Flow for Tests

# Documentation: https://redislabs.atlassian.net/wiki/spaces/DX/pages/3967844669/RediSearch+CI+refactor

on:
  workflow_call:
    inputs:
      env:
        default: ${{ vars.RUNS_ON || 'ubuntu-latest' }}
        type: string
      container:
        type: string
      san:
        type: string
      coverage:
        type: boolean
        default: false
      get-redis:
        type: string
      test-config:
        description: 'Test configuration environment variable (e.g. "CONFIG=tls" or "QUICK=1")'
        required: true
        type: string
      coordinator:
        type: boolean
        default: true
      standalone:
        type: boolean
        default: true
      pre-steps-script:
        type: string
        description: "Script to run before any other steps (extremely basic dependency needs only)"
      rejson:
        type: boolean
        default: true
        description: "Enable tests with RedisJSON"
      rejson-branch:
        type: string
        default: master
        description: "Branch to use when building RedisJSON for tests"
      test-timeout:
        type: number
        default: 50

env:
  REJSON: ${{ inputs.rejson && 1 || 0 }} # convert the boolean input to numeric
  VERBOSE_UTESTS: 1
  COV: ${{ inputs.coverage && 1 || 0 }} # convert the boolean input to numeric
  # Setting RUST_BACKTRACE here to ensure that we get a full report if something goes wrong.
  RUST_BACKTRACE: "full"
  BUILD_INTEL_SVS_OPT: "yes"

jobs:
  build-image:
    if: ${{ inputs.container }}
    name: Build container for ${{ inputs.container || inputs.env }}, Redis ${{ inputs.get-redis || 'unstable' }}
    runs-on: ${{ inputs.env }}
    permissions:
      contents: read
      packages: write # required for GHCR push
    outputs:
      image: ${{ steps.meta.outputs.image }}
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      - name: Set image name
        id: meta
        run: |
          # Base image name
          IMAGE_NAME="ghcr.io/redisearch/redisearch-ci"

          # Append container and sanitizer to make it unique
          CONTAINER=${{ inputs.container || 'default' }}
          SAN=${{ inputs.san || 'none' }}

          # Normalize container string (replace : / with -)
          CONTAINER_SAFE=$(echo "$CONTAINER" | sed 's/[:\/]/-/g')

          # Construct full tag
          IMAGE_TAG="${IMAGE_NAME}:${CONTAINER_SAFE}-${SAN}"

          echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Using image tag: $IMAGE_TAG"
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      - name: Build and push (cached)
        uses: docker/build-push-action@v6
        with:
          push: true
          context: .
          build-args: |
            BASE_IMAGE=${{ inputs.container || 'ubuntu:24.04' }}
          file: Dockerfile
          tags: ${{ steps.meta.outputs.image }}
          cache-to: type=registry,ref=${{ steps.meta.outputs.image }}-cache,mode=max
          cache-from: type=registry,ref=${{ steps.meta.outputs.image }}-cache
  common-flow:
    name: Test ${{ inputs.container || inputs.env }}, Redis ${{ inputs.get-redis || 'unstable' }}
    runs-on: ${{ inputs.env }}
    needs: build-image
    container:
      image: ${{ inputs.container && needs.build-image.outputs.image || null }}
    # Nothing to do if both are `false`, skip
    if: ${{ !cancelled() && (inputs.standalone || inputs.coordinator) }}
    defaults:
      run:
        shell: bash -l -eo pipefail {0}
    steps:
      - name: Fix HOME Directory
        if: ${{ inputs.container }}
        shell: bash
        run: |
          # Issue [HOME is overridden for containers](https://github.com/actions/runner/issues/863)
          h=$(getent passwd $(id -un) | cut -d: -f6)
          if [ "$h" = "$HOME" ]; then
            echo "HOME fine: $HOME"
            exit 0
          fi
          echo "HOME=$HOME was broken. Setting it to $h"
          ls -ld $HOME
          ls -ld $h
          echo "USER: $USER"
          echo "id: $(id)"
          echo "HOME=$h" >> $GITHUB_ENV
      # Split to alpine and non-alpine due to different default shells, once the dependency installation is done, we can use the same shell in the rest of the flow
      - name: Pre-steps Dependencies (Alpine)
        if: inputs.pre-steps-script && inputs.container == 'alpine:3'
        shell: sh -l -eo pipefail {0}
        run: |
          SUCCESS=0
          for i in {1..5}; do
            echo "Attempt $i of 5"
            if ${{ inputs.pre-steps-script }}; then
              echo "Pre-steps Dependencies succeeded"
              SUCCESS=1
              break
            fi
            if [ $i -lt 5 ]; then
              echo "Pre-steps Dependencies failed, retrying in 30 seconds..."
              sleep 30
            fi
          done
          if [ $SUCCESS -eq 0 ]; then
            echo "Pre-steps Dependencies failed after 5 attempts"
            exit 1
          fi
      - name: Pre-steps Dependencies (Non-Alpine)
        if: inputs.pre-steps-script && inputs.container != 'alpine:3'
        run: |
          SUCCESS=0
          for i in {1..5}; do
            echo "Attempt $i of 5"
            if ${{ inputs.pre-steps-script }}; then
              echo "Pre-steps Dependencies succeeded"
              SUCCESS=1
              break
            fi
            if [ $i -lt 5 ]; then
              echo "Pre-steps Dependencies failed, retrying in 30 seconds..."
              sleep 30
            fi
          done
          if [ $SUCCESS -eq 0 ]; then
            echo "Pre-steps Dependencies failed after 5 attempts"
            exit 1
          fi
      - name: Enable dynamic linking to C runtime in Alpine
        if: inputs.container == 'alpine:3'
        run: echo RUST_DYN_CRT=1 >> $GITHUB_ENV
      - name: Get Installation Mode
        id: mode
        run: |
          [[ -z "${{ inputs.container }}" ]] && echo "mode=sudo" >> $GITHUB_OUTPUT || echo "mode=" >> $GITHUB_OUTPUT
      - name: Free up disk space
        run: |
          df -h
          ${{ steps.mode.outputs.mode }} rm -rf /usr/share/dotnet || true
          ${{ steps.mode.outputs.mode }} rm -rf /usr/local/lib/android || true
          ${{ steps.mode.outputs.mode }} rm -rf /opt/ghc || true
          ${{ steps.mode.outputs.mode }} rm -rf /opt/hostedtoolcache/CodeQL || true
          df -h
      - name: Check if node20 is Supported
        id: node20 # TODO: Remove this when node20 is supported on all platforms, or when we drop support for these platforms
        run: |
          for platform in amazonlinux:2 alpine:3; do
            if [[ "${{ inputs.container }}" == "$platform" ]]; then
              echo "supported=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          done
          echo "supported=true" >> $GITHUB_OUTPUT
      - name: Full checkout (node20)
        if: steps.node20.outputs.supported == 'true'
        uses: actions/checkout@v4
        with:
          submodules: recursive
      - name: Full checkout (node20 not supported)
        env:
          GITHUB_REF: ${{ github.ref }}
          GITHUB_REPO: ${{ github.repository }}
        if: steps.node20.outputs.supported == 'false'
        run: |
          # Execute the logic based on the detected platform
          echo "Detected platform: ${{ inputs.container }}"
          case "${{ inputs.container }}" in
            amazonlinux:2 | alpine:3)

              # Configure the safe directory
              git config --global --add safe.directory "/__w/$GITHUB_REPO"

              # Checkout
              REPO_URL="https://github.com/$GITHUB_REPO.git"

              # Initialize a Git repository
              git init
              git remote add origin "$REPO_URL"

              # Fetch and checkout ref
              git fetch origin "$GITHUB_REF" || {
                echo "Failed to fetch ref: '$GITHUB_REF'";
                exit 1;
              }
              git checkout FETCH_HEAD  # Check out the fetched ref

              # Update submodules
              git submodule update --init --recursive
              ;;
            *)
              echo "Unsupported platform: '${{ inputs.container }}'"
              exit 1
              ;;
          esac
      - name: Print CPU information
        env:
          RUNNER_ARCH: ${{ runner.arch }}
        run: |
          echo "=== CPU Information ==="
          if command -v lscpu >/dev/null 2>&1; then
            echo "--- lscpu output ---"
            lscpu
          elif [[ "$RUNNER_OS" == "macOS" ]]; then
            echo "--- macOS CPU info ---"
            echo "CPU brand: $(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo "N/A")"
            echo "Core count: $(sysctl -n machdep.cpu.core_count 2>/dev/null || echo "N/A")"
            echo "Thread count: $(sysctl -n machdep.cpu.thread_count 2>/dev/null || echo "N/A")"
            echo "CPU vendor: $(sysctl -n machdep.cpu.vendor 2>/dev/null || echo "N/A")"
            echo "CPU features: $(sysctl -n machdep.cpu.features 2>/dev/null || echo "N/A")"
          else
            echo "--- Fallback CPU info ---"
            cat /proc/cpuinfo 2>/dev/null || echo "CPU info not available"
          fi
          echo "Runner OS: $RUNNER_OS"
          echo "Runner Architecture: $RUNNER_ARCH"
          echo "========================"
      - name: Setup
        if: needs.build-image.result == 'skipped'
        working-directory: .install
        run: |
          SUCCESS=0
          for i in {1..5}; do
            echo "Attempt $i of 5"
            if ./install_script.sh ${{ steps.mode.outputs.mode }}; then
              echo "Setup succeeded"
              SUCCESS=1
              break
            fi
            if [ $i -lt 5 ]; then
              echo "Setup failed, retrying in 30 seconds..."
              sleep 30
            fi
          done
          if [ $SUCCESS -eq 0 ]; then
            echo "Setup failed after 5 attempts"
            exit 1
          fi
      - name: Setup Python test dependencies
        run: |
          SUCCESS=0
          for i in {1..5}; do
            echo "Attempt $i of 5"
            if .install/test_deps/install_python_deps.sh ${{ steps.mode.outputs.mode }}; then
              echo "Setup tests dependencies succeeded"
              SUCCESS=1
              break
            fi
            if [ $i -lt 5 ]; then
              echo "Setup tests dependencies failed, retrying in 30 seconds..."
              sleep 30
            fi
          done
          if [ $SUCCESS -eq 0 ]; then
            echo "Setup tests dependencies failed after 5 attempts"
            exit 1
          fi
      - name: Install LLVM for sanitizer
        if: inputs.san == 'address'
        working-directory: .install
        run: |
          SUCCESS=0
          for i in {1..5}; do
            echo "Attempt $i of 5"
            if ./install_llvm.sh ${{ steps.mode.outputs.mode }}; then
              echo "Install LLVM for sanitizer succeeded"
              CLANG_BIN=$(find /usr/bin /usr/local/bin -name "clang-[0-9]*" 2>/dev/null | sort -V | tail -1)
              CLANG_VERSION=$(basename $CLANG_BIN | sed 's/clang-//')
              echo "Using LLVM version: $CLANG_VERSION"
              echo "CC=$CLANG_BIN" >> $GITHUB_ENV
              echo "CXX=$(dirname $CLANG_BIN)/clang++-$CLANG_VERSION" >> $GITHUB_ENV
              echo "LD=$CLANG_BIN" >> $GITHUB_ENV
              SUCCESS=1
              break
            fi
            if [ $i -lt 5 ]; then
              echo "Install LLVM for sanitizer failed, retrying in 30 seconds..."
              sleep 30
            fi
          done
          if [ $SUCCESS -eq 0 ]; then
            echo "Install LLVM for sanitizer failed after 5 attempts"
            exit 1
          fi
      - name: Get Redis (node20)
        if: ${{ steps.node20.outputs.supported == 'true' }}
        uses: actions/checkout@v4
        with:
          repository: redis/redis
          ref: ${{ inputs.get-redis }}
          path: redis
      - name: Get Redis (node20 not supported)
        if: ${{ steps.node20.outputs.supported == 'false' }}
        run: |
          REPO_URL="https://github.com/redis/redis.git"
          DEST_DIR="redis"  # Directory to clone into

          # Clone the repository (shallow clone without tags)
          git clone $REPO_URL $DEST_DIR
          cd $DEST_DIR

          # Checkout the REF
          git fetch origin ${{ inputs.get-redis }}
          git checkout ${{ inputs.get-redis }}

      - name: Build Redis
        working-directory: redis
        run:  ${{ steps.mode.outputs.mode }} make install
              BUILD_TLS=yes
              SANITIZER=${{ inputs.san }}

      - name: Set Artifact Names
        # Artifact names have to be unique, so we base them on the environment.
        # We also remove invalid characters from the name.
        id: artifact-names
        run:
          | # Invalid characters include: Double quote ", Colon :, Less than <, Greater than >, Vertical bar |, Asterisk *, Question mark ?
          echo "name=$(echo "${{ format('{0}', inputs.san == 'address' && 'sanitizer' || '') }} \
                             ${{ format('{0}', inputs.coverage && 'coverage test' || '') }} \
                             ${{ inputs.container || inputs.env }} ${{ runner.arch }} - Redis ${{ inputs.get-redis || 'unstable' }}" | \
                       sed -e 's/[":\/\\<>\|*?]/_/g' -e 's/__*/_/g' -e 's/^_//' -e 's/_$//')" >> $GITHUB_OUTPUT
      - name: Build
        env:
          SAN: ${{ inputs.san }}
          REDIS_VER: ${{ inputs.get-redis }}
          ENABLE_ASSERT: 1
        run: make build TESTS=1
      - name: Unit tests
        timeout-minutes: ${{ fromJSON(inputs.test-timeout) }}
        id: unit_tests
        continue-on-error: true
        env:
          SAN: ${{ inputs.san }}
          LOG: 1
          CLEAR_LOGS: 0
          ENABLE_ASSERT: 1
        run: make unit-tests rust-tests
      - name: Flow tests (standalone)
        timeout-minutes: ${{ fromJSON(inputs.test-timeout) }}
        id: standalone_tests
        if: ${{ inputs.standalone }}
        continue-on-error: true
        env:
          SAN: ${{ inputs.san }}
          LOG: 1
          CLEAR_LOGS: 0
          REDIS_STANDALONE: 1
          REJSON: ${{ env.REJSON }}
          REJSON_BRANCH: ${{ inputs.rejson-branch }}
          ENABLE_ASSERT: 1
        run: make pytest ${{ inputs.test-config }}

      - name: Flow tests (coordinator)
        timeout-minutes: ${{ fromJSON(inputs.test-timeout) }}
        id: coordinator_tests
        if: ${{ inputs.coordinator }}
        continue-on-error: true
        env:
          SAN: ${{ inputs.san }}
          LOG: 1
          CLEAR_LOGS: 0
          REDIS_STANDALONE: 0
          REJSON: ${{ env.REJSON }}
          REJSON_BRANCH: ${{ inputs.rejson-branch }}
          ENABLE_ASSERT: 1
        run: make pytest ${{ inputs.test-config }}

      - name: Check test logs folder size
        if: always()
        run: |
          echo "=== Test Logs Folder Size ==="
          if [ -d "tests" ]; then
            echo "Total tests directory size:"
            du -sh tests/ 2>/dev/null || echo "tests/ directory not found"
            echo ""
            echo "Logs subdirectories size:"
            find tests -type d -name "logs" -exec du -sh {} \; 2>/dev/null || echo "No logs directories found"
          else
            echo "tests/ directory does not exist"
          fi
          echo "=========================="

      - name: Check coverage files size
        if: inputs.coverage
        run: |
          echo "=== Coverage Files Size ==="
          if [ -d "bin" ]; then
            echo "Coverage files in bin/:"
            ls -lh bin/*.info 2>/dev/null || echo "No .info files found in bin/"
            echo ""
            echo "Total size of coverage files:"
            du -ch bin/*.info 2>/dev/null | tail -1 || echo "No coverage files to measure"
            echo ""
            echo "Individual coverage file sizes:"
            for file in bin/*.info; do
              if [ -f "$file" ]; then
                echo "  $(basename $file): $(du -h "$file" | cut -f1)"
              fi
            done
          else
            echo "bin/ directory does not exist"
          fi
          echo "=========================="

      # Using version 4 if node20 is supported, since it is MUCH faster (15m vs 25s)
      - name: Upload Artifacts (node20)
        # Upload artifacts only if node20 is supported and tests failed (including sanitizer failures)
        if: >
          steps.node20.outputs.supported == 'true' &&
          (steps.unit_tests.outcome == 'failure' || steps.standalone_tests.outcome == 'failure' || steps.coordinator_tests.outcome == 'failure')
        uses: actions/upload-artifact@v4
        with:
          name: Test Logs ${{ steps.artifact-names.outputs.name }}
          path: |
            tests/**/logs/*.log*
            bin/**/redisearch.so
            bin/**/redisearch.so.debug

          if-no-files-found: ignore
      # If node20 is not supported, we can only use version 3.
      # Here we only upload the artifacts if the tests had failed, since it is very slow
      - name: Upload Artifacts (node20 not supported) (temporarily disabled)
        if: >
          steps.node20.outputs.supported == 'false' &&
          (steps.unit_tests.outcome == 'failure' || steps.standalone_tests.outcome == 'failure' || steps.coordinator_tests.outcome == 'failure')
        run: echo "Currently not available..."

      - name: Fail flow if tests failed
        if: steps.unit_tests.outcome == 'failure' || steps.standalone_tests.outcome == 'failure' || steps.coordinator_tests.outcome == 'failure'
        run: |
          echo "Unit Tests: ${{ steps.unit_tests.outcome }}"
          echo "Standalone: ${{ steps.standalone_tests.outcome }}"
          echo "Coordinator: ${{ steps.coordinator_tests.outcome }}"
          exit 1

      - name: Upload flow coverage
        if: inputs.coverage
        uses: codecov/codecov-action@v5
        with:
          files: bin/flow_standalone.info,bin/flow_coordinator.info
          disable_search: true
          flags: flow
          fail_ci_if_error: true # Fail on upload errors
          token: ${{ secrets.CODECOV_TOKEN }}
      - name: Upload unit coverage
        if: inputs.coverage
        uses: codecov/codecov-action@v5
        with:
          files: bin/unit.info,bin/rust_cov.info
          disable_search: true
          flags: unit
          fail_ci_if_error: true # Fail on upload errors
          token: ${{ secrets.CODECOV_TOKEN }}
