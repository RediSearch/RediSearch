name: Detect Merge Queue Resubmission Without New Commits

on:
  merge_group:
    types: [checks_requested]

permissions:
  actions: read
  contents: read

jobs:
  detect-resubmit:
    runs-on: ${{ vars.RUNS_ON || 'ubuntu-latest' }}
    steps:
      - name: Check for resubmission without new commits
        id: check
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          HEAD_SHA: ${{ github.event.merge_group.head_sha }}
          BASE_SHA: ${{ github.event.merge_group.base_sha }}
          PR_NUMBER: ${{ github.event.merge_group.head_ref }}
          CURRENT_RUN_ID: ${{ github.run_id }}
        shell: python
        run: |
          import os
          import re
          import json
          import subprocess
          import sys

          def run_gh_api(endpoint, jq_filter=None):
              """Run gh api command and return the result."""
              cmd = [
                  'gh', 'api',
                  '-H', 'Accept: application/vnd.github+json',
                  '-H', 'X-GitHub-Api-Version: 2022-11-28',
                  endpoint
              ]
              if jq_filter:
                  cmd.extend(['--jq', jq_filter])

              result = subprocess.run(cmd, capture_output=True, text=True, check=True)
              return result.stdout.strip()

          def set_output(name, value):
              """Set GitHub Actions output using EOF delimiter format."""
              github_output = os.getenv('GITHUB_OUTPUT')
              if not github_output:
                  print(f"::set-output name={name}::{value}")
                  return
              with open(github_output, 'a') as f:
                  f.write(f"{name}<<EOF\n")
                  f.write(f"{value}\n")
                  f.write("EOF\n")

          # Get environment variables
          repo = os.environ['REPO']
          head_sha = os.environ['HEAD_SHA']
          base_sha = os.environ['BASE_SHA']
          pr_number_ref = os.environ['PR_NUMBER']
          current_run_id = int(os.environ['CURRENT_RUN_ID'])

          # Extract PR number from head_ref
          pr_num = None
          if match := re.search(r'refs/pull/(\d+)/merge', pr_number_ref):
              pr_num = match.group(1)
          elif match := re.search(r'pr-(\d+)-', pr_number_ref):
              pr_num = match.group(1)

          if not pr_num:
              print(f"Could not extract PR number from: {pr_number_ref}")
              set_output('resubmit', 'false')
              sys.exit(0)

          print(f"Checking PR #{pr_num}")
          print(f"Current HEAD SHA: {head_sha}")
          print(f"Current BASE SHA: {base_sha}")

          # The merge queue creates a NEW temporary merge commit each time,
          # so head_sha will be different even for the same PR commits.
          # Hence, we should check the PR's actual head commit (before merge).

          # Get the PR's actual head SHA
          pr_head_sha = run_gh_api(f"/repos/{repo}/pulls/{pr_num}", '.head.sha')
          print(f"PR's actual HEAD SHA: {pr_head_sha}")

          # Get the list of previous workflow runs for this merge queue workflow
          print(f"Searching for previous merge_group runs for PR #{pr_num}...")

          runs_data = run_gh_api(f"/repos/{repo}/actions/runs?event=merge_group&per_page=100")
          all_runs = json.loads(runs_data)

          # Filter runs: exclude current run, extract relevant fields
          filtered_runs = [
              {
                  'id': run['id'],
                  'head_sha': run['head_sha'],
                  'conclusion': run['conclusion'],
                  'head_ref': run['head_branch'],
                  'created_at': run['created_at'],
                  'updated_at': run['updated_at']
              }
              for run in all_runs.get('workflow_runs', [])
              if run['id'] != current_run_id
          ]

          print("Recent merge_group runs:")
          for run in filtered_runs:
              print(f"  Run {run['id']}: conclusion={run['conclusion']}, "
                    f"created={run['created_at']}, updated={run['updated_at']}, "
                    f"ref={run['head_ref']}")

          # Look for previous runs from the same PR
          # Use regex to ensure exact PR number match (e.g., pr-12- won't match pr-123-)
          # Only consider completed runs (conclusion is not None)
          # Note: conclusion can be None/null if the workflow is still running or queued
          pattern = re.compile(rf'(^|/)pr-{pr_num}-')
          print(f"Looking for pattern: (^|/)pr-{pr_num}-")
          previous_run_data = None

          for run in filtered_runs:
              # Check if this run matches our PR
              matches_pr = pattern.search(run['head_ref']) if run['head_ref'] else False
              is_failed_or_cancelled = run['conclusion'] in ['failure', 'cancelled'] if run['conclusion'] else False

              print(f"  Run {run['id']}: ref='{run['head_ref']}', "
                    f"matches_pr={bool(matches_pr)}, conclusion='{run['conclusion']}', "
                    f"is_failed_or_cancelled={is_failed_or_cancelled}")

              if matches_pr and is_failed_or_cancelled:
                  previous_run_data = run
                  print(f"  âœ“ Found matching previous run!")
                  break

          if not previous_run_data:
              print(f"No previous failed/cancelled runs found for PR #{pr_num}")
              set_output('resubmit', 'false')
              sys.exit(0)

          previous_run_id = previous_run_data['id']
          print(f"Found previous failed/cancelled run ID: {previous_run_id}")

          # Now check if the PR's head SHA has changed since that previous run
          # The merge queue creates temporary merge commits (merging PR into base branch)
          # The merge commit has 2 parents: [0] = base branch, [1] = PR head
          # We can extract the PR head SHA from the previous run's merge commit parents

          previous_merge_sha = previous_run_data['head_sha']
          print(f"Previous run merge commit SHA: {previous_merge_sha}")

          # Get commit details to check parent structure
          commit_details = run_gh_api(f"/repos/{repo}/commits/{previous_merge_sha}")
          commit_data = json.loads(commit_details)

          parents = commit_data.get('parents', [])
          print(f"Previous merge commit has {len(parents)} parent(s)")

          for i, parent in enumerate(parents):
              print(f"  Parent[{i}]: {parent['sha']}")

          # Get the parent commits of the previous merge commit
          # The second parent is the PR head at the time of the previous run
          previous_pr_head_sha = None

          if len(parents) >= 2:
              # Standard merge commit: parent[1] is the PR head
              previous_pr_head_sha = parents[1]['sha']
              print(f"Previous PR HEAD SHA (from merge parent[1]): {previous_pr_head_sha}")
          elif len(parents) == 1:
              # Not a merge commit - might be a squash or the PR head itself
              # In this case, the commit itself might be the PR head
              print("Warning: Previous run commit is not a merge commit (only 1 parent)")
              print("This might happen with squash merges or if the merge queue behavior changed")
              # We can't reliably determine the previous PR head, so we'll be conservative
              # and NOT alert (assume there might be new commits)
              print("Cannot reliably compare - skipping resubmit detection")
              set_output('resubmit', 'false')
              sys.exit(0)
          else:
              print("Error: Previous run commit has no parents - this is unexpected")
              print("Cannot reliably compare - skipping resubmit detection")
              set_output('resubmit', 'false')
              sys.exit(0)

          # Compare the PR head SHAs directly
          if pr_head_sha != previous_pr_head_sha:
              print(f"New commits detected! PR HEAD changed from {previous_pr_head_sha} to {pr_head_sha}")
              set_output('resubmit', 'false')
              sys.exit(0)

          print(f"Found previous failed/cancelled run for PR #{pr_num}")
          print(f"Previous run ID: {previous_run_id}")
          print("No new commits detected since the previous run!")
          print("This is a resubmission without new commits!")
          set_output('resubmit', 'true')
          set_output('pr_number', pr_num)

          # Get PR details for the notification
          pr_title = run_gh_api(f"/repos/{repo}/pulls/{pr_num}", '.title')
          pr_url = run_gh_api(f"/repos/{repo}/pulls/{pr_num}", '.html_url')
          pr_author = run_gh_api(f"/repos/{repo}/pulls/{pr_num}", '.user.login')

          set_output('pr_title', pr_title)
          set_output('pr_url', pr_url)
          set_output('pr_author', pr_author)

      - name: Notify Slack about resubmission
        if: steps.check.outputs.resubmit == 'true'
        uses: slackapi/slack-github-action@v1
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL_RQE_CI_ISSUES }}
        with:
          payload: |
            {
              "PR": "${{ steps.check.outputs.pr_url }}",
              "Title": "${{ toJson(steps.check.outputs.pr_title) }}",
              "Author": "${{ toJson(steps.check.outputs.pr_author) }}",
              "Workflow": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            }

