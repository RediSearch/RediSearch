name: default (common) flow for host runner

on:
  workflow_call:
    inputs:
      env:
        required: true
        type: string
      san:
        type: string
      get-redis:
        type: boolean
      test-config:
        description: 'Test configuration environment variable (e.g. "CONFIG=concurrent_write" or "QUICK=1")'
        required: true
        type: string
      coordinator:
        type: boolean
        default: true
      standalone:
        type: boolean
        default: true

env:
  MODE: "sudo"

jobs:
  common-flow:
    runs-on: ${{ inputs.env }}
# From this point on, this file should be identical to the other common flow.
    defaults:
      run:
        shell: bash -l -eo pipefail {0}
    steps:
      - name: Deps checkout
        uses: actions/checkout@v4
        with:
          submodules: true
      - run: |
          git config --global --add safe.directory '*'
          git submodule update --init --recursive
      - name: Setup
        run: ./sbin/setup
      # TODO: use this instead
      # - name: Deps checkout
      # uses: actions/checkout@v4
      # with:
      #     sparse-checkout: .install
      # - name: Setup
      #   run: |
      #     ${{env.MODE}} ./.install/install_script.sh
      # - name: Full checkout
      #   uses: actions/checkout@v4
      #   with:
      #     submodules: recursive
      #     set-safe-directory: "'*'"
      - name: Get Redis
        if: ${{ inputs.get-redis }}
        run: |
          export GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          ./deps/readies/bin/getredis --with-github-token

      - name: Decide if to continue after failure
        id: continue-on-error
        run: |
          if [[ -n "${{ inputs.san }}" ]]; then
            echo "decision=true" >> $GITHUB_OUTPUT
          else
            echo "decision=false" >> $GITHUB_OUTPUT
          fi

      - name: Build Standalone
        if: ${{ inputs.standalone }}
        run: make SAN=${{ inputs.san }}
      - name: Build Coordinator
        if: ${{ inputs.coordinator }}
        run: make COORD=1 SAN=${{ inputs.san }}

      - name: Unit tests (standalone)
        id: test1
        if: ${{ inputs.standalone }}
        continue-on-error: ${{ steps.continue-on-error.outputs.decision }}
        run: make unit-tests LOG=1 CLEAR_LOGS=0 SAN=${{ inputs.san }}
      - name: Flow tests (standalone)
        id: test2
        if: ${{ inputs.standalone }}
        continue-on-error: ${{ steps.continue-on-error.outputs.decision }}
        run: make pytest LOG=1 CLEAR_LOGS=0 SAN=${{ inputs.san }} ${{ inputs.test-config }}
      - name: Unit tests (coordinator)
        id: test3
        if: ${{ inputs.coordinator }}
        continue-on-error: ${{ steps.continue-on-error.outputs.decision }}
        run: make COORD=1 unit-tests LOG=1 CLEAR_LOGS=0 SAN=${{ inputs.san }}
      - name: Flow tests (coordinator)
        id: test4
        if: ${{ inputs.coordinator }}
        continue-on-error: ${{ steps.continue-on-error.outputs.decision }}
        run: make COORD=1 pytest LOG=1 CLEAR_LOGS=0 SAN=${{ inputs.san }} ${{ inputs.test-config }}

      - name: Upload Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: Test Logs
          path: |
            tests/logs
            tests/pytests/logs/*.log
          if-no-files-found: ignore
      - name: Upload Sanitizer Artifacts
        if: ${{ inputs.san }}
        uses: actions/upload-artifact@v3
        with:
          name: Sanitizer Logs
          path: tests/pytests/logs/*.log.*
          if-no-files-found: ignore

      - name: Fail flow if tests failed
        if: ${{ steps.test1.outcome == 'failure' || steps.test2.outcome == 'failure' || steps.test3.outcome == 'failure' || steps.test4.outcome == 'failure' }}
        run: exit 1
      # - name: Fail flow if sanitizer failed
      #   if: ${{ inputs.san }}
      #   run: |
      #     if [[ -n "$(ls tests/pytests/logs/*.log.* 2>/dev/null)" ]]; then
      #       exit 1
      #     fi
