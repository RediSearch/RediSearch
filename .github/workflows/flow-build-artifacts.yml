name: Trigger Build and Upload Artifacts for Environments

on:
  workflow_dispatch:
    inputs:
      platform:
        type: choice
        options:
          - all
          - ubuntu:jammy
          - ubuntu:focal
          - ubuntu:bionic
          - rockylinux:8
          - rockylinux:9
          - debian:bullseye
          - amazonlinux:2
          - mariner:2
          - macos
        description: 'Platform to build on. Use "all" to build on all'
        default: all
      architecture:
        type: choice
        options:
          - all
          - x86_64
          - aarch64
        description: 'Architecture to build on. Use "all" to build on all'
        default: all
      tag:
        type: string
        description: 'RediSearch version to build'
        required: true

jobs:
  validation:
    runs-on: ubuntu-latest
    outputs:
      sha: ${{ steps.set-outputs.outputs.sha }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Validate Tag Input
        run: |
          [[ $(git tag --list ${{ inputs.tag }} | wc -l) -eq 1 ]] || exit 1
      - name: Set Outputs
        id: set-outputs
        run: echo "sha=$(git rev-parse ${{ inputs.tag }})" >> $GITHUB_OUTPUT

  decide-linux:
    if: ${{ inputs.platform != 'macos' }}
    uses: ./.github/workflows/task-get-linux-configurations.yml
    with:
      platform: ${{ inputs.platform }}
      architecture: ${{ inputs.architecture }}

  decide-macos:
    runs-on: ubuntu-latest
    if: ${{ contains(fromJson('["macos", "all"]'), inputs.platform) }}
    outputs:
      platforms: ${{ steps.decide.outputs.platforms }}
    steps:
      - id: decide
        shell: python
        run: |
          import os
          platforms = []

          if '${{ inputs.architecture }}' in ['all', 'x86_64']:
            platforms.append('macos-13')
          if '${{ inputs.architecture }}' in ['all', 'aarch64']:
            platforms.append('macos-latest-xlarge')

          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
            print(f'platforms={platforms}', file=f)

  build-linux-x86:
    needs: [decide-linux, validation]
    if: contains(fromJson('["x86_64", "all"]'), inputs.architecture)
    strategy:
      fail-fast: false
      matrix:
        OS: ${{ fromJson(needs.decide-linux.outputs.platforms_x86) }}
        include: ${{ fromJson(needs.decide-linux.outputs.include_x86) }}
    uses: ./.github/workflows/task-build-artifacts.yml
    secrets: inherit
    with:
      container: ${{ matrix.OS }}
      pre-steps-script: ${{ matrix.pre-deps }}
      ref: ${{ inputs.tag }}

  build-linux-arm:
    needs: [decide-linux, validation]
    if: contains(fromJson('["aarch64", "all"]'), inputs.architecture)
    strategy:
      fail-fast: false
      matrix:
        OS: ${{ fromJson(needs.decide-linux.outputs.platforms_arm) }}
        include: ${{ fromJson(needs.decide-linux.outputs.include_arm) }}
    uses: ./.github/workflows/task-build-artifacts.yml
    secrets: inherit
    with:
      env: ${{ vars.RUNS_ON_ARM }}
      container: ${{ matrix.OS }}
      pre-steps-script: ${{ matrix.pre-deps }}
      ref: ${{ inputs.tag }}

  build-macos:
    needs: [decide-macos, validation]
    if: contains(fromJson('["macos", "all"]'), inputs.platform)
    strategy:
      fail-fast: false
      matrix:
        OS: ${{ fromJson(needs.decide-macos.outputs.platforms) }}
    uses: ./.github/workflows/task-build-artifacts.yml
    secrets: inherit
    with:
      env: ${{ matrix.OS }}
      ref: ${{ inputs.tag }}

  deploy:
    needs: [build-linux-x86, build-linux-arm, build-macos, validation]
    if: ${{ !cancelled() && !failure() }}
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.ARTIFACT_UPLOAD_AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.ARTIFACT_UPLOAD_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.ARTIFACT_UPLOAD_AWS_REGION }}
      - name: Get boto3
        run: pip install boto3
      - name: Set Version Artifacts
        shell: python
        run: |
          import boto3
          import os
          import json
          from concurrent.futures import ThreadPoolExecutor
          from zipfile import ZipFile

          bucket = "redismodules"
          oss_dir = "redisearch-oss"
          ent_dir = "redisearch"

          suffix = ".${{ inputs.tag }}.zip"
          new_suffix = ".${{ inputs.tag }}.zip".replace("v", "")
          expected_sha = "${{ needs.validation.outputs.sha }}"

          client = boto3.client("s3")

          ########################### Helper Functions ###########################

          # List all file in `bucket`, with suffix `suffix` and the given prefix (path)
          def list_files_by_branch(prefix):
              paginator = client.get_paginator("list_objects_v2")
              for page in paginator.paginate(Bucket=bucket, Prefix=prefix):
                  for obj in page.get("Contents", []):
                      if obj["Key"].endswith(suffix):
                          yield obj["Key"]

          def list_snapshots_by_branch(dir):
              return list_files_by_branch(f"{dir}/snapshots/{dir}")

          # Return the git sha from the module.json file in the zip file (build sha)
          def extract_sha(key):
              zip_name = os.path.basename(key)
              c = boto3.client("s3")
              c.download_file(bucket, key, zip_name)
              with ZipFile(zip_name, "r") as z:
                  with z.open("module.json") as f:
                      obj = json.load(f)
                      sha = str(obj["git_sha"]) # handle bytes, str, and bytes string representation
                      return sha[2:-1] if sha[:2] in ['b"', "b'"] else sha

          # new location is outside snapshots/ directory and with the new suffix
          # Only called on files we know end with `suffix` and have a `snapshot` directory in the path
          def get_target_name(name):
              return name.replace("snapshots/", "", 1)[:-len(suffix)] + new_suffix

          def group_print(title, args):
              print(f"::group::{title} ({len(args)})")
              print(*args, sep="\n")
              print("::endgroup::")

          ############################### Main Script ###############################

          files = []
          for dir in [oss_dir, ent_dir]:
              files.extend(list_snapshots_by_branch(dir))

          group_print("${{ inputs.tag }} Branch candidates", files)

          with ThreadPoolExecutor() as executor:
              sha_list = executor.map(extract_sha, files)

          exclude_list = [(f, sha) for f, sha in zip(files, sha_list) if sha != expected_sha]
          include_list = [f for f in files if f not in [x for x, _ in exclude_list]]
          dest_files = [get_target_name(f) for f in include_list]

          # Log files
          group_print("Excluded files", exclude_list)
          group_print("Included files", include_list)
          group_print("Unexpected SHAs", set([sha for _, sha in exclude_list]))

          # Copy included files to new location
          for src, dst in zip(include_list, dest_files):
              client.copy_object(Bucket=bucket, Key=dst, CopySource={"Bucket": bucket, "Key": src}, ACL="public-read")

          group_print("New Files", dest_files)

          if len(exclude_list) > 0:
              print("::warning title=Unexpected Files::The workflow has encountered files that do not match the "
                    "expected git sha. These files will not be included in the release artifacts. Look for the "
                    "`Excluded files` section above for more details.")
