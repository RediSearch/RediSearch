/*
 * Copyright Redis Ltd. 2016 - present
 * Licensed under your choice of the Redis Source Available License 2.0 (RSALv2) or
 * the Server Side Public License v1 (SSPLv1).
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "../parse.h"
#include "parser.h"
#include "../../query_node.h"

/* forward declarations of stuff generated by lemon */

#define RSQuery_Parse_v2 RSQueryParser_v2_ // weird Lemon quirk.. oh well..
#define RSQuery_ParseAlloc_v2 RSQueryParser_v2_Alloc
#define RSQuery_ParseFree_v2 RSQueryParser_v2_Free

void RSQuery_Parse_v2(void *yyp, int yymajor, QueryToken yyminor, QueryParseCtx *ctx);
void *RSQuery_ParseAlloc_v2(void *(*mallocProc)(size_t));
void RSQuery_ParseFree_v2(void *p, void (*freeProc)(void *));

int RSQuery_ParseNumericOp_v2(void* pParser, int OperatorType, QueryToken tok,
      QueryParseCtx *q, const char *ts, const char *te, char c1,
      unsigned int opLen) {
    tok.len = te - (ts + 1);
    tok.pos = ts - q->raw;
    tok.s = ts + 1;

    // Find the position before the operator
    char *end1 = strchr(tok.s, c1) - 1;
    // Find the position after the operator
    char *start2 = end1 + opLen + 1;
    // Remove unescaped spaces at the end of the modifier
    char *m = (char*)(tok.s);
    int escaped = (*m == '\\');
    while (m < end1) {
      if (isspace(*(m + 1)) && !escaped) {
        end1 = m;
        break;
      }
      ++m;
      escaped = !escaped && *m == '\\';
    }
    tok.len = end1 - tok.s + 1;
    RSQuery_Parse_v2(pParser, MODIFIER, tok, q);
    if (!QPCTX_ISOK(q)) {
      return 0;
    }

    tok.s = start2 - opLen;
    tok.len = opLen;
    RSQuery_Parse_v2(pParser, OperatorType, tok, q);
    if (!QPCTX_ISOK(q)) {
      return 0;
    }

    // Remove spaces after the operator
    while (isspace(*start2)) {
      ++start2;
    }

    // Detect parameter's sign if exists
    if ((*start2 == '+' || *start2 == '-') && *(start2+1) == '$') {
      tok.sign = *start2 == '-' ? -1 : 1;
      ++start2;
    }
    tok.s = start2;
    int is_attr = (*(tok.s) == '$') ? 1 : 0;
    tok.len = (te - start2) + 1 - is_attr;

    if(is_attr) {
      tok.s++;
      // Remove trailing spaces from attribute
      while (isspace(*(tok.s + tok.len - 1))) {
        --tok.len;
      }
      RSQuery_Parse_v2(pParser, ATTRIBUTE, tok, q);
    } else {
      char *ne = (char*)te;
      tok.numval = strtod(tok.s, &ne);
      RSQuery_Parse_v2(pParser, NUMBER, tok, q);
    }
    if (!QPCTX_ISOK(q)) {
        return 0;
    }
    return 1;
}

%%{

machine query;

inf = 'inf'i ;
size = digit+ ;
number = digit+('.' digit+)? (('E'|'e') ['+\-]? digit+)?;

quote = '"';
or = '|';
lp = '(';
rp = ')';
lb = '{';
rb = '}';
colon = ':';
semicolon = ';';
arrow = '=>';
minus = '-';
plus = '+';
tilde = '~';
star = '*';
percent = '%';
rsqb = ']';
lsqb = '[';
escape = '\\';
squote = "'";
escaped_character = escape (punct | space | escape);
exact = (quote . ((any - quote) | (escape.quote))+ . quote) | (squote . ((any - squote) | (escape.squote))+ . squote);
term = (((any - (punct | cntrl | space | escape)) | escaped_character) | '_')+   ;
empty_string = quote.quote | squote.squote;
mod = '@'.term ;
attr = '$'.term ;
mod_not_equal = '@'.term.(space*).'!='.(space*).(((plus|minus)?(space*).(number|inf))|size|(plus|minus)?.attr);
mod_equal = '@'.term.(space*).'=='.(space*).(((plus|minus)?(space*).(number|inf))|size|(plus|minus)?.attr) ;
mod_gt = '@'.term.(space*).'>'.(space*).(((plus|minus)?(space*).(number|inf))|size|(plus|minus)?.attr) ;
mod_ge = '@'.term.(space*).'>='.(space*).(((plus|minus)?(space*).(number|inf))|size|(plus|minus)?.attr) ;
mod_lt = '@'.term.(space*).'<'.(space*).(((plus|minus)?(space*).(number|inf))|size|(plus|minus)?.attr) ;
mod_le = '@'.term.(space*).'<='.(space*).(((plus|minus)?(space*).(number|inf))|size|(plus|minus)?.attr) ;
contains = (star.term.star | star.((plus|minus)?number).star | star.attr.star) ;
contains_exact = (star.exact.star) ;
prefix = (term.star | (plus|minus)?(space*).number.star | attr.star) ;
prefix_exact = (exact.star) ;
suffix = (star.term | star.(plus|minus)?(space*).number | star.attr) ;
suffix_exact = (star.exact) ;
as = 'as'i;
verbatim = ((quote . ((any - quote - escape) | escape.any)+ . quote) | (squote . ((any - squote - escape) | escape.any)+ . squote)) ;
wildcard = 'w' . verbatim ;
ismissing = 'ismissing'i ;

main := |*

  size => {
    tok.s = ts;
    tok.len = te-ts;
    char *ne = (char*)te;
    tok.numval = strtod(tok.s, &ne);
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, SIZE, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  number => {
    tok.s = ts;
    tok.len = te-ts;
    char *ne = (char*)te;
    tok.numval = strtod(tok.s, &ne);
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, NUMBER, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  mod => {
    tok.pos = ts-q->raw;
    tok.len = te - (ts + 1);
    tok.s = ts+1;
    RSQuery_Parse_v2(pParser, MODIFIER, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  attr => {
    tok.pos = ts-q->raw;
    tok.len = te - (ts + 1);
    tok.s = ts+1;
    RSQuery_Parse_v2(pParser, ATTRIBUTE, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  mod_not_equal => {
    if(!RSQuery_ParseNumericOp_v2(pParser, NOT_EQUAL, tok, q, ts, te, '!', 2)) {
      fbreak;
    }
  };

  mod_equal => {
    if(!RSQuery_ParseNumericOp_v2(pParser, EQUALS, tok, q, ts, te, '=', 2)) {
      fbreak;
    }
  };

  mod_gt => {
    if(!RSQuery_ParseNumericOp_v2(pParser, GT, tok, q, ts, te, '>', 1)) {
      fbreak;
    }
  };

  mod_ge => {
    if(!RSQuery_ParseNumericOp_v2(pParser, GE, tok, q, ts, te, '>', 2)) {
      fbreak;
    }
  };

  mod_lt => {
    if(!RSQuery_ParseNumericOp_v2(pParser, LT, tok, q, ts, te, '<', 1)) {
      fbreak;
    }
  };

  mod_le => {
    if(!RSQuery_ParseNumericOp_v2(pParser, LE, tok, q, ts, te, '<', 2)) {
      fbreak;
    }
  };

  arrow => {
    tok.pos = ts-q->raw;
    tok.len = te - ts;
    tok.s = ts+1;
    RSQuery_Parse_v2(pParser, ARROW, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  as => {
    tok.pos = ts-q->raw;
    tok.len = te - ts;
    tok.s = ts;
    RSQuery_Parse_v2(pParser, AS_T, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  inf => {
    tok.pos = ts-q->raw;
    tok.s = ts;
    tok.len = te-ts;
    tok.numval = *ts == '-' ? -INFINITY : INFINITY;
    RSQuery_Parse_v2(pParser, NUMBER, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  empty_string => {
    tok.pos = ts-q->raw;
    tok.s = "";
    tok.len = 0;
    RSQuery_Parse_v2(pParser, TERM, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  quote => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, QUOTE, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  or => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, OR, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  lp => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, LP, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  rp => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, RP, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  lb => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, LB, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  rb => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, RB, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
   colon => {
     tok.pos = ts-q->raw;
     RSQuery_Parse_v2(pParser, COLON, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
   };
    semicolon => {
     tok.pos = ts-q->raw;
     RSQuery_Parse_v2(pParser, SEMICOLON, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
   };

  minus =>  {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, MINUS, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  plus =>  {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, PLUS, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  tilde => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, TILDE, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
 star => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, STAR, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
   percent => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, PERCENT, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  lsqb => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, LSQB, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  rsqb => {
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, RSQB, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  space;
  punct;
  cntrl;

  ismissing => {
    tok.pos = ts-q->raw;
    tok.len = te - ts;
    tok.s = ts;
    RSQuery_Parse_v2(pParser, ISMISSING, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };
  term => {
    tok.len = te-ts;
    tok.s = ts;
    tok.numval = 0;
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, TERM, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  exact => {
    tok.len = te - (ts + 2);
    tok.s = ts + 1;
    tok.numval = 0;
    tok.pos = ts-q->raw;
    RSQuery_Parse_v2(pParser, EXACT, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  prefix => {
    int is_attr = (*ts == '$') ? 1 : 0;
    tok.type = is_attr ? QT_PARAM_TERM : QT_TERM;
    tok.len = te - (ts + 1 + is_attr);
    tok.s = ts + is_attr;
    tok.numval = 0;
    tok.pos = ts-q->raw;

    RSQuery_Parse_v2(pParser, PREFIX, tok, q);

    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  prefix_exact => {
    tok.type = QT_TERM;
    tok.len = te - (ts + 3); // remove the quotes and the star at the end
    tok.s = ts + 1; // skip the quote
    tok.numval = 0;
    tok.pos = ts-q->raw;

    RSQuery_Parse_v2(pParser, PREFIX, tok, q);

    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  suffix => {
    int is_attr = (*(ts+1) == '$') ? 1 : 0;
    tok.type = is_attr ? QT_PARAM_TERM : QT_TERM;
    tok.len = te - (ts + 1 + is_attr);
    tok.s = ts + 1 + is_attr;
    tok.numval = 0;
    tok.pos = ts-q->raw;

    RSQuery_Parse_v2(pParser, SUFFIX, tok, q);

    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  suffix_exact => {
    tok.type = QT_TERM;
    tok.len = te - (ts + 3); // remove the quotes at the end
    tok.s = ts + 2; // skip the star and the quote
    tok.numval = 0;
    tok.pos = ts-q->raw;

    RSQuery_Parse_v2(pParser, SUFFIX, tok, q);

    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  contains => {
    int is_attr = (*(ts+1) == '$') ? 1 : 0;
    tok.type = is_attr ? QT_PARAM_TERM : QT_TERM;
    tok.len = te - (ts + 2 + is_attr);
    tok.s = ts + 1 + is_attr;
    tok.numval = 0;
    tok.pos = ts-q->raw;

    RSQuery_Parse_v2(pParser, CONTAINS, tok, q);

    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  contains_exact => {
    tok.type = QT_TERM;
    tok.len = te - (ts + 4); // remove the quotes and the star
    tok.s = ts + 2; // skip the star and the quote
    tok.numval = 0;
    tok.pos = ts-q->raw;

    RSQuery_Parse_v2(pParser, CONTAINS, tok, q);

    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  verbatim => {
    int is_attr = (*(ts+2) == '$') ? 1 : 0;
    tok.type = is_attr ? QT_PARAM_TERM : QT_TERM;
    tok.pos = ts-q->raw;
    tok.len = te - (ts + 2 + is_attr);
    tok.s = ts + 1 + is_attr;
    tok.numval = 0;
    RSQuery_Parse_v2(pParser, VERBATIM, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

  wildcard => {
    int is_attr = (*(ts+2) == '$') ? 1 : 0;
    tok.type = is_attr ? QT_PARAM_WILDCARD : QT_WILDCARD;
    tok.pos = ts-q->raw + 2;
    tok.len = te - (ts + 3 + is_attr);
    tok.s = ts + 2 + is_attr;
    tok.numval = 0;
    RSQuery_Parse_v2(pParser, WILDCARD, tok, q);
    if (!QPCTX_ISOK(q)) {
      fbreak;
    }
  };

*|;
}%%

%% write data;

QueryNode *RSQuery_ParseRaw_v2(QueryParseCtx *q) {
  void *pParser = RSQuery_ParseAlloc_v2(rm_malloc);


  int cs, act;
  const char* ts = q->raw;          // query start
  const char* te = q->raw + q->len; // query end
  %% write init;
  QueryToken tok = {.len = 0, .pos = 0, .s = 0, .sign = 1};

  //parseCtx ctx = {.root = NULL, .ok = 1, .errorMsg = NULL, .q = q};
  const char* p = q->raw;
  const char* pe = q->raw + q->len;
  const char* eof = pe;

  %% write exec;

  if (QPCTX_ISOK(q)) {
    RSQuery_Parse_v2(pParser, 0, tok, q);
  }
  RSQuery_ParseFree_v2(pParser, rm_free);
  if (!QPCTX_ISOK(q) && q->root) {
    QueryNode_Free(q->root);
    q->root = NULL;
  }
  return q->root;
}
