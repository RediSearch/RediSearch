/*
 * Copyright (c) 2006-Present, Redis Ltd.
 * All rights reserved.
 *
 * Licensed under your choice of the Redis Source Available License 2.0
 * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the
 * GNU Affero General Public License v3 (AGPLv3).
*/

use std::{ffi::c_char, marker::PhantomData};

use ffi::{RSDocumentMetadata, RSQueryTerm, RSYieldableMetric, t_docId, t_fieldMask};
use low_memory_thin_vec::LowMemoryThinVec;

use super::RSResultKindMask;

/// Represents a numeric value in an index record.
/// cbindgen:field-names=[value]
#[allow(rustdoc::broken_intra_doc_links)] // The field rename above breaks the intra-doc link
#[repr(C)]
pub struct RSNumericRecordRaw(pub f64);

/// Represents the encoded offsets of a term in a document. You can read the offsets by iterating
/// over it with RSIndexResult_IterateOffsets
#[repr(C)]
pub struct RSOffsetVectorRaw<'index> {
    /// At this point the data ownership is still managed by the caller.
    // TODO: switch to a Cow once the caller code has been ported to Rust.
    pub data: *mut c_char,
    pub len: u32,
    /// data may be borrowed from the reader.
    /// The data pointer does not allow lifetime so use a PhantomData to carry the lifetime for it instead.
    pub _phantom: PhantomData<&'index ()>,
}

// Check at compile-time if `RSOffsetVectorRaw` and `super::RSOffsetVectorRef` have the same representation.
// This is important to ensure that the C bindings generated by `cbindgen` match the Rust structs
// used in the codebase.
const _: () = {
    use std::mem::{align_of, size_of};

    // Struct size and alignment check
    const SIZE_MATCHES: bool =
        size_of::<RSOffsetVectorRaw<'_>>() == size_of::<super::RSOffsetVectorRef<'_>>();
    const ALIGN_MATCHES: bool =
        align_of::<RSOffsetVectorRaw<'_>>() == align_of::<super::RSOffsetVectorRef<'_>>();

    if !SIZE_MATCHES {
        panic!("Size mismatch between RSOffsetVectorRaw and super::RSOffsetVectorRef");
    }

    if !ALIGN_MATCHES {
        panic!("Alignment mismatch between RSOffsetVectorRaw and super::RSOffsetVectorRef");
    }

    // Check offset of each field
    const DATA_OFFSET_MATCHES: bool = std::mem::offset_of!(RSOffsetVectorRaw<'_>, data)
        == std::mem::offset_of!(super::RSOffsetVectorRef<'_>, data);
    if !DATA_OFFSET_MATCHES {
        panic!("Field 'data' does not match offset in super::RSOffsetVectorRef");
    }

    const LEN_OFFSET_MATCHES: bool = std::mem::offset_of!(RSOffsetVectorRaw<'_>, len)
        == std::mem::offset_of!(super::RSOffsetVectorRef<'_>, len);
    if !LEN_OFFSET_MATCHES {
        panic!("Field 'len' does not match offset in super::RSOffsetVectorRef");
    }
};

// Check at compile-time if `RSOffsetVectorRaw` and `super::RSOffsetVectorOwned` have the same representation.
// This is important to ensure that the C bindings generated by `cbindgen` match the Rust structs
// used in the codebase.
const _: () = {
    use std::mem::{align_of, size_of};

    // Struct size and alignment check
    const SIZE_MATCHES: bool =
        size_of::<RSOffsetVectorRaw<'_>>() == size_of::<super::RSOffsetVectorOwned>();
    const ALIGN_MATCHES: bool =
        align_of::<RSOffsetVectorRaw<'_>>() == align_of::<super::RSOffsetVectorOwned>();

    if !SIZE_MATCHES {
        panic!("Size mismatch between RSOffsetVectorRaw and super::RSOffsetVectorOwned");
    }

    if !ALIGN_MATCHES {
        panic!("Alignment mismatch between RSOffsetVectorRaw and super::RSOffsetVectorOwned");
    }

    // Check offset of each field
    const DATA_OFFSET_MATCHES: bool = std::mem::offset_of!(RSOffsetVectorRaw<'_>, data)
        == std::mem::offset_of!(super::RSOffsetVectorOwned, data);
    if !DATA_OFFSET_MATCHES {
        panic!("Field 'data' does not match offset in super::RSOffsetVectorOwned");
    }

    const LEN_OFFSET_MATCHES: bool = std::mem::offset_of!(RSOffsetVectorRaw<'_>, len)
        == std::mem::offset_of!(super::RSOffsetVectorOwned, len);
    if !LEN_OFFSET_MATCHES {
        panic!("Field 'len' does not match offset in super::RSOffsetVectorOwned");
    }
};

/// Represents a single record of a document inside a term in the inverted index
/// cbindgen:rename-all=CamelCase
#[repr(C)]
pub struct RSTermRecordRaw<'index> {
    /// We mark copied terms so we can treat them a bit differently on delete.
    pub is_copy: bool,

    /// The term that brought up this record
    pub term: *mut RSQueryTerm,

    /// The encoded offsets in which the term appeared in the document
    pub offsets: RSOffsetVectorRaw<'index>,
}

// Check at compile-time if `RSTermRecordRaw` and `super::RSTermRecord` have the same representation.
// This is important to ensure that the C bindings generated by `cbindgen` match the Rust structs
// used in the codebase.
const _: () = {
    use std::mem::{align_of, size_of};

    // Struct size and alignment check
    const SIZE_MATCHES: bool =
        size_of::<RSTermRecordRaw<'_>>() == size_of::<super::RSTermRecord<'_>>();
    const ALIGN_MATCHES: bool =
        align_of::<RSTermRecordRaw<'_>>() == align_of::<super::RSTermRecord<'_>>();

    if !SIZE_MATCHES {
        panic!("Size mismatch between RSTermRecordRaw and super::RSTermRecord");
    }

    if !ALIGN_MATCHES {
        panic!("Alignment mismatch between RSTermRecordRaw and super::RSTermRecord");
    }

    // Check offset of each field
    const TERM_REF_OFFSET_MATCHES: bool = std::mem::offset_of!(RSTermRecordRaw<'_>, term)
        == std::mem::offset_of!(super::RSTermRecordRef<'_>, term) + 8;
    if !TERM_REF_OFFSET_MATCHES {
        panic!("Field 'term' does not match offset in super::RSTermRecordRef");
    }

    const TERM_OWNED_OFFSET_MATCHES: bool = std::mem::offset_of!(RSTermRecordRaw<'_>, term)
        == std::mem::offset_of!(super::RSTermRecordOwned, term) + 8;
    if !TERM_OWNED_OFFSET_MATCHES {
        panic!("Field 'term' does not match offset in super::RSTermRecordOwned");
    }

    const OFFSETS_REF_OFFSET_MATCHES: bool = std::mem::offset_of!(RSTermRecordRaw<'_>, offsets)
        == std::mem::offset_of!(super::RSTermRecordRef<'_>, offsets) + 8;
    if !OFFSETS_REF_OFFSET_MATCHES {
        panic!("Field 'offsets' does not match offset in super::RSTermRecordRef");
    }

    const OFFSETS_OWNED_OFFSET_MATCHES: bool = std::mem::offset_of!(RSTermRecordRaw<'_>, offsets)
        == std::mem::offset_of!(super::RSTermRecordOwned, offsets) + 8;
    if !OFFSETS_OWNED_OFFSET_MATCHES {
        panic!("Field 'offsets' does not match offset in super::RSTermRecordOwned");
    }
};

/// Represents an aggregate array of values in an index record.
///
/// The C code should always use `AggregateResult_New` to construct a new instance of this type
/// using Rust since the internals cannot be constructed directly in C. The reason is because of
/// the `LowMemoryThinVec` which needs to exist in Rust's memory space to ensure its memory is
/// managed correctly.
/// cbindgen:rename-all=CamelCase
#[repr(C)]
pub struct RSAggregateResultRaw<'index> {
    /// We mark copied aggregates so we can treat them a bit differently on delete.
    pub is_copy: bool,

    /// The records making up this aggregate result
    ///
    /// The `RSAggregateResult` is part of a union in [`RSResultData`], so it needs to have a
    /// known size. The std `Vec` won't have this since it is not `#[repr(C)]`, so we use our
    /// own `LowMemoryThinVec` type which is `#[repr(C)]` and has a known size instead.
    pub records: LowMemoryThinVec<*const RSIndexResultRaw<'index>>,

    /// A map of the aggregate kind of the underlying records
    pub kind_mask: RSResultKindMask,
}

// Check at compile-time if `RSAggregateResultRaw` and `super::RSAggregateResult` have the same representation.
// This is important to ensure that the C bindings generated by `cbindgen` match the Rust structs
// used in the codebase.
const _: () = {
    use std::mem::{align_of, size_of};

    // Struct size and alignment check
    const SIZE_MATCHES: bool =
        size_of::<RSAggregateResultRaw<'_>>() == size_of::<super::RSAggregateResult<'_>>();
    const ALIGN_MATCHES: bool =
        align_of::<RSAggregateResultRaw<'_>>() == align_of::<super::RSAggregateResult<'_>>();

    if !SIZE_MATCHES {
        panic!("Size mismatch between RSAggregateResultRaw and super::RSAggregateResult");
    }

    if !ALIGN_MATCHES {
        panic!("Alignment mismatch between RSAggregateResultRaw and super::RSAggregateResult");
    }

    // Check offset of each field
    const RECORDS_REF_OFFSET_MATCHES: bool =
        std::mem::offset_of!(RSAggregateResultRaw<'_>, records)
            == std::mem::offset_of!(super::RSAggregateResultRef<'_>, records) + 8;
    if !RECORDS_REF_OFFSET_MATCHES {
        panic!("Field 'records' does not match offset in super::RSAggregateResultRef");
    }

    const RECORDS_OWNED_OFFSET_MATCHES: bool =
        std::mem::offset_of!(RSAggregateResultRaw<'_>, records)
            == std::mem::offset_of!(super::RSAggregateResultOwned, records) + 8;
    if !RECORDS_REF_OFFSET_MATCHES {
        panic!("Field 'records' does not match offset in super::RSAggregateResultOwned");
    }

    const KIND_MASK_REF_OFFSET_MATCHES: bool =
        std::mem::offset_of!(RSAggregateResultRaw<'_>, kind_mask)
            == std::mem::offset_of!(super::RSAggregateResultRef<'_>, kind_mask) + 8;
    if !KIND_MASK_REF_OFFSET_MATCHES {
        panic!("Field 'kind_mask' does not match offset in super::RSAggregateResultRef");
    }

    const KIND_MASK_OWNED_OFFSET_MATCHES: bool =
        std::mem::offset_of!(RSAggregateResultRaw<'_>, kind_mask)
            == std::mem::offset_of!(super::RSAggregateResultOwned, kind_mask) + 8;
    if !KIND_MASK_OWNED_OFFSET_MATCHES {
        panic!("Field 'kind_mask' does not match offset in super::RSAggregateResultOwned");
    }
};

/// Represents a virtual result in an index record.
#[repr(C)]
pub struct RSVirtualResultRaw;

/// Holds the actual data of an ['IndexResult']
///
/// These enum values should stay in sync with [`RSResultKind`], so that the C union generated matches
/// the bitflags on [`RSResultKindMask`]
///
/// The `'index` lifetime is linked to the [`crate::IndexBlock`] when decoding borrows from the block.
/// While the `'aggregate_children` lifetime is linked to [`RSAggregateResult`] that is holding
/// raw pointers to results.
#[repr(u8)]
/// cbindgen:prefix-with-name=true
pub enum RSResultDataRaw<'index> {
    Union(RSAggregateResultRaw<'index>) = 1,
    Intersection(RSAggregateResultRaw<'index>) = 2,
    Term(RSTermRecordRaw<'index>) = 4,
    Virtual(RSVirtualResultRaw) = 8,
    Numeric(RSNumericRecordRaw) = 16,
    Metric(RSNumericRecordRaw) = 32,
    HybridMetric(RSAggregateResultRaw<'index>) = 64,
}

// Check at compile-time if `RSResultDataRaw` and `super::RSResultData` have the same representation.
// This is important to ensure that the C bindings generated by `cbindgen` match the Rust structs
// used in the codebase.
const _: () = {
    use std::mem::{align_of, size_of};

    // Struct size and alignment check
    const SIZE_MATCHES: bool =
        size_of::<RSResultDataRaw<'_>>() == size_of::<super::RSResultData<'_>>();
    const ALIGN_MATCHES: bool =
        align_of::<RSResultDataRaw<'_>>() == align_of::<super::RSResultData<'_>>();

    if !SIZE_MATCHES {
        panic!("Size mismatch between RSResultDataRaw and super::RSResultData");
    }

    if !ALIGN_MATCHES {
        panic!("Alignment mismatch between RSResultDataRaw and super::RSResultData");
    }
};

/// The result of an inverted index
/// cbindgen:rename-all=CamelCase
#[repr(C)]
pub struct RSIndexResultRaw<'index> {
    /// The document ID of the result
    pub doc_id: t_docId,

    /// Some metadata about the result document
    pub dmd: *const RSDocumentMetadata,

    /// The aggregate field mask of all the records in this result
    pub field_mask: t_fieldMask,

    /// The total frequency of all the records in this result
    pub freq: u32,

    /// For term records only. This is used as an optimization, allowing the result to be loaded
    /// directly into memory
    pub offsets_sz: u32,

    /// The actual data of the result
    pub data: RSResultDataRaw<'index>,

    /// Holds an array of metrics yielded by the different iterators in the AST
    pub metrics: *mut RSYieldableMetric,

    /// Relative weight for scoring calculations. This is derived from the result's iterator weight
    pub weight: f64,
}

// Check at compile-time if `RSIndexResultRaw` and `super::RSIndexResult` have the same representation.
// This is important to ensure that the C bindings generated by `cbindgen` match the Rust structs
// used in the codebase.
const _: () = {
    use std::mem::{align_of, size_of};

    // Struct size and alignment check
    const SIZE_MATCHES: bool = size_of::<RSIndexResultRaw>() == size_of::<super::RSIndexResult>();
    const ALIGN_MATCHES: bool =
        align_of::<RSIndexResultRaw>() == align_of::<super::RSIndexResult>();

    if !SIZE_MATCHES {
        panic!("Size mismatch between RSIndexResultRaw and super::RSIndexResult");
    }

    if !ALIGN_MATCHES {
        panic!("Alignment mismatch between RSIndexResultRaw and super::RSIndexResult");
    }

    // Check offset of each field
    const DOC_ID_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, doc_id)
        == std::mem::offset_of!(super::RSIndexResult<'_>, doc_id);
    if !DOC_ID_OFFSET_MATCHES {
        panic!("Field 'doc_id' does not match offset in super::RSIndexResult");
    }

    const DMD_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, dmd)
        == std::mem::offset_of!(super::RSIndexResult<'_>, dmd);
    if !DMD_OFFSET_MATCHES {
        panic!("Field 'dmd' does not match offset in super::RSIndexResult");
    }

    const FIELD_MASK_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, field_mask)
        == std::mem::offset_of!(super::RSIndexResult<'_>, field_mask);
    if !FIELD_MASK_OFFSET_MATCHES {
        panic!("Field 'field_mask' does not match offset in super::RSIndexResult");
    }

    const FREQ_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, freq)
        == std::mem::offset_of!(super::RSIndexResult<'_>, freq);
    if !FREQ_OFFSET_MATCHES {
        panic!("Field 'freq' does not match offset in super::RSIndexResult");
    }

    const OFFSETS_SZ_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, offsets_sz)
        == std::mem::offset_of!(super::RSIndexResult<'_>, offsets_sz);
    if !OFFSETS_SZ_OFFSET_MATCHES {
        panic!("Field 'offsets_sz' does not match offset in super::RSIndexResult");
    }

    const DATA_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, data)
        == std::mem::offset_of!(super::RSIndexResult<'_>, data);
    if !DATA_OFFSET_MATCHES {
        panic!("Field 'data' does not match offset in super::RSIndexResult");
    }

    const METRICS_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, metrics)
        == std::mem::offset_of!(super::RSIndexResult<'_>, metrics);
    if !METRICS_OFFSET_MATCHES {
        panic!("Field 'metrics' does not match offset in super::RSIndexResult");
    }

    const WEIGHT_OFFSET_MATCHES: bool = std::mem::offset_of!(RSIndexResultRaw<'_>, weight)
        == std::mem::offset_of!(super::RSIndexResult<'_>, weight);
    if !WEIGHT_OFFSET_MATCHES {
        panic!("Field 'weight' does not match offset in super::RSIndexResult");
    }
};
