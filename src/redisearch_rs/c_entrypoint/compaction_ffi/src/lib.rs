/*
 * Copyright (c) 2006-Present, Redis Ltd.
 * All rights reserved.
 *
 * Licensed under your choice of the Redis Source Available License 2.0
 * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the
 * GNU Affero General Public License v3 (AGPLv3).
*/

//! FFI callback structures for compaction delta application.
//!
//! These structures define the callback interface between Rust and C.
//! C provides callback implementations, and Rust invokes them to:
//! - Update C-owned in-memory structures (Trie term doc counts, numTerms)
//! - Perform synchronization (acquire/release locks)
//!
//! The C header is auto-generated by cbindgen during build.
//!
//! # Important Note on Scoring Stats
//!
//! - Term-level stats: `numDocs` per term in the trie (via `update_trie_term`)
//! - Index-level term count: `numTerms` when terms become empty (via `update_scoring_stats`)

use std::ffi::{c_char, c_void};

/// Scoring stats delta - passed to the update callback.
///
/// This structure is FFI-safe and the C definition is auto-generated by cbindgen.
/// It only contains stats that are updated by GC, NOT at delete time.
///
/// Note: `num_docs` and `totalDocsLen` are updated at delete time,
/// so they are NOT included here.
#[repr(C)]
#[derive(Clone, Copy, Default, Debug, PartialEq, Eq)]
pub struct ScoringStatsDelta {
    /// Number of terms that became empty during compaction.
    pub num_terms_removed: u64,
}

impl ScoringStatsDelta {
    /// Returns true if this delta contains no changes.
    pub fn is_empty(&self) -> bool {
        self.num_terms_removed == 0
    }
}

/// FFI-safe callback struct for compaction operations.
///
/// This struct is passed from C to Rust. Rust invokes these callbacks to
/// perform operations on C-owned data structures.
///
/// The C definition is auto-generated by cbindgen.
///
/// # Safety
///
/// All function pointers must be valid and the `ctx` pointer must remain
/// valid for the duration of compaction. The C side is responsible for
/// providing valid callback implementations.
#[repr(C)]
pub struct CompactionCallbacks {
    // === Synchronization Callbacks ===
    /// Acquire IndexSpec write lock.
    /// Called before applying delta to memory structures.
    pub acquire_write_lock: Option<unsafe extern "C" fn(*mut c_void)>,

    /// Release IndexSpec write lock.
    /// Called after applying delta to memory structures.
    pub release_write_lock: Option<unsafe extern "C" fn(*mut c_void)>,

    // === Memory Update Callbacks ===
    /// Update a term's document count in the Serving Trie.
    ///
    /// # Parameters
    /// - `ctx`: Opaque context pointer (typically IndexSpec*)
    /// - `term`: Pointer to term string (NOT null-terminated)
    /// - `term_len`: Length of term in bytes
    /// - `doc_count_decrement`: Number of documents to decrement from the term's count
    pub update_trie_term: Option<unsafe extern "C" fn(*mut c_void, *const c_char, usize, usize)>,

    /// Update IndexScoringStats.
    ///
    /// # Parameters
    /// - `ctx`: Opaque context pointer (typically IndexSpec*)
    /// - `delta`: Pointer to ScoringStatsDelta with the changes
    pub update_scoring_stats: Option<unsafe extern "C" fn(*mut c_void, *const ScoringStatsDelta)>,

    // === Context ===
    /// Opaque pointer passed to all callbacks.
    /// Typically points to the C IndexSpec struct.
    pub ctx: *mut c_void,
}

// SAFETY: CompactionCallbacks contains raw pointers but is only used for FFI.
// The C side ensures thread safety through proper synchronization.
unsafe impl Send for CompactionCallbacks {}

impl Default for CompactionCallbacks {
    /// Creates a no-op CompactionCallbacks with all callbacks set to None.
    /// Useful for testing where no actual C callbacks are needed.
    fn default() -> Self {
        Self {
            acquire_write_lock: None,
            release_write_lock: None,
            update_trie_term: None,
            update_scoring_stats: None,
            ctx: std::ptr::null_mut(),
        }
    }
}

impl CompactionCallbacks {
    /// Calls the acquire_write_lock callback if present.
    ///
    /// # Safety
    /// The callback and ctx must be valid.
    pub fn acquire_write_lock(&self) {
        if let Some(f) = self.acquire_write_lock {
            // SAFETY: Caller ensures ctx is valid and callback is safe to call
            unsafe { f(self.ctx) };
        }
    }

    /// Calls the release_write_lock callback if present.
    ///
    /// # Safety
    /// The callback and ctx must be valid.
    pub fn release_write_lock(&self) {
        if let Some(f) = self.release_write_lock {
            // SAFETY: Caller ensures ctx is valid and callback is safe to call
            unsafe { f(self.ctx) };
        }
    }

    /// Updates a term's document count in the Serving Trie.
    ///
    /// # Arguments
    /// * `term` - The term string to update
    /// * `doc_count_decrement` - Number of documents to decrement
    ///
    /// # Safety
    /// The callback and ctx must be valid.
    pub fn update_trie_term(&self, term: &str, doc_count_decrement: u64) {
        if let Some(f) = self.update_trie_term {
            let term_bytes = term.as_bytes();
            // SAFETY: Caller ensures ctx is valid and callback is safe to call.
            // We pass the term as a pointer + length (not null-terminated).
            unsafe {
                f(
                    self.ctx,
                    term_bytes.as_ptr() as *const c_char,
                    term_bytes.len(),
                    doc_count_decrement as usize,
                );
            }
        }
    }

    /// Updates the IndexScoringStats with the given delta.
    ///
    /// # Arguments
    /// * `delta` - The scoring stats delta to apply
    ///
    /// # Safety
    /// The callback and ctx must be valid.
    pub fn update_scoring_stats(&self, delta: &ScoringStatsDelta) {
        if let Some(f) = self.update_scoring_stats {
            // SAFETY: Caller ensures ctx is valid and callback is safe to call.
            unsafe {
                f(self.ctx, delta as *const ScoringStatsDelta);
            }
        }
    }
}
