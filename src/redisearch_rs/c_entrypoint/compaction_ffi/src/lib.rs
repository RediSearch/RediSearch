/*
 * Copyright (c) 2006-Present, Redis Ltd.
 * All rights reserved.
 *
 * Licensed under your choice of the Redis Source Available License 2.0
 * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the
 * GNU Affero General Public License v3 (AGPLv3).
*/

//! FFI callback structures for compaction delta application.
//!
//! These structures define the callback interface between Rust and C.
//! C provides callback implementations, and Rust invokes them to:
//! - Update C-owned in-memory structures (Trie term doc counts, numTerms)
//! - Perform synchronization (acquire/release locks)
//!
//! The C header is auto-generated by cbindgen during build.
//!
//! # Important Note on Scoring Stats
//!
//! - Term-level stats: `numDocs` per term in the trie (via `update_trie_term`)
//! - Index-level term count: `numTerms` when terms become empty (via `update_scoring_stats`)

use std::ffi::{c_char, c_void};

/// Scoring stats delta - passed to the update callback.
///
/// This structure is FFI-safe and the C definition is auto-generated by cbindgen.
/// It only contains stats that are updated by GC, NOT at delete time.
///
/// Note: `num_docs` and `totalDocsLen` are updated at delete time,
/// so they are NOT included here.
#[repr(C)]
#[derive(Clone, Copy, Default, Debug, PartialEq, Eq)]
pub struct ScoringStatsDelta {
    /// Number of terms that became empty during compaction.
    pub num_terms_removed: u64,
}

impl ScoringStatsDelta {
    /// Returns true if this delta contains no changes.
    pub fn is_empty(&self) -> bool {
        self.num_terms_removed == 0
    }
}

/// FFI-safe callback struct for compaction operations.
///
/// This struct is passed from C to Rust. Rust invokes these callbacks to
/// perform operations on C-owned data structures.
///
/// The C definition is auto-generated by cbindgen.
///
/// # Safety
///
/// All function pointers must be valid and the `ctx` pointer must remain
/// valid for the duration of compaction. The C side is responsible for
/// providing valid callback implementations.
#[repr(C)]
pub struct CompactionCallbacks {
    // === Synchronization Callbacks ===
    /// Acquire IndexSpec write lock.
    /// Called before applying delta to memory structures.
    pub acquire_write_lock: Option<unsafe extern "C" fn(*mut c_void)>,

    /// Release IndexSpec write lock.
    /// Called after applying delta to memory structures.
    pub release_write_lock: Option<unsafe extern "C" fn(*mut c_void)>,

    // === Memory Update Callbacks ===
    /// Update a term's document count in the Serving Trie.
    ///
    /// # Parameters
    /// - `ctx`: Opaque context pointer (typically IndexSpec*)
    /// - `term`: Pointer to term string (NOT null-terminated)
    /// - `term_len`: Length of term in bytes
    /// - `doc_count_decrement`: Number of documents to decrement from the term's count
    pub update_trie_term: Option<unsafe extern "C" fn(*mut c_void, *const c_char, usize, usize)>,

    /// Update IndexScoringStats.
    ///
    /// # Parameters
    /// - `ctx`: Opaque context pointer (typically IndexSpec*)
    /// - `delta`: Pointer to ScoringStatsDelta with the changes
    pub update_scoring_stats: Option<unsafe extern "C" fn(*mut c_void, *const ScoringStatsDelta)>,

    // === Context ===
    /// Opaque pointer passed to all callbacks.
    /// Typically points to the C IndexSpec struct.
    pub ctx: *mut c_void,
}

// SAFETY: CompactionCallbacks contains raw pointers but is only used for FFI.
// The C side ensures thread safety through proper synchronization.
unsafe impl Send for CompactionCallbacks {}

impl Default for CompactionCallbacks {
    /// Creates a no-op CompactionCallbacks with all callbacks set to None.
    /// Useful for testing where no actual C callbacks are needed.
    fn default() -> Self {
        Self {
            acquire_write_lock: None,
            release_write_lock: None,
            update_trie_term: None,
            update_scoring_stats: None,
            ctx: std::ptr::null_mut(),
        }
    }
}

impl CompactionCallbacks {
    /// Acquires the write lock and returns a guard that releases it on drop.
    ///
    /// This is the preferred way to acquire the lock, as it ensures the lock
    /// is always released when the guard goes out of scope (RAII pattern).
    ///
    /// Operations that require the lock (like [`WriteGuard::update_trie_term`])
    /// are only available through the guard, enforcing at compile time that
    /// they can only be called while holding the lock.
    ///
    /// # Example
    ///
    /// ```ignore
    /// let guard = callbacks.write_lock();
    /// guard.update_trie_term(b"term", 5);
    /// // Lock is automatically released when `guard` goes out of scope
    /// ```
    pub fn write_lock(&self) -> WriteGuard<'_> {
        WriteGuard::new(self)
    }
}

/// A guard that holds the write lock and releases it on drop.
///
/// This guard implements the RAII pattern: the lock is acquired when the guard
/// is created (via [`CompactionCallbacks::write_lock`]) and released when the
/// guard is dropped.
///
/// Operations that require the write lock are exposed as methods on this guard,
/// ensuring at compile time that they can only be called while holding the lock.
///
/// # Example
///
/// ```ignore
/// {
///     let guard = callbacks.write_lock();
///     guard.update_trie_term(b"foo", 5);
///     guard.update_scoring_stats(&delta);
///     // Lock automatically released here
/// }
/// ```
pub struct WriteGuard<'a> {
    callbacks: &'a CompactionCallbacks,
}

impl<'a> WriteGuard<'a> {
    /// Creates a new guard, acquiring the write lock.
    ///
    /// Prefer using [`CompactionCallbacks::write_lock`] instead of calling this directly.
    fn new(callbacks: &'a CompactionCallbacks) -> Self {
        if let Some(f) = callbacks.acquire_write_lock {
            // SAFETY: Caller ensures ctx is valid and callback is safe to call
            unsafe { f(callbacks.ctx) };
        }
        Self { callbacks }
    }

    /// Updates a term's document count in the Serving Trie.
    ///
    /// This method requires holding the write lock (enforced by requiring `&self`).
    ///
    /// # Arguments
    /// * `term` - The term as raw bytes (typically UTF-8, but not validated here)
    /// * `doc_count_decrement` - Number of documents to decrement
    pub fn update_trie_term(&self, term: &[u8], doc_count_decrement: u64) {
        if let Some(f) = self.callbacks.update_trie_term {
            // SAFETY: We hold the write lock (enforced by having &self),
            // and caller ensures ctx is valid.
            // The C side receives raw bytes + length and handles encoding internally.
            unsafe {
                f(
                    self.callbacks.ctx,
                    term.as_ptr() as *const c_char,
                    term.len(),
                    doc_count_decrement as usize,
                );
            }
        }
    }

    /// Updates the IndexScoringStats with the given delta.
    ///
    /// This method requires holding the write lock (enforced by requiring `&self`).
    ///
    /// # Arguments
    /// * `delta` - The scoring stats delta to apply
    pub fn update_scoring_stats(&self, delta: &ScoringStatsDelta) {
        if let Some(f) = self.callbacks.update_scoring_stats {
            // SAFETY: We hold the write lock (enforced by having &self),
            // and caller ensures ctx is valid.
            unsafe {
                f(self.callbacks.ctx, delta as *const ScoringStatsDelta);
            }
        }
    }
}

impl Drop for WriteGuard<'_> {
    fn drop(&mut self) {
        if let Some(f) = self.callbacks.release_write_lock {
            // SAFETY: We acquired the lock in new(), so we must release it.
            // Caller ensures ctx is valid.
            unsafe { f(self.callbacks.ctx) };
        }
    }
}
