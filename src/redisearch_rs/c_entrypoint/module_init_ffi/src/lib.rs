/*
 * Copyright (c) 2006-Present, Redis Ltd.
 * All rights reserved.
 *
 * Licensed under your choice of the Redis Source Available License 2.0
 * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the
 * GNU Affero General Public License v3 (AGPLv3).
*/

use std::ptr::NonNull;

/// Initializes a global subscriber that reports Rust `tracing` traces through `redismodule` logging.
#[unsafe(no_mangle)]
pub extern "C" fn TracingRedisModule_Init(ctx: Option<NonNull<ffi::RedisModuleCtx>>) {
    tracing_redismodule::init(ctx);
}

/// Initialize RediSearch's panic hook, without replaacing the pre-existing panic hook (if any).
///
/// Panic messages will be logged through `tracing` at the `ERROR` level.
#[unsafe(no_mangle)]
pub extern "C" fn RustPanicHook_Init() {
    let previous_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |panic_info| {
        // We don't capture a backtrace here, since it should be included
        // in the crash report generated by the module info function
        // if `for_crash_report` is set to `true`.
        tracing::error!(
            panic.payload = panic_info.payload_as_str(),
            panic.location = panic_info.location().map(|l| l.to_string()),
            "A panic occurred in the Rust code",
        );

        // Invoke the previous panic hook, if any.
        previous_hook(panic_info);
    }));
}
