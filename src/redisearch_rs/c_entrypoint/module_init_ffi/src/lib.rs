/*
 * Copyright (c) 2006-Present, Redis Ltd.
 * All rights reserved.
 *
 * Licensed under your choice of the Redis Source Available License 2.0
 * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the
 * GNU Affero General Public License v3 (AGPLv3).
*/

use std::ptr::NonNull;

/// Initializes a global subscriber that reports Rust `tracing` traces through `redismodule` logging.
#[unsafe(no_mangle)]
pub extern "C" fn TracingRedisModule_Init(ctx: Option<NonNull<ffi::RedisModuleCtx>>) {
    tracing_redismodule::init(ctx);
}

/// Initialize RediSearch's panic hook, without replaacing the pre-existing panic hook (if any).
///
/// Panic messages will be logged through `tracing` at the `ERROR` level.
#[unsafe(no_mangle)]
pub extern "C" fn RustPanicHook_Init() {
    let previous_hook = std::panic::take_hook();
    std::panic::set_hook(Box::new(move |panic_info| {
        let payload = panic_info.payload();
        #[allow(clippy::manual_map)]
        let payload = if let Some(s) = payload.downcast_ref::<&str>() {
            Some(&**s)
        } else if let Some(s) = payload.downcast_ref::<String>() {
            Some(s.as_str())
        } else {
            None
        };
        // We don't capture a backtrace here, since it should be included
        // in the crash report generated by the module info function
        // if `for_crash_report` is set to `true`.
        tracing::error!(
            panic.payload = payload,
            panic.location = panic_info.location().map(|l| l.to_string()),
            "A panic occurred in the Rust code",
        );

        // Invoke the previous panic hook, if any.
        previous_hook(panic_info);
    }));
}
/// Add the current backtrace as a new section to the report printed
/// by RediSearch's INFO command.
///
/// # Safety
///
/// `ctx` must be a valid pointer to a `RedisModuleInfoCtx`.
#[unsafe(no_mangle)]
pub extern "C" fn AddToInfo_RustBacktrace(ctx: Option<NonNull<ffi::RedisModuleInfoCtx>>) {
    use std::ffi::CString;

    let Some(ctx) = ctx else {
        return;
    };

    let backtrace = std::backtrace::Backtrace::force_capture();
    let backtrace_str = backtrace.to_string();

    // The `RedisModule_Info*` functions we need to invoke expect a valid C string.
    // We need to ensure that the backtrace we printed doesn't contain any null bytes and
    // is properly null-terminated.
    //
    // For perf purposes, we strive to avoid allocating a new string if possibleâ€”i.e.
    // if the formatted backtrace string doesn't contain any null bytes.
    let backtrace_cstr = match CString::new(backtrace_str) {
        Ok(cstr) => cstr,
        Err(err) => {
            let mut bytes = err.into_vec();
            for byte in &mut bytes {
                if *byte == 0 {
                    *byte = b'?';
                }
            }
            // SAFETY: We just replaced all null bytes with '?'.
            unsafe { CString::from_vec_unchecked(bytes) }
        }
    };

    // SAFETY: `RedisModule_InfoAddSection` has been initialized during module load.
    let info_add_section = unsafe { ffi::RedisModule_InfoAddSection.unwrap() };
    // SAFETY: `RedisModule_InfoAddFieldCString` has been initialized during module load.
    let info_add_field_cstring = unsafe { ffi::RedisModule_InfoAddFieldCString.unwrap() };

    // SAFETY: `ctx` is a valid pointer to a `RedisModuleInfoCtx`.
    unsafe { info_add_section(ctx.as_ptr(), c"rust_backtrace".as_ptr()) };
    // SAFETY: `ctx` is a valid pointer and `backtrace_cstr` is a valid null-terminated C string.
    unsafe { info_add_field_cstring(ctx.as_ptr(), c"backtrace".as_ptr(), backtrace_cstr.as_ptr()) };
}

/// Intentionally trigger a crash in Rust code,
/// to verify the crash handling mechanism.
///
/// Used by the crash result processor.
#[unsafe(no_mangle)]
pub extern "C" fn CrashInRust() {
    panic!("Crash in Rust code");
}
