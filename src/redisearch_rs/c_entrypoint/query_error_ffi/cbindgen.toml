language = "C"
autogen_warning = "/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/query_error_ffi/build.rs. Don't modify it manually. */"
cpp_compat = true
pragma_once = true
sys_includes = ["rmutil/args.h"]

after_includes = """
// Required to ensure that the alignment declared by cbindgen is respected on
// the C/C++ side.
#define ALIGNED(n) __attribute__((aligned(n)))

/**
 * Convenience macro to reply the error string to redis and clear the error code.
 * I'm making this into a C macro so I don't need to include redismodule.h.
 */
#define QueryError_ReplyAndClear(rctx, qerr)                         \\
  ({                                                                 \\
    RedisModule_ReplyWithError(rctx, QueryError_GetUserError(qerr)); \\
    QueryError_ClearError(qerr);                                     \\
    REDISMODULE_OK;                                                  \\
  })

/** Convenience macro to extract the error string of the argument parser */
#define QERR_MKBADARGS_AC(status, name, rv)                                                     \\
  QueryError_SetWithUserDataFmt(status, QUERY_ERROR_CODE_PARSE_ARGS, "Bad arguments", " for %s: %s", name, \\
                         AC_Strerror(rv))

#define QERR_MKSYNTAXERR(status, message) QueryError_SetError(status, QUERY_ERROR_CODE_SYNTAX, message)

// String constants to warnings. These should be moved to const functions in rust.
#define QUERY_WMAXPREFIXEXPANSIONS "Max prefix expansions limit was reached"
#define QUERY_WINDEXING_FAILURE "Index contains partial data due to an indexing failure caused by insufficient memory"
#define QUERY_WOOM_CLUSTER "One or more shards failed to execute the query due to insufficient memory"
"""

trailer = """
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Set the error code using a custom-formatted string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithUserDataFmt(QueryError *status, QueryErrorCode code, const char* message, const char *fmt, ...);

/**
 * Set the error code using a custom-formatted string
 * Only use this function if you are certain that no user data is leaked in the format string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithoutUserDataFmt(QueryError *status, QueryErrorCode code, const char *fmt, ...);

/**
 * Not implemented in Rust yet as mocking ArgsCursor would be a large lift.
 */
void QueryError_FmtUnknownArg(QueryError *err, ArgsCursor *ac, const char *name);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
"""

[layout]
aligned_n = "ALIGNED"

[parse]
parse_deps = true
include = ["mimic", "query_error"]

[export.rename]
"OpaqueQueryError" = "QueryError"
