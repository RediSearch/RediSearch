language = "C"
autogen_warning = "/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/query_error_ffi/build.rs. Don't modify it manually. */"
cpp_compat = true
pragma_once = true
includes = ["rmalloc.h"]
sys_includes = ["rmutil/args.h"]

after_includes = """
// Required to ensure that the alignment declared by cbindgen is respected on
// the C/C++ side.
#define ALIGNED(n) __attribute__((aligned(n)))

/**
 * Convenience macro to reply the error string to redis and clear the error code.
 * I'm making this into a C macro so I don't need to include redismodule.h.
 */
#define QueryError_ReplyAndClear(rctx, qerr)                         \\
  ({                                                                 \\
    RedisModule_ReplyWithError(rctx, QueryError_GetUserError(qerr)); \\
    QueryError_ClearError(qerr);                                     \\
    REDISMODULE_OK;                                                  \\
  })

/** Convenience macro to extract the error string of the argument parser */
#define QERR_MKBADARGS_AC(status, name, rv)                                                     \\
  QueryError_SetWithUserDataFmt(status, QUERY_EPARSEARGS, "Bad arguments", " for %s: %s", name, \\
                         AC_Strerror(rv))

// String constants to warnings. These should be moved to const functions in rust.
#define QUERY_WMAXPREFIXEXPANSIONS "Max prefix expansions limit was reached"
#define QUERY_WINDEXING_FAILURE "Index contains partial data due to an indexing failure caused by insufficient memory"
#define QUERY_WOOM_CLUSTER "One or more shards failed to execute the query due to insufficient memory"
"""

trailer = """
/**
 * Set the error code using a custom-formatted string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithUserDataFmt(QueryError *status, QueryErrorCode code, const char* message, const char *fmt, ...) {
  char *formatted = NULL;
  va_list ap;
  va_start(ap, fmt);
  rm_vasprintf(&formatted, fmt, ap);
  va_end(ap);

  char *detail = NULL;
  rm_asprintf(&detail, "%s%s", message, formatted);
  rm_free(formatted);

  QueryError_SetError(status, code, message);
  QueryError_SetDetail(status, detail);
  rm_free(detail);
}

/**
 * Set the error code using a custom-formatted string
 * Only use this function if you are certain that no user data is leaked in the format string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithoutUserDataFmt(QueryError *status, QueryErrorCode code, const char *fmt, ...) {
  char *formatted = NULL;
  va_list ap;
  va_start(ap, fmt);
  rm_vasprintf(&formatted, fmt, ap);
  va_end(ap);

  QueryError_SetError(status, code, formatted);
  rm_free(formatted);
}
"""

[layout]
aligned_n = "ALIGNED"

[parse]
parse_deps = true
include = ["mimic", "query_error"]

[export.rename]
"OpaqueQueryError" = "QueryError"
