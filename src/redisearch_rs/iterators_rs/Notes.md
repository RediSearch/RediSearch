# Iterator Design Meeting 20250429

## Meeting Agenda

- Methodology
- Plan Overview
- Sketch of Rust Trait
- Porting RSResultIndex and dependencies

## Methodology

Steps for porting a module to Rust. 

0. Understand the C-side
1. Define and agree on an FFI Interface C -> Rust
2. Hook up existing C Tests, extend Test suite
3. Implement a idiomatic Rust Module
4. Implement Micro Benchmarks
5. Implement the FFI (translation from C idioms to Rust idioms here)
6. After full benchmark: Swap the implementations

## Plan Overview

Before we can work on the iterators we need to port common types like RSResultIndex and it's dependencies.

- Validate Iterator Interface v2 (c side),
  - Is it possible to merge union iterator into master from Guys branch, e.g. with glue code to v1 interface
  - If no Either we have to refactor from v1 to v2 too
  - or we postpone integration
- Agree on FFI interface
  - access patterns to current (RSIndexResult) in different contexts (types), does it change types in place
- Agree on Rust QueryIterator trait
- Agree on Plan to port RSResultIndex (drafted based on assumptions)
- Scaffold the crates / project structure
- Porting & Implementations

## Sketch of Rust trait

```rust
pub trait QueryIterator: Iterator<Item = Result<RSIndexResult, TimeoutError>>  {
    // operations from v2 api of Guy that does not match the idiomatic Rust iterator well.
    fn skip_to(&mut self, doc_id: DocId) -> Option<Result<RSIndexResult, SkipError>>;
    fn rewind(&mut self);

    // fn read() - next in iter methods
    // fn num_estimated() size_hint in iter methods
   

    /// access the RSIndexResult or None
    /// ??? Understand access patterns in different contexts
    fn current(&self) -> Option<<Self as QueryIterator>::Item>;
}
```

## Porting ResultIndex

Still open questions, probably changes in the future.

 - Virtual, Numeric (easy cases)
  - Terms and Aggregates have more dependencies
- RSOffsetVector + RSOffsetIterator (Terms, Aggregates)
  - Iterator generated by MemPool, borrows RSOffsetVector based on Buffer and BufferedReader
  - Iterator has subset of v2 iterator interface
  - RSOffsetIterators Implementation for:
    - Terms
    - Aggregates
- AggregateResult_*, ResultsMetric_*
  - ResultsMetric is an array
  - AggregateResult is a tree

## Open Questions

1. In which cases is RSINdexResult field dmd used?
2. 
1. Access Patterns for iterator.current
  - read/set docI
  - overwrite (e.g. skip)


## Coarse Step Plan

1. Validate if a switch to iterator v2 interface is possible at c-side
  - If so: refactor the C-side to use the the v2 Iterator interface
    - Remove abort, has_next and len
    - IS ReadIterator the only implementor of len?
2. Port RFResultIndex
  - Understand the access patterns
3. Agree on Idiomatic Rust interface
4. Agree on c_api
  - stick to prefix_Read, prefix_Rewind, prefix_SkipTo


## Detailed notes Porting of RSResultIndex

There are four use-cases or types:

1. Virtual 
2. Term
3. Numeric
4. Aggregate (Union, Intersection, HybridMetric)

### Iterator Function Name Prefixes

- EOI - Empty Iterator
- IL - IDList Iterator
- IR - Reader Itertor
- UI - Union Iterator
- II - Intersect Iterator
- NI - Not Iterator
- WI - Wildcard Iterator
- OI - Optional Iterator
- PI - Profile Iterator

### Access Points of current

- AggregateResult_AddChild
- AggregateResult_Reset
- ResultsMetric_Add
- ResultsMetric_Concat
- IndexResult_IsWithinRange
- IndexResult_Free
- IndexResult_Clear
- InsertResult_to_heap
- InsertResult_to_heap_aggregate

### Creators of 

- NewVirtualResult
- NewNumericResult
- NewMetricResult
- NewHybridResult
