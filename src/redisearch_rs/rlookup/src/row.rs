/*
 * Copyright (c) 2006-Present, Redis Ltd.
 * All rights reserved.
 *
 * Licensed under your choice of the Redis Source Available License 2.0
 * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the
 * GNU Affero General Public License v3 (AGPLv3).
*/

#[cfg(debug_assertions)]
use crate::rlookup_id::RLookupId;
use crate::{RLookup, RLookupKey, RLookupKeyFlag, RLookupKeyFlags};
use sorting_vector::RSSortingVector;
use std::{borrow::Cow, ffi::CStr};
use value::RSValueTrait;

/// Row data for a lookup key. This abstracts the question of if the data comes from a borrowed [RSSortingVector]
/// or from dynamic values stored in the row during processing.
///
/// The type itself exposes the dynamic values, [`RLookupRow::dyn_values`], as a vector of `Option<T>`, where `T` is the type
/// of the value and it also provides methods to get the length of the dynamic values and check if they are empty.
///
/// The type `T` is the type of the value stored in the row, which must implement the [`RSValueTrait`].
/// [`RSValueTrait`] is a temporary trait that will be replaced by a type implementing `RSValue` in Rust, see MOD-10347.
///
/// The C-side allocations of values in [`RLookupRow::dyn_values`] and [`RLookupRow::sorting_vector`] are released on drop.
#[derive(Debug)]
pub struct RLookupRow<'a, T: RSValueTrait> {
    /// Sorting vector attached to document
    sorting_vector: Option<&'a RSSortingVector<T>>,

    /// Dynamic values obtained from prior processing
    dyn_values: Vec<Option<T>>,

    /// The number of values in [`RLookupRow::dyn_values`] that are `is_some()`. Note that this
    /// is not the length of [`RLookupRow::dyn_values`]
    num_dyn_values: u32,

    #[cfg(debug_assertions)]
    rlookup_id: RLookupId,
}

impl<'a, T: RSValueTrait> RLookupRow<'a, T> {
    /// Creates a new `RLookupRow` with an empty [`RLookupRow::dyn_values`] vector and
    /// a [`RLookupRow::sorting_vector`] of the given length.
    #[cfg_attr(not(debug_assertions), allow(unused_variables))]
    pub const fn new(rlookup: &RLookup<'_>) -> Self {
        Self {
            sorting_vector: None,
            dyn_values: vec![],
            num_dyn_values: 0,
            #[cfg(debug_assertions)]
            rlookup_id: rlookup.id(),
        }
    }

    /// Returns the length of [`RLookupRow::dyn_values`].
    pub const fn len(&self) -> usize {
        self.dyn_values.len()
    }

    /// Returns true if the [`RLookupRow::dyn_values`] vector is empty.
    pub const fn is_empty(&self) -> bool {
        self.dyn_values.is_empty()
    }

    /// Readonly access to the [`RLookupRow::dyn_values`] vector that has been generated by prior processing.
    ///
    /// The function [`RLookupRow::write_key`] can be used to write values to this vector.
    pub fn dyn_values(&self) -> &[Option<T>] {
        &self.dyn_values
    }

    /// Sets the capacity of the [`RLookupRow::dyn_values`] vector to the given capacity.
    /// It fills up the vector with None values to the given capacity.
    /// This is useful to preallocate memory for the row if you know the number of values that will be written to it.
    pub fn set_dyn_capacity(&mut self, capacity: usize) {
        self.dyn_values.resize(capacity, None);
    }

    /// Readonly access to [`RLookupRow::sorting_vector`], it may be `None` if no sorting vector was set.
    pub const fn sorting_vector(&self) -> Option<&RSSortingVector<T>> {
        self.sorting_vector
    }

    /// Borrow a sorting vector for the row.
    pub const fn set_sorting_vector(&mut self, sv: &'a RSSortingVector<T>) {
        self.sorting_vector = Some(sv);
    }

    /// The number of values in [`RLookupRow::dyn_values`] that are `is_some()`. Note that this
    /// is not the length of [`RLookupRow::dyn_values`]
    pub const fn num_dyn_values(&self) -> u32 {
        self.num_dyn_values
    }

    /// Retrieves an item from the given `RLookupRow` based on the provided `RLookupKey`.
    /// The function first checks for dynamic values, and if not found, it checks the sorting vector
    /// if the `SvSrc` flag is set in the key.
    /// If the item is not found in either location, it returns `None`.
    pub fn get(&self, key: &RLookupKey) -> Option<&T> {
        // Check dynamic values first
        if self.len() > key.dstidx as usize
            && let Some(val) = self
                .dyn_values()
                .get(key.dstidx as usize)
                .expect("value is not in dynamic values even though dstidx is in bounds")
                .as_ref()
        {
            return Some(val);
        }

        // If not found in dynamic values, check the sorting vector if the SvSrc flag is set
        if key.flags.contains(RLookupKeyFlag::SvSrc) {
            self.sorting_vector()?.get(key.svidx as usize)
        } else {
            None
        }
    }

    /// Write a value to the lookup table in [`RLookupRow::dyn_values`]. Key must already be registered, and not
    /// refer to a read-only (SVSRC) key.
    pub fn write_key(&mut self, key: &RLookupKey, val: T) -> Option<T> {
        #[cfg(debug_assertions)]
        assert_eq!(key.rlookup_id(), self.rlookup_id);

        let idx = key.dstidx;
        if self.dyn_values.len() <= idx as usize {
            self.set_dyn_capacity((idx + 1) as usize);
        }

        let prev = self.dyn_values[idx as usize].replace(val);

        if prev.is_none() {
            self.num_dyn_values += 1;
        }

        prev
    }

    /// Write a value to the lookup table *by-name*. This is useful for 'dynamic' keys
    /// for which it is not necessary to use the boilerplate of getting an explicit
    /// key.
    pub fn write_key_by_name(
        &mut self,
        rlookup: &mut RLookup<'a>,
        name: impl Into<Cow<'a, CStr>>,
        val: T,
    ) {
        let name = name.into();
        let key = if let Some(cursor) = rlookup.find_key_by_name(&name) {
            cursor.into_current().expect("the cursor returned by `Keys::find_by_name` must have a current key. This is a bug!")
        } else {
            rlookup
                .get_key_write(name, RLookupKeyFlags::empty())
                .expect("`RLookup::get_key_write` must never return None for non-existent keys. This is a bug!")
        };
        self.write_key(key, val);
    }

    /// Wipes the row, retaining its memory but decrementing the ref count of any included instance of `T`.
    /// This does not free all the memory consumed by the row, but simply resets
    /// the row data (preserving any caches) so that it may be refilled.
    pub fn wipe(&mut self) {
        for value in self.dyn_values.iter_mut().filter(|v| v.is_some()) {
            *value = None;
            self.num_dyn_values -= 1;
        }
    }

    /// Resets the row, clearing the dynamic values. This effectively wipes the row and deallocates the memory used for dynamic values.
    ///
    /// It does not affect the sorting vector.
    pub fn reset_dyn_values(&mut self) {
        self.num_dyn_values = 0;
        self.dyn_values = vec![];
    }

    /// Write fields from a source row into this row, the fields must exist in both lookups (schemas).
    ///
    /// Iterate through the source lookup keys, if it finds a corresponding key in the destination
    /// lookup by name, then it's value is written to this row as a destination.
    ///
    /// If a source key is not found in the destination lookup the function will panic (same as C behavior).
    ///
    /// If a source key has no value in the source row, it is skipped.
    ///
    /// # Arguments
    ///
    /// - `dst_lookup`: The destination lookup containing the schema of this row, must be the associated lookup of `self`.
    /// - `src_row`: The source row from which to copy values.
    /// - `src_lookup`: The source lookup containing the schema of the source row, must be the associated lookup of `src_row`.
    pub fn copy_fields_from(&mut self, dst_lookup: &RLookup, src_row: &Self, src_lookup: &RLookup) {
        let dst_row = self;

        // NB: the `Iterator` impl for `Cursor` will automatically skip overridden keys
        for src_key in src_lookup.cursor() {
            // Get value from source row
            if let Some(value) = src_row.get(src_key) {
                // Find corresponding key in destination lookup
                let dst_key = dst_lookup
                    .find_key_by_name(src_key.name())
                    .expect("we expect all source keys to exist in destination")
                    .into_current()
                    .unwrap();

                // Write fields to destination
                dst_row.write_key(dst_key, value.clone());
            }
        }
    }
}
