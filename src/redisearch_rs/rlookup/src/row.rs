/*
 * Copyright (c) 2006-Present, Redis Ltd.
 * All rights reserved.
 *
 * Licensed under your choice of the Redis Source Available License 2.0
 * (RSALv2); or (b) the Server Side Public License v1 (SSPLv1); or (c) the
 * GNU Affero General Public License v3 (AGPLv3).
*/

use sorting_vector::RSSortingVector;
use value::RSValueTrait;

use crate::RLookupKey;

/// Row data for a lookup key. This abstracts the question of if the data comes from a borrowed [RSSortingVector]
/// or from dynamic values stored in the row during processing.
///
/// The type itself exposes the dynamic values, [`RLookupRow::dyn_values`], as a vector of `Option<T>`, where `T` is the type
/// of the value and it also provides methods to get the length of the dynamic values and check if they are empty.
///
/// The type `T` is the type of the value stored in the row, which must implement the [`RSValueTrait`].
/// [`RSValueTrait`] is a temporary trait that will be replaced by a type implementing `RSValue` in Rust, see MOD-10347.
///
/// The C-side allocations of values in [`RLookupRow::dyn_values`] and [`RLookupRow::sorting_vector`] are released on drop.
#[derive(Debug, Default)]
pub struct RLookupRow<'a, T: RSValueTrait> {
    /// Sorting vector attached to document
    sorting_vector: Option<&'a RSSortingVector<T>>,

    /// Dynamic values obtained from prior processing
    dyn_values: Vec<Option<T>>,

    /// The number of values in [`RLookupRow::dyn_values`] that are `is_some()`. Note that this
    /// is not the length of [`RLookupRow::dyn_values`]
    num_dyn_values: u32,
}

impl<'a, T: RSValueTrait> RLookupRow<'a, T> {
    /// Creates a new `RLookupRow` with an empty [`RLookupRow::dyn_values`] vector and
    /// a [`RLookupRow::sorting_vector`] of the given length.
    pub fn new() -> Self {
        Self {
            sorting_vector: None,
            dyn_values: vec![],
            num_dyn_values: 0,
        }
    }

    /// Returns the length of [`RLookupRow::dyn_values`].
    pub fn len(&self) -> usize {
        self.dyn_values.len()
    }

    /// Returns true if the [`RLookupRow::dyn_values`] vector is empty.
    pub fn is_empty(&self) -> bool {
        self.dyn_values.is_empty()
    }

    /// Readonly access to the [`RLookupRow::dyn_values`] vector that has been generated by prior processing.
    ///
    /// The function [`RLookupRow::write_key`] can be used to write values to this vector.
    pub fn dyn_values(&self) -> &Vec<Option<T>> {
        &self.dyn_values
    }

    /// Sets the capacity of the [`RLookupRow::dyn_values`] vector to the given capacity.
    /// It fills up the vector with None values to the given capacity.
    /// This is useful to preallocate memory for the row if you know the number of values that will be written to it.
    pub fn set_dyn_capacity(&mut self, capacity: usize) {
        self.dyn_values.resize(capacity, None);
    }

    /// Readonly access to [`RLookupRow::sorting_vector`], it may be `None` if no sorting vector was set.
    pub fn sorting_vector(&self) -> Option<&RSSortingVector<T>> {
        self.sorting_vector
    }

    /// Borrow a sorting vector for the row.
    pub fn set_sorting_vector(&mut self, sv: &'a RSSortingVector<T>) {
        self.sorting_vector = Some(sv);
    }

    /// The number of values in [`RLookupRow::dyn_values`] that are `is_some()`. Note that this
    /// is not the length of [`RLookupRow::dyn_values`]
    pub fn num_dyn_values(&self) -> u32 {
        self.num_dyn_values
    }

    /// Write a value to the lookup table in [`RLookupRow::dyn_values`]. Key must already be registered, and not
    /// refer to a read-only (SVSRC) key.
    pub fn write_key(&mut self, key: &RLookupKey, val: T) {
        let idx = key.dstidx;
        if self.dyn_values.len() <= idx as usize {
            self.set_dyn_capacity((idx + 1) as usize);
        }

        let in_place = &mut self.dyn_values[idx as usize];
        if let Some(existing_value) = in_place {
            existing_value.decrement();
            self.num_dyn_values -= 1;
        }

        *in_place = Some(val);
        self.num_dyn_values += 1;
    }

    /// Wipes the row, retaining its memory but decrementing the ref count of any included instance of `T`.
    /// This does not free all the memory consumed by the row, but simply resets
    /// the row data (preserving any caches) so that it may be refilled.    
    pub fn wipe(&mut self) {
        for value in self.dyn_values.iter_mut().filter(|v| v.is_some()) {
            value.as_mut().unwrap().decrement();
            *value = None;
            self.num_dyn_values -= 1;
        }
    }
}

impl<'a, T: RSValueTrait> Drop for RLookupRow<'a, T> {
    fn drop(&mut self) {
        // Wipe the row, decrementing any instances of `T`
        self.wipe();
    }
}
