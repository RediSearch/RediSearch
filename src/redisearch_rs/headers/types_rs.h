#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/types_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "low_memory_thin_vec.h"
/**
 * Forward declarations which will be defined in `redisearch.h`
 */
typedef struct RSQueryTerm RSQueryTerm;
typedef struct RSDocumentMetadata_s RSDocumentMetadata;
typedef struct RSYieldableMetric RSYieldableMetric;
typedef uint64_t t_docId;

/* Copied from `redisearch.h` */
#if (defined(__x86_64__) || defined(__aarch64__) || defined(__arm64__)) && !defined(RS_NO_U128)
/* 64 bit architectures use 128 bit field masks and up to 128 fields */
typedef __uint128_t t_fieldMask;
#else
/* 32 bit architectures use 64 bits and 64 fields only */
typedef uint64_t t_fieldMask;
#endif


/**
 * An iterator over the results in an [`RSAggregateResult`].
 */
typedef struct RSAggregateResultIter RSAggregateResultIter;

/**
 * See the crate's top level documentation for a description of this type.
 */
typedef struct LowMemoryThinVecRSIndexResult {
  Header *ptr;
} LowMemoryThinVecRSIndexResult;

/**
 * Represents a set of flags of some type `T`.
 * `T` must have the `#[bitflags]` attribute applied.
 *
 * A `BitFlags<T>` is as large as the `T` itself,
 * and stores one flag per bit.
 *
 * ## Comparison operators, [`PartialOrd`] and [`Ord`]
 *
 * To make it possible to use `BitFlags` as the key of a
 * [`BTreeMap`][std::collections::BTreeMap], `BitFlags` implements
 * [`Ord`]. There is no meaningful total order for bitflags,
 * so the implementation simply compares the integer values of the bits.
 *
 * Unfortunately, this means that comparing `BitFlags` with an operator
 * like `<=` will compile, and return values that are probably useless
 * and not what you expect. In particular, `<=` does *not* check whether
 * one value is a subset of the other. Use [`BitFlags::contains`] for that.
 *
 * ## Customizing `Default`
 *
 * By default, creating an instance of `BitFlags<T>` with `Default` will result
 * in an empty set. If that's undesirable, you may customize this:
 *
 * ```
 * # use enumflags2::{BitFlags, bitflags};
 * #[bitflags(default = B | C)]
 * #[repr(u8)]
 * #[derive(Copy, Clone, Debug, PartialEq)]
 * enum MyFlag {
 *     A = 0b0001,
 *     B = 0b0010,
 *     C = 0b0100,
 *     D = 0b1000,
 * }
 *
 * assert_eq!(BitFlags::default(), MyFlag::B | MyFlag::C);
 * ```
 *
 * ## Memory layout
 *
 * `BitFlags<T>` is marked with the `#[repr(transparent)]` trait, meaning
 * it can be safely transmuted into the corresponding numeric type.
 *
 * Usually, the same can be achieved by using [`BitFlags::bits`] in one
 * direction, and [`BitFlags::from_bits`], [`BitFlags::from_bits_truncate`],
 * or [`BitFlags::from_bits_unchecked`] in the other direction. However,
 * transmuting might still be useful if, for example, you're dealing with
 * an entire array of `BitFlags`.
 *
 * When transmuting *into* a `BitFlags`, make sure that each set bit
 * corresponds to an existing flag
 * (cf. [`from_bits_unchecked`][BitFlags::from_bits_unchecked]).
 *
 * For example:
 *
 * ```
 * # use enumflags2::{BitFlags, bitflags};
 * #[bitflags]
 * #[repr(u8)] // <-- the repr determines the numeric type
 * #[derive(Copy, Clone)]
 * enum TransmuteMe {
 *     One = 1 << 0,
 *     Two = 1 << 1,
 * }
 *
 * # use std::slice;
 * // NOTE: we use a small, self-contained function to handle the slice
 * // conversion to make sure the lifetimes are right.
 * fn transmute_slice<'a>(input: &'a [BitFlags<TransmuteMe>]) -> &'a [u8] {
 *     unsafe {
 *         slice::from_raw_parts(input.as_ptr() as *const u8, input.len())
 *     }
 * }
 *
 * let many_flags = &[
 *     TransmuteMe::One.into(),
 *     TransmuteMe::One | TransmuteMe::Two,
 * ];
 *
 * let as_nums = transmute_slice(many_flags);
 * assert_eq!(as_nums, &[0b01, 0b11]);
 * ```
 *
 * ## Implementation notes
 *
 * You might expect this struct to be defined as
 *
 * ```ignore
 * struct BitFlags<T: BitFlag> {
 *     value: T::Numeric
 * }
 * ```
 *
 * Ideally, that would be the case. However, because `const fn`s cannot
 * have trait bounds in current Rust, this would prevent us from providing
 * most `const fn` APIs. As a workaround, we define `BitFlags` with two
 * type parameters, with a default for the second one:
 *
 * ```ignore
 * struct BitFlags<T, N = <T as BitFlag>::Numeric> {
 *     value: N,
 *     marker: PhantomData<T>,
 * }
 * ```
 *
 * Manually providing a type for the `N` type parameter shouldn't ever
 * be necessary.
 *
 * The types substituted for `T` and `N` must always match, creating a
 * `BitFlags` value where that isn't the case is only possible with
 * incorrect unsafe code.
 */
typedef uint8_t BitFlags_RSResultKind__u8;

typedef BitFlags_RSResultKind__u8 RSResultKindMask;

/**
 * See the crate's top level documentation for a description of this type.
 */
typedef struct LowMemoryThinVecRSIndexResultOwned {
  Header *ptr;
} LowMemoryThinVecRSIndexResultOwned;

/**
 * Represents an aggregate array of values in an index record.
 *
 * The C code should always use `AggregateResult_New` to construct a new instance of this type
 * using Rust since the internals cannot be constructed directly in C. The reason is because of
 * the `LowMemoryThinVec` which needs to exist in Rust's memory space to ensure its memory is
 * managed correctly.
 */
enum RSAggregateResult_Tag
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  RSAggregateResult_Borrowed,
  RSAggregateResult_Owned,
};
#ifndef __cplusplus
typedef uint8_t RSAggregateResult_Tag;
#endif // __cplusplus

typedef struct RSAggregateResult_Borrowed_Body {
  RSAggregateResult_Tag tag;
  /**
   * The records making up this aggregate result
   *
   * The `RSAggregateResult` is part of a union in [`RSResultData`], so it needs to have a
   * known size. The std `Vec` won't have this since it is not `#[repr(C)]`, so we use our
   * own `LowMemoryThinVec` type which is `#[repr(C)]` and has a known size instead.
   *
   * This requires `'index` on the reference because adding a new lifetime will cause the
   * type to be `LowMemoryThinVec<&'refs RSIndexResult<'index, 'refs>>` which will require
   * `'index: 'refs` else it would mean the `'index` can be cleaned up while some reference
   * will still try to access it (ie a dangling pointer). Now the decoders will never return
   * any aggregate results so `'refs == 'static` when decoding. Because of the requirement
   * above, this means `'index: 'static` which is just incorrect since the index data will
   * never be `'static` when decoding.
   */
  struct LowMemoryThinVecRSIndexResult records;
  /**
   * A map of the aggregate kind of the underlying records
   */
  RSResultKindMask kind_mask;
} RSAggregateResult_Borrowed_Body;

typedef struct RSAggregateResult_Owned_Body {
  RSAggregateResult_Tag tag;
  /**
   * The records making up this aggregate result
   *
   * The `RSAggregateResult` is part of a union in [`RSResultData`], so it needs to have a
   * known size. The std `Vec` won't have this since it is not `#[repr(C)]`, so we use our
   * own `LowMemoryThinVec` type which is `#[repr(C)]` and has a known size instead.
   */
  struct LowMemoryThinVecRSIndexResultOwned records;
  /**
   * A map of the aggregate kind of the underlying records
   */
  RSResultKindMask kind_mask;
} RSAggregateResult_Owned_Body;

typedef union RSAggregateResult {
  RSAggregateResult_Tag tag;
  RSAggregateResult_Borrowed_Body borrowed;
  RSAggregateResult_Owned_Body owned;
} RSAggregateResult;

/**
 * Represents the encoded offsets of a term in a document. You can read the offsets by iterating
 * over it with RSIndexResult_IterateOffsets
 */
typedef struct RSOffsetVector {
  /**
   * At this point the data ownership is still managed by the caller.
   */
  char *data;
  uint32_t len;
} RSOffsetVector;

/**
 * Represents a single record of a document inside a term in the inverted index
 */
enum RSTermRecord_Tag
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  RSTermRecord_Borrowed,
  RSTermRecord_Owned,
};
#ifndef __cplusplus
typedef uint8_t RSTermRecord_Tag;
#endif // __cplusplus

typedef struct RSTermRecord_Borrowed_Body {
  RSTermRecord_Tag tag;
  /**
   * The term that brought up this record
   *
   * This term was created using `NewQueryTerm`, and in the borrowed case, it is actually
   * the owner of the memory. So it should be freed when this record is dropped.
   */
  RSQueryTerm *term;
  /**
   * The encoded offsets in which the term appeared in the document
   *
   * A decoder can choose to borrow this data from the index block, hence the `'index` lifetime.
   */
  struct RSOffsetVector offsets;
} RSTermRecord_Borrowed_Body;

typedef struct RSTermRecord_Owned_Body {
  RSTermRecord_Tag tag;
  /**
   * The term that brought up this record
   *
   * The owned version points to the original borrowed term, and should therefore never clean
   * up this memory.
   */
  RSQueryTerm *term;
  /**
   * The encoded offsets in which the term appeared in the document
   *
   * The owned version will make a copy of the offsets data, hence that `'static` lifetime.
   */
  struct RSOffsetVector offsets;
} RSTermRecord_Owned_Body;

typedef union RSTermRecord {
  RSTermRecord_Tag tag;
  RSTermRecord_Borrowed_Body borrowed;
  RSTermRecord_Owned_Body owned;
} RSTermRecord;

/**
 * Holds the actual data of an ['IndexResult']
 *
 * These enum values should stay in sync with [`RSResultKind`], so that the C union generated matches
 * the bitflags on [`RSResultKindMask`]
 *
 * The `'index` lifetime is linked to the [`crate::IndexBlock`] when decoding borrows from the block.
 */
enum RSResultData_Tag
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  RSResultData_Union = 1,
  RSResultData_Intersection = 2,
  RSResultData_Term = 4,
  RSResultData_Virtual = 8,
  RSResultData_Numeric = 16,
  RSResultData_Metric = 32,
  RSResultData_HybridMetric = 64,
};
#ifndef __cplusplus
typedef uint8_t RSResultData_Tag;
#endif // __cplusplus

typedef union RSResultData {
  RSResultData_Tag tag;
  struct {
    RSResultData_Tag union_tag;
    union RSAggregateResult union_;
  };
  struct {
    RSResultData_Tag intersection_tag;
    union RSAggregateResult intersection;
  };
  struct {
    RSResultData_Tag term_tag;
    union RSTermRecord term;
  };
  struct {
    RSResultData_Tag numeric_tag;
    double numeric;
  };
  struct {
    RSResultData_Tag metric_tag;
    double metric;
  };
  struct {
    RSResultData_Tag hybrid_metric_tag;
    union RSAggregateResult hybrid_metric;
  };
} RSResultData;

/**
 * The result of an inverted index
 */
typedef struct RSIndexResult {
  /**
   * The document ID of the result
   */
  t_docId docId;
  /**
   * Some metadata about the result document
   */
  const RSDocumentMetadata *dmd;
  /**
   * The aggregate field mask of all the records in this result
   */
  t_fieldMask fieldMask;
  /**
   * The total frequency of all the records in this result
   */
  uint32_t freq;
  /**
   * For term records only. This is used as an optimization, allowing the result to be loaded
   * directly into memory
   */
  uint32_t offsetsSz;
  /**
   * The actual data of the result
   */
  union RSResultData data;
  /**
   * Holds an array of metrics yielded by the different iterators in the AST
   */
  RSYieldableMetric *metrics;
  /**
   * Relative weight for scoring calculations. This is derived from the result's iterator weight
   */
  double weight;
} RSIndexResult;

/**
 * Summary information about the key metrics of a block in an inverted index
 */
typedef struct IIBlockSummary {
  t_docId first_doc_id;
  t_docId last_doc_id;
  uintptr_t number_of_entries;
} IIBlockSummary;

/**
 * Summary information about an inverted index containing all key metrics
 */
typedef struct IISummary {
  uintptr_t number_of_docs;
  uintptr_t number_of_entries;
  t_docId last_doc_id;
  uint64_t flags;
  uintptr_t number_of_blocks;
  double block_efficiency;
  bool has_efficiency;
} IISummary;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Check if the result is an aggregate result.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
bool IndexResult_IsAggregate(const struct RSIndexResult *result);

/**
 * Get the numeric value of the result if it is a numeric result. If the result is not numeric,
 * this function will return `0.0`.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
double IndexResult_NumValue(const struct RSIndexResult *result);

/**
 * Set the numeric value of the result if it is a numeric result. If the result is not numeric,
 * this function will do nothing.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
void IndexResult_SetNumValue(struct RSIndexResult *result, double value);

/**
 * Get the query term from a result if it is a term result. If the result is not a term, then
 * this function will return a `NULL` pointer.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
RSQueryTerm *IndexResult_QueryTermRef(const struct RSIndexResult *result);

/**
 * Get the term offsets from a result if it is a term result. If the result is not a term, then
 * this function will return a `NULL` pointer.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
const struct RSOffsetVector *IndexResult_TermOffsetsRef(const struct RSIndexResult *result);

/**
 * Get a mutable term offsets from a result if it is a term result. If the result is not a term,
 * then this function will return a `NULL` pointer.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
struct RSOffsetVector *IndexResult_TermOffsetsRefMut(struct RSIndexResult *result);

/**
 * Get the aggregate result reference if the result is an aggregate result. If the result is
 * not an aggregate, this function will return a `NULL` pointer.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
const union RSAggregateResult *IndexResult_AggregateRef(const struct RSIndexResult *result);

/**
 * Reset the result if it is an aggregate result. This will clear all children and reset the kind mask.
 * This function does not deallocate the children pointers, but rather resets the internal state of the
 * aggregate result. The owner of the children pointers is responsible for managing their lifetime.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `result` must point to a valid `RSIndexResult` and cannot be NULL.
 */
void IndexResult_AggregateReset(struct RSIndexResult *result);

/**
 * Get the result at the specified index in the aggregate result. This will return a `NULL` pointer
 * if the index is out of bounds.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `agg` must point to a valid `RSAggregateResult` and cannot be NULL.
 * - The memory address at `index` should still be valid and not have been deallocated.
 */
const struct RSIndexResult *AggregateResult_Get(const union RSAggregateResult *agg,
                                                uintptr_t index);

/**
 * Get the element count of the aggregate result.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `agg` must point to a valid `RSAggregateResult` and cannot be NULL.
 */
uintptr_t AggregateResult_NumChildren(const union RSAggregateResult *agg);

/**
 * Get the capacity of the aggregate result.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `agg` must point to a valid `RSAggregateResult` and cannot be NULL.
 */
uintptr_t AggregateResult_Capacity(const union RSAggregateResult *agg);

/**
 * Get the kind mask of the aggregate result.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `agg` must point to a valid `RSAggregateResult` and cannot be NULL.
 */
uint8_t AggregateResult_KindMask(const union RSAggregateResult *agg);

/**
 * Create a new aggregate result with the specified capacity. This function will make the result
 * in Rust memory, but the ownership ends up being transferred to C's memory space. This ownership
 * should return to Rust to free up any heap memory using [`AggregateResult_Free`].
 */
union RSAggregateResult AggregateResult_New(uintptr_t cap);

/**
 * Take ownership of a `RSAggregateResult` to free any heap memory it owns. This function will not
 * free the individual children pointers, but rather the heap allocations owned by the aggregate
 * result itself (such as the internal vector buffer). The caller is responsible for managing the
 * memory of the children pointers before this call if needed.
 *
 * The `agg` parameter should have been created with [`AggregateResult_New`].
 */
void AggregateResult_Free(union RSAggregateResult agg);

/**
 * Add a child to a result if it is an aggregate result. Note, if `parent` only hold references
 * to results, then it will not take ownership of the `child` and will therefore not free it.
 * Instead, the caller is responsible for managing the memory of the `child` pointer *after* the
 * `parent` has been freed.
 *
 * If the `parent` is not an aggregate kind, then this is a no-op.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `parent` must point to a valid `RSIndexResult` and cannot be NULL.
 * - `child` must point to a valid `RSIndexResult` and cannot be NULL.
 */
void AggregateResult_AddChild(struct RSIndexResult *parent, struct RSIndexResult *child);

/**
 * Create an iterator over the aggregate result. This iterator should be freed
 * using [`AggregateResultIter_Free`].
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `agg` must point to a valid `RSAggregateResult` and cannot be NULL.
 */
struct RSAggregateResultIter *AggregateResult_Iter(const union RSAggregateResult *agg);

/**
 * Get the next item in the aggregate result iterator and put it into the provided `value`
 * pointer. This function will return `true` if there is a next item, or `false` if the iterator
 * is exhausted.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `iter` must point to a valid `RSAggregateResultIter` and cannot be NULL.
 * - `value` must point to a valid pointer where the next item will be stored.
 * - All the memory addresses of the `RSAggregateResult` should still be valid and not have
 *   been deallocated.
 */
bool AggregateResultIter_Next(struct RSAggregateResultIter *iter, struct RSIndexResult **value);

/**
 * Free the aggregate result iterator. This function will deallocate the memory used by the iterator.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `iter` must point to a valid `RSAggregateResultIter`.
 * - The iterator must have been created using [`AggregateResult_Iter`].
 */
void AggregateResultIter_Free(struct RSAggregateResultIter *iter);

/**
 * Retrieve the offsets array from [`RSOffsetVector`].
 *
 * Set the array length into the `len` pointer.
 * The returned array is borrowed from the [`RSOffsetVector`] and should not be modified.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `offsets` must point to a valid [`RSOffsetVector`] and cannot be NULL.
 * - `len` cannot be NULL and must point to an allocated memory big enough to hold an u32.
 */
const char *RSOffsetVector_GetData(const struct RSOffsetVector *offsets, uint32_t *len);

/**
 * Set the offsets array on a [`RSOffsetVector`].
 *
 * The [`RSOffsetVector`] will borrow the passed array so it's up to the caller to
 * ensure it stays alive during the [`RSOffsetVector`] lifetime.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `offsets` must point to a valid [`RSOffsetVector`] and cannot be NULL.
 * - `data` must point to an array of `len` offsets.
 * - if `data` is NULL then `len` should be 0.
 */
void RSOffsetVector_SetData(struct RSOffsetVector *offsets, const char *data, uint32_t len);

/**
 * Free the data inside an [`RSOffsetVector`]'s offset
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `offsets` must point to a valid [`RSOffsetVector`] and cannot be NULL.
 * - The data pointer of `offsets` had been allocated via the global allocator
 *   and points to an array matching the length of `offsets`.
 */
void RSOffsetVector_FreeData(struct RSOffsetVector *offsets);

/**
 * Copy the data from one offset vector to another.
 *
 * Deep copies the data array from `src` to `dest`.
 * It's up to the caller to free the copied array using [`RSOffsetVector_FreeData`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `dest` must point to a valid [`RSOffsetVector`] and cannot be NULL.
 * - `src` must point to a valid [`RSOffsetVector`] and cannot be NULL.
 * - `src` data should point to a valid array of `src.len` offsets.
 */
void RSOffsetVector_CopyData(struct RSOffsetVector *dest, const struct RSOffsetVector *src);

/**
 * Retrieve the number of offsets in [`RSOffsetVector`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `offsets` must point to a valid [`RSOffsetVector`] and cannot be NULL.
 */
uint32_t RSOffsetVector_Len(const struct RSOffsetVector *offsets);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
