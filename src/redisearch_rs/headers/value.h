#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/value_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "redismodule.h"
// Required to ensure that the alignment declared by cbindgen is respected on
// the C/C++ side.
#define ALIGNED(n) __attribute__((aligned(n)))

// Required to ensure that the layout declared by cbindgen is respected on
// the C/C++ side
#define PACKED __attribute__((packed))


/**
 * Enumeration of the types an [`RsValue`] can be of.
 *
 */
typedef enum RsValueType {
  RsValueType_Undef = 0,
  RsValueType_Number = 1,
  RsValueType_String = 2,
  RsValueType_Null = 3,
  RsValueType_RedisString = 4,
  RsValueType_Array = 5,
  RsValueType_Reference = 6,
  RsValueType_Trio = 7,
  RsValueType_Map = 8,
} RsValueType;

/**
 * An actual [`RsValue`] object
 */
typedef struct RsValue RsValue;

/**
 * A shared RedisSearch dynamic value, backed by an `Arc<RsValue>`.
 */
typedef struct SharedRsValue SharedRsValue;

/**
 * A single entry of a [`RsValueMap`].
 */
typedef struct RsValueMapEntry {
  struct SharedRsValue key;
  struct SharedRsValue value;
} RsValueMapEntry;

/**
 * An low-memory immutable structure that holds and manages a set of
 * T items.
 *
 * This collection's capacity is represented by an `u32` and the
 * collection itself is `#[repr(C, packed)]` so that it's size is just
 * 12 bytes.
 *
 * # Invariants
 * - (1) Can hold at most [`Self::MAX_CAPACITY`] items, which on 32-bit systems
 *   is less than `u32::MAX`. The reason for this is that when doing pointer
 *   addition, we must ensure we don't overflow `isize::MAX`.
 *   See [`NonNull::add`].
 */
typedef struct PACKED RsValueCollection_RsValueMapEntry {
  /**
   * Pointer to a heap-allocated array of `Self::cap` items.
   */
  struct RsValueMapEntry *entries;
  /**
   * The number of items this collection can hold
   */
  uint32_t cap;
} RsValueCollection_RsValueMapEntry;

typedef struct RsValueCollection_RsValueMapEntry RsValueMap;

/**
 * An low-memory immutable structure that holds and manages a set of
 * T items.
 *
 * This collection's capacity is represented by an `u32` and the
 * collection itself is `#[repr(C, packed)]` so that it's size is just
 * 12 bytes.
 *
 * # Invariants
 * - (1) Can hold at most [`Self::MAX_CAPACITY`] items, which on 32-bit systems
 *   is less than `u32::MAX`. The reason for this is that when doing pointer
 *   addition, we must ensure we don't overflow `isize::MAX`.
 *   See [`NonNull::add`].
 */
typedef struct PACKED RsValueCollection_SharedRsValue {
  /**
   * Pointer to a heap-allocated array of `Self::cap` items.
   */
  struct SharedRsValue *entries;
  /**
   * The number of items this collection can hold
   */
  uint32_t cap;
} RsValueCollection_SharedRsValue;

typedef struct RsValueCollection_SharedRsValue RsValueArray;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new, uninitialized [`RsValueMap`], reserving space for `cap`
 * entries. The map entries are uninitialized and must be set using [`RsValueMap_SetEntry`].
 *
 * # Safety
 * - (1) All items of the returned [`RsValueMap`] must be initialized using
 *   [`RsValueMap_SetEntry`] prior to using it.
 *
 * @param cap the number of entries (key and value) the map needs to store
 * @returns an uninitialized `RsValueMap` of `cap` capacity.
 */
RsValueMap RsValueMap_AllocUninit(uint32_t cap);

/**
 * Set a key-value pair at a specific index in the map.
 * Takes ownership of both the key and value RSValues.
 *
 * # Safety
 * - (1) `map` must be a valid pointer to an [`RsValueMap`] that
 *   has been created by [`RsValueMap_AllocUninit`] and
 *   that is valid for writes;
 * - (2) `i` must smaller than the capacity of the [`RsValueMap`],
 *   which cannot exceed [`u32::MAX`].
 * - (3) `key` and `value` must be valid pointers to [`RsValue`]
 *   obtained from [`SharedRsValue::into_raw`].
 *
 * @param map The map to modify
 * @param i The index where to set the entry (must be < map->len)
 * @param key The key RSValue (ownership is transferred to the map)
 * @param value The value RSValue (ownership is transferred to the map)
 */
void RsValueMap_SetEntry(RsValueMap *map,
                         size_t i,
                         const struct RsValue *key,
                         const struct RsValue *value);

/**
 * Allocates an uninitialized [`RsValueArray`].
 *
 * # Safety
 * See [`RsValueCollection::reserve_uninit`](value::collection::RsValueCollection::reserve_uninit)
 *
 * @param cap The desired capacity of the [`RsValueArray`]
 * @return An uninitialized `RsValueArray` of `cap` capacity
 */
RsValueArray RsValueArray_AllocUninit(uint32_t cap);

/**
 * Writes a value into the [`RsValueArray`] at `i`.
 *
 * # Safety
 * - (1) `arr` must be a non-null pointer to an [`RsValueArray`] originating from
 *   [`RsValueArray_AllocUninit`];
 * - (2) `arr` must be unique;
 * - (3) `i` must not exceed the [`RsValueArray`]'s capacity, which cannot
 *   exceed [`u32::MAX`].
 * - (4) `value` must be a valid pointer to [`RsValue`]
 *   obtained from [`SharedRsValue::into_raw`].
 *
 * @param arr The array to modify
 * @param i The index at which to write the value
 * @param value the value that is to be written
 */
void RsValueArray_SetEntry(RsValueArray *arr, size_t i, const struct RsValue *value);

/**
 * Creates and returns a new **owned** [`RsValue`] object of type undefined.
 *
 * The caller must make sure to pass the returned [`RsValue`] to one of the
 * ownership taking `RSValue_` methods, directly or indirectly.
 */
struct RsValue *RSValue_NewUndefined(void);

/**
 * Creates and returns a new **owned** [`RsValue`] object of type null.
 *
 * The caller must make sure to pass the returned [`RsValue`] to one of the
 * ownership taking `RSValue_` methods, directly or indirectly.
 */
struct RsValue *RSValue_NewNull(void);

/**
 * Creates and returns a new **owned** [`RsValue`] object of type number
 * containing the given numeric value.
 *
 * The caller must make sure to pass the returned [`RsValue`] to one of the
 * ownership taking `RSValue_` methods, directly or indirectly.
 */
struct RsValue *RSValue_NewNumber(double value);

/**
 * Creates and returns a new **owned** [`RsValue`] object of type trio from three [`RsValue`]s.
 *
 * Takes ownership of all three arguments.
 *
 * The caller must make sure to pass the returned [`RsValue`] to one of the
 * ownership taking `RSValue_` methods, directly or indirectly.
 *
 * # Safety
 *
 * 1. All three arguments must point to a valid **owned** [`RsValue`] obtained from an
 *    `RSValue_*` function returning an owned [`RsValue`] object.
 */
struct RsValue *RSValue_NewTrio(struct RsValue *left,
                                struct RsValue *middle,
                                struct RsValue *right);

/**
 * Gets the numeric value from an [`RsValue`].
 *
 * # Safety
 *
 * 1. `value` must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 *
 * # Panic
 *
 * Panics if the value is not a number type.
 */
double RSValue_Number_Get(const struct RsValue *value);

/**
 * Borrows an immutable reference to the left value of a trio.
 *
 * # Safety
 *
 * 1. `value` must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 *
 * # Panic
 *
 * Panics if the value is not a trio type.
 */
const struct RsValue *RSValue_Trio_GetLeft(const struct RsValue *value);

/**
 * Borrows an immutable reference to the middle value of a trio.
 *
 * # Safety
 *
 * 1. `value` must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 *
 * # Panic
 *
 * Panics if the value is not a trio type.
 */
const struct RsValue *RSValue_Trio_GetMiddle(const struct RsValue *value);

/**
 * Borrows an immutable reference to the right value of a trio.
 *
 * # Safety
 *
 * 1. `value` must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 *
 * # Panic
 *
 * Panics if the value is not a trio type.
 */
const struct RsValue *RSValue_Trio_GetRight(const struct RsValue *value);

/**
 * Converts an [`RsValue`] to a number type in-place.
 *
 * This clears the existing value and sets it to Number with the given value.
 *
 * # Safety
 *
 * 1. `value` must point to a valid **owned** [`RsValue`] obtained from an
 *    `RSValue_*` function returning an owned [`RsValue`] object.
 * 2. Only 1 reference is allowed to exist pointing to this [`RsValue`] object.
 *
 * # Panic
 *
 * Panics if more than 1 reference exists to this [`RsValue`] object.
 */
void RSValue_SetNumber(struct RsValue *value, double n);

/**
 * Converts an [`RsValue`] to null type in-place.
 *
 * This clears the existing value and sets it to Null.
 *
 * # Safety
 *
 * 1. `value` must point to a valid **owned** [`RsValue`] obtained from an
 *    `RSValue_*` function returning an owned [`RsValue`] object.
 * 2. Only 1 reference is allowed to exist pointing to this [`RsValue`] object.
 *
 * # Panic
 *
 * Panics if more than 1 reference exists to this [`RsValue`] object.
 */
void RSValue_SetNull(struct RsValue *value);

/**
 * Creates a heap-allocated `RsValue` by parsing a string as a number.
 * Returns an undefined value if the string cannot be parsed as a valid number.
 *
 * # Safety
 * - (1) `str` must be a valid const pointer to a char sequence of `len` bytes.
 *
 * @param p The string to parse
 * @param l The length of the string
 * @return A pointer to a heap-allocated `RsValue`
 */
const struct RsValue *SharedRsValue_NewParsedNumber(const char *str, uintptr_t len);

/**
 * Creates a heap-allocated `RsValue` containing a number from an int64.
 * This operation casts the passed `i64` to an `f64`, possibly losing information.
 *
 * @param ii The int64 value to convert and wrap
 * @return A pointer to a heap-allocated `RsValue` of type `RsValueType_Number`
 */
const struct RsValue *SharedRsValue_NewNumberFromInt64(int64_t dd);

/**
 * Creates a heap-allocated `RsValue` array from existing values.
 * Takes ownership of the values (values will be freed when array is freed).
 *
 * @param vals The values array to use for the array (ownership is transferred)
 * @param len Number of values
 * @return A pointer to a heap-allocated `RsValue` of type `RsValueType_Array`
 */
const struct RsValue *SharedRsValue_NewArray(RsValueArray vals);

/**
 * Creates a heap-allocated RsValue of type RsValue_Map from an RsValueMap.
 * Takes ownership of the map structure and all its entries.
 *
 * @param map The RsValueMap to wrap (ownership is transferred)
 * @return A pointer to a heap-allocated RsValue of type RsValueType_Map
 */
const struct RsValue *SharedRsValue_NewMap(RsValueMap map);

/**
 * Returns the type of the given [`RsValue`].
 *
 * # Safety
 *
 * 1. `value` must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 */
enum RsValueType RSValue_Type(const struct RsValue *value);

/**
 * Returns whether the given [`RsValue`] is a reference type, or `false` if `value` is NULL.
 *
 * # Safety
 *
 * 1. If `value` is non-null, it must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 */
bool RSValue_IsReference(const struct RsValue *value);

/**
 * Returns whether the given [`RsValue`] is a number type, or `false` if `value` is NULL.
 *
 * # Safety
 *
 * 1. If `value` is non-null, it must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 */
bool RSValue_IsNumber(const struct RsValue *value);

/**
 * Returns whether the given [`RsValue`] is a string type (any string variant), or `false` if `value` is NULL.
 *
 * # Safety
 *
 * 1. If `value` is non-null, it must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 */
bool RSValue_IsString(const struct RsValue *value);

/**
 * Returns whether the given [`RsValue`] is an array type, or `false` if `value` is NULL.
 *
 * # Safety
 *
 * 1. If `value` is non-null, it must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 */
bool RSValue_IsArray(const struct RsValue *value);

/**
 * Returns whether the given [`RsValue`] is a trio type, or `false` if `value` is NULL.
 *
 * # Safety
 *
 * 1. If `value` is non-null, it must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 */
bool RSValue_IsTrio(const struct RsValue *value);

/**
 * Returns whether the given [`RsValue`] is a null pointer, a null type, or a reference to a null type.
 *
 * # Safety
 *
 * 1. If `value` is non-null, it must point to a valid [`RsValue`] obtained from an `RSValue_*` function.
 */
bool RSValue_IsNull(const struct RsValue *value);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
