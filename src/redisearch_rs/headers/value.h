#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/value_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "redismodule.h"
// Required to ensure that the alignment declared by cbindgen is respected on
// the C/C++ side.
#define ALIGNED(n) __attribute__((aligned(n)))

// Required to ensure that the layout declared by cbindgen is respected on
// the C/C++ side
#define PACKED __attribute__((packed))


/**
 * Enumeration of the types an `RsValue` can be of for
 * compatibility with the traditional C enum setup.
 *
 */
typedef enum RsValueType {
  RsValueType_Undef = 0,
  RsValueType_Number = 1,
  RsValueType_String = 2,
  RsValueType_Null = 3,
  RsValueType_RedisString = 4,
  RsValueType_Array = 5,
  RsValueType_Reference = 6,
  RsValueType_Trio = 7,
  RsValueType_Map = 8,
} RsValueType;

/**
 * An actual [`RsValue`] object
 */
typedef struct RsValue RsValue;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

struct RsValue **RSValue_AllocateArray(uintptr_t len);

struct RsValue *RSValue_NewArray(struct RsValue **vals, uint32_t len);

uint32_t RSValue_ArrayLen(const struct RsValue *value);

struct RsValue *RSValue_ArrayItem(const struct RsValue *value, uint32_t index);

/**
 * Creates a heap-allocated `RsValue` wrapping a string.
 * Doesn't duplicate the string. Use strdup if the value needs to be detached.
 *
 * # Safety
 * - (1) `str` must not be NULL;
 * - (2) `len` must match the length of `str`;
 * - (3) `str` must point to a valid, C string with a length of at most `u32::MAX` bytes;
 * - (4) `str` must not be aliased.
 * - (5) `str` must point to a location allocated using `rm_alloc`
 * - (6) `RedisModule_Alloc` must not be mutated for the lifetime of the
 *   `OpaqueRsValue`.
 *
 * @param str The string to wrap (ownership is transferred)
 * @param len The length of the string
 * @return A pointer to a heap-allocated RsValue
 */
const struct RsValue *SharedRsValue_NewString(char *str, uint32_t len);

/**
 * Creates a heap-allocated `SharedRsValue` wrapping a const string.
 *
 * # Safety
 * - (1) `str` must live as least as long as the returned [`SharedRsValue`].
 * - (2) `str` must point to a byte sequence that is valid for reads of `len` bytes.
 *
 * @param str The null-terminated string to wrap (ownership is transferred)
 * @return A pointer to a heap-allocated RsValue wrapping a constant C string
 */
const struct RsValue *SharedRsValue_NewConstString(const char *str, uint32_t len);

/**
 * Creates a heap-allocated `RsValue` which increments and owns a reference to the Redis string.
 * The RsValue will decrement the refcount when freed.
 *
 * # Safety
 * - (1) `str` must be non-null
 * - (2) `str` must point to a valid [`RedisModuleString`]
 *   with a reference count of at least 1.
 *
 * @param str The RedisModuleString to wrap (refcount is incremented)
 * @return A pointer to a heap-allocated RsValue
 */
const struct RsValue *SharedRsValue_NewRedisString(RedisModuleString *str);

/**
 * Creates a heap-allocated `RsValue` with a copied string.
 * The string is duplicated using `rm_malloc`.
 *
 * # Safety
 * - (1) `str` must be a valid pointer to a char sequence of `len` chars.
 *
 * @param s The string to copy
 * @param dst The length of the string to copy
 * @return A pointer to a heap-allocated `RsValue` owning the copied string
 */
const struct RsValue *SharedRsValue_NewCopiedString(const char *str, uint32_t len);

/**
 * Creates a heap-allocated `RsValue` by parsing a string as a number.
 * Returns an undefined value if the string cannot be parsed as a valid number.
 *
 * # Safety
 * - (1) `str` must be a valid const pointer to a char sequence of `len` bytes.
 *
 * @param p The string to parse
 * @param l The length of the string
 * @return A pointer to a heap-allocated `RsValue`
 */
const struct RsValue *SharedRsValue_NewParsedNumber(const char *str, uintptr_t len);

/**
 * Creates a heap-allocated `RsValue` containing a number.
 *
 * @param n The numeric value to wrap
 * @return A pointer to a heap-allocated `RsValue` of type `RsValueType_Number`
 */
const struct RsValue *SharedRsValue_NewNumber(double n);

/**
 * Creates a heap-allocated `RsValue` containing a number from an int64.
 * This operation casts the passed `i64` to an `f64`, possibly losing information.
 *
 * @param ii The int64 value to convert and wrap
 * @return A pointer to a heap-allocated `RsValue` of type `RsValueType_Number`
 */
const struct RsValue *SharedRsValue_NewNumberFromInt64(int64_t dd);

/**
 * Creates a heap-allocated RsValue Trio from three RsValues.
 * Takes ownership of all three values.
 *
 * # Safety
 *
 * - (1) `left`, `middle`, and `right` must be valid pointers to [`RsValue`]
 *   obtained from [`SharedRsValue::into_raw`].
 *
 * @param left The left value (ownership is transferred)
 * @param middle The middle value (ownership is transferred)
 * @param right The right value (ownership is transferred)
 * @return A pointer to a heap-allocated RsValue of type RsValueType_Trio
 */
const struct RsValue *SharedRsValue_NewTrio(const struct RsValue *left,
                                            const struct RsValue *middle,
                                            const struct RsValue *right);

/**
 * Gets the `f64` wrapped by the `SharedRsValue`
 *
 * # Safety
 * - (1) `v` must be a valid pointer to [`RsValue`] obtained from [`SharedRsValue::into_raw`].
 * - (2) `v` must be a number value.
 */
double SharedRsValue_Number_Get(const struct RsValue *v);

/**
 * Get the type of an RSValue.
 *
 * @param v The value to inspect
 * @return The RSValueType of the
 *
 * # SAFETY
 *
 * - `value` must point to a valid `RSValue` returned by
 *   one of the `RSValue_` functions and cannot be NULL.
 */
enum RsValueType RSValue_Type(const struct RsValue *value);

/**
 * Check if the RSValue is a reference type.
 *
 * @param v The value to check
 * @return true if the value is of type RSValueType_Reference, false otherwise
 *
 * # SAFETY
 *
 * - `value` is either NULL or must point to a valid
 *   `RSValue` returned by one of the `RSValue_` functions.
 */
bool RSValue_IsReference(const struct RsValue *value);

/**
 * Check if the RSValue is a number type.
 *
 * @param v The value to check
 * @return true if the value is of type RSValueType_Number, false otherwise
 *
 * # SAFETY
 *
 * - `value` is either NULL or must point to a valid
 *   `RSValue` returned by one of the `RSValue_` functions.
 */
bool RSValue_IsNumber(const struct RsValue *value);

/**
 * Check if the RSValue is of a string type.
 *
 * @param v The value to check
 * @return true if the value is of type RSValueType_String or RSValueType_RedisString, false otherwise
 *
 * # SAFETY
 *
 * - `value` is either NULL or must point to a valid
 *   `RSValue` returned by one of the `RSValue_` functions.
 */
bool RSValue_IsString(const struct RsValue *value);

/**
 * Check if the RSValue is an array type.
 *
 * @param v The value to check
 * @return true if the value is of type RSValueType_Array, false otherwise
 *
 * # SAFETY
 *
 * - `value` is either NULL or must point to a valid
 *   `RSValue` returned by one of the `RSValue_` functions.
 */
bool RSValue_IsArray(const struct RsValue *value);

/**
 * Check whether the RSValue is of type RSValueType_Trio.
 *
 * @param v The value to check
 * @return true if the value is of type RSValueType_Trio, false otherwise
 *
 * # SAFETY
 *
 * - `value` is either NULL or must point to a valid
 *   `RSValue` returned by one of the `RSValue_` functions.
 */
bool RSValue_IsTrio(const struct RsValue *value);

/**
 * Return 1 if the value is NULL, RSValueType_Null or a reference to RSValue_NullStatic
 *
 * # SAFETY
 *
 * - `value` is either NULL or must point to a valid
 *   `RSValue` returned by one of the `RSValue_` functions.
 */
bool RSValue_IsNull(const struct RsValue *value);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
