#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/query_error_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <rmutil/args.h>
#include <rmutil/rm_assert.h>
#include "rmalloc.h"
// Required to ensure that the alignment declared by cbindgen is respected on
// the C/C++ side.
#define ALIGNED(n) __attribute__((aligned(n)))

/**
 * Convenience macro to reply the error string to redis and clear the error code.
 * I'm making this into a C macro so I don't need to include redismodule.h.
 */
#define QueryError_ReplyAndClear(rctx, qerr)                         \
  ({                                                                 \
    RedisModule_ReplyWithError(rctx, QueryError_GetUserError(qerr)); \
    QueryError_ClearError(qerr);                                     \
    REDISMODULE_OK;                                                  \
  })

/** Convenience macro to extract the error string of the argument parser */
#define QERR_MKBADARGS_AC(status, name, rv)                                                     \
  QueryError_SetWithUserDataFmt(status, QUERY_ERROR_CODE_PARSE_ARGS, "Bad arguments", " for %s: %s", name, \
                         AC_Strerror(rv))

#define QERR_MKSYNTAXERR(status, message) QueryError_SetError(status, QUERY_ERROR_CODE_SYNTAX, message)

// String constants to warnings. These should be moved to const functions in rust.
#define QUERY_WMAXPREFIXEXPANSIONS "Max prefix expansions limit was reached"
#define QUERY_WINDEXING_FAILURE "Index contains partial data due to an indexing failure caused by insufficient memory"
#define QUERY_WOOM_CLUSTER "One or more shards failed to execute the query due to insufficient memory"


enum QueryErrorCode
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  QUERY_ERROR_CODE_NONE = 0,
  QUERY_ERROR_CODE_GENERIC,
  QUERY_ERROR_CODE_SYNTAX,
  QUERY_ERROR_CODE_PARSE_ARGS,
  QUERY_ERROR_CODE_ADD_ARGS,
  QUERY_ERROR_CODE_EXPR,
  QUERY_ERROR_CODE_KEYWORD,
  QUERY_ERROR_CODE_NO_RESULTS,
  QUERY_ERROR_CODE_BAD_ATTR,
  QUERY_ERROR_CODE_INVAL,
  QUERY_ERROR_CODE_BUILD_PLAN,
  QUERY_ERROR_CODE_CONSTRUCT_PIPELINE,
  QUERY_ERROR_CODE_NO_REDUCER,
  QUERY_ERROR_CODE_REDUCER_GENERIC,
  QUERY_ERROR_CODE_AGG_PLAN,
  QUERY_ERROR_CODE_CURSOR_ALLOC,
  QUERY_ERROR_CODE_REDUCER_INIT,
  QUERY_ERROR_CODE_Q_STRING,
  QUERY_ERROR_CODE_NO_PROP_KEY,
  QUERY_ERROR_CODE_NO_PROP_VAL,
  QUERY_ERROR_CODE_NO_DOC,
  QUERY_ERROR_CODE_NO_OPTION,
  QUERY_ERROR_CODE_REDIS_KEY_TYPE,
  QUERY_ERROR_CODE_INVAL_PATH,
  QUERY_ERROR_CODE_INDEX_EXISTS,
  QUERY_ERROR_CODE_BAD_OPTION,
  QUERY_ERROR_CODE_BAD_ORDER_OPTION,
  QUERY_ERROR_CODE_LIMIT,
  QUERY_ERROR_CODE_NO_INDEX,
  QUERY_ERROR_CODE_DOC_EXISTS,
  QUERY_ERROR_CODE_DOC_NOT_ADDED,
  QUERY_ERROR_CODE_DUP_FIELD,
  QUERY_ERROR_CODE_GEO_FORMAT,
  QUERY_ERROR_CODE_NO_DISTRIBUTE,
  QUERY_ERROR_CODE_UNSUPP_TYPE,
  QUERY_ERROR_CODE_NOT_NUMERIC,
  QUERY_ERROR_CODE_TIMED_OUT,
  QUERY_ERROR_CODE_NO_PARAM,
  QUERY_ERROR_CODE_DUP_PARAM,
  QUERY_ERROR_CODE_BAD_VAL,
  QUERY_ERROR_CODE_NON_HYBRID,
  QUERY_ERROR_CODE_HYBRID_NON_EXIST,
  QUERY_ERROR_CODE_ADHOC_WITH_BATCH_SIZE,
  QUERY_ERROR_CODE_ADHOC_WITH_EF_RUNTIME,
  QUERY_ERROR_CODE_NON_RANGE,
  QUERY_ERROR_CODE_MISSING,
  QUERY_ERROR_CODE_MISMATCH,
  QUERY_ERROR_CODE_UNKNOWN_INDEX,
  QUERY_ERROR_CODE_DROPPED_BACKGROUND,
  QUERY_ERROR_CODE_ALIAS_CONFLICT,
  QUERY_ERROR_CODE_INDEX_BG_OOM_FAIL,
  QUERY_ERROR_CODE_WEIGHT_NOT_ALLOWED,
  QUERY_ERROR_CODE_VECTOR_NOT_ALLOWED,
  QUERY_ERROR_CODE_OUT_OF_MEMORY,
};
#ifndef __cplusplus
typedef uint8_t QueryErrorCode;
#endif // __cplusplus

/**
 * A type with size `N`.
 */
typedef uint8_t Size_38[38];

/**
 * An opaque query error which can be passed by value to C.
 *
 * The size and alignment of this struct must match the rust structure exactly.
 */
typedef struct ALIGNED(8) QueryError {
  Size_38 _0;
} QueryError;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

struct QueryError QueryError_Default(void);

bool QueryError_IsOk(const struct QueryError *query_error);

bool QueryError_HasError(const struct QueryError *query_error);

const char *QueryError_Strerror(uint8_t maybe_code);

void QueryError_SetError(struct QueryError *query_error, QueryErrorCode code, const char *message);

void QueryError_SetCode(struct QueryError *query_error, QueryErrorCode code);

void QueryError_SetDetail(struct QueryError *query_error, const char *detail);

void QueryError_CloneFrom(const struct QueryError *src, struct QueryError *dest);

const char *QueryError_GetUserError(const struct QueryError *query_error);

const char *QueryError_GetDisplayableError(const struct QueryError *query_error, bool obfuscate);

QueryErrorCode QueryError_GetCode(const struct QueryError *query_error);

void QueryError_ClearError(struct QueryError *query_error);

void QueryError_MaybeSetCode(struct QueryError *query_error, QueryErrorCode code);

bool QueryError_HasReachedMaxPrefixExpansionsWarning(const struct QueryError *query_error);

void QueryError_SetReachedMaxPrefixExpansionsWarning(struct QueryError *query_error);

bool QueryError_HasQueryOOMWarning(const struct QueryError *query_error);

void QueryError_SetQueryOOMWarning(struct QueryError *query_error);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Set the error code using a custom-formatted string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithUserDataFmt(QueryError *status, QueryErrorCode code, const char* message, const char *fmt, ...);

/**
 * Set the error code using a custom-formatted string
 * Only use this function if you are certain that no user data is leaked in the format string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithoutUserDataFmt(QueryError *status, QueryErrorCode code, const char *fmt, ...);

/**
 * Not implemented in Rust yet as mocking ArgsCursor would be a large lift.
 */
void QueryError_FmtUnknownArg(QueryError *err, ArgsCursor *ac, const char *name);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
