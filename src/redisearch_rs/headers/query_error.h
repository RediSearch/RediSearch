#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/query_error_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <rmutil/args.h>
// Required to ensure that the alignment declared by cbindgen is respected on
// the C/C++ side.
#define ALIGNED(n) __attribute__((aligned(n)))

/**
 * Convenience macro to reply the error string to redis and clear the error code.
 * I'm making this into a C macro so I don't need to include redismodule.h.
 */
#define QueryError_ReplyAndClear(rctx, qerr)                         \
  ({                                                                 \
    RedisModule_ReplyWithError(rctx, QueryError_GetUserError(qerr)); \
    QueryError_ClearError(qerr);                                     \
    REDISMODULE_OK;                                                  \
  })

/** Convenience macro to extract the error string of the argument parser */
#define QERR_MKBADARGS_AC(status, name, rv)                                                     \
  QueryError_SetWithUserDataFmt(status, QUERY_ERROR_CODE_PARSE_ARGS, "Bad arguments", " for %s: %s", name, \
                         AC_Strerror(rv))

#define QERR_MKSYNTAXERR(status, message) QueryError_SetError(status, QUERY_ERROR_CODE_SYNTAX, message)

// String constants to warnings. These should be moved to const functions in rust.
#define QUERY_WMAXPREFIXEXPANSIONS "Max prefix expansions limit was reached"
#define QUERY_WINDEXING_FAILURE "Index contains partial data due to an indexing failure caused by insufficient memory"
#define QUERY_WOOM_SHARD "One or more shards failed to execute the query due to insufficient memory"
#define QUERY_WOOM_COORD "Coordinator failed to execute the query due to insufficient memory"


enum QueryErrorCode
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  QUERY_ERROR_CODE_OK = 0,
  QUERY_ERROR_CODE_GENERIC,
  QUERY_ERROR_CODE_SYNTAX,
  QUERY_ERROR_CODE_PARSE_ARGS,
  QUERY_ERROR_CODE_ADD_ARGS,
  QUERY_ERROR_CODE_EXPR,
  QUERY_ERROR_CODE_KEYWORD,
  QUERY_ERROR_CODE_NO_RESULTS,
  QUERY_ERROR_CODE_BAD_ATTR,
  QUERY_ERROR_CODE_INVAL,
  QUERY_ERROR_CODE_BUILD_PLAN,
  QUERY_ERROR_CODE_CONSTRUCT_PIPELINE,
  QUERY_ERROR_CODE_NO_REDUCER,
  QUERY_ERROR_CODE_REDUCER_GENERIC,
  QUERY_ERROR_CODE_AGG_PLAN,
  QUERY_ERROR_CODE_CURSOR_ALLOC,
  QUERY_ERROR_CODE_REDUCER_INIT,
  QUERY_ERROR_CODE_Q_STRING,
  QUERY_ERROR_CODE_NO_PROP_KEY,
  QUERY_ERROR_CODE_NO_PROP_VAL,
  QUERY_ERROR_CODE_NO_DOC,
  QUERY_ERROR_CODE_NO_OPTION,
  QUERY_ERROR_CODE_REDIS_KEY_TYPE,
  QUERY_ERROR_CODE_INVAL_PATH,
  QUERY_ERROR_CODE_INDEX_EXISTS,
  QUERY_ERROR_CODE_BAD_OPTION,
  QUERY_ERROR_CODE_BAD_ORDER_OPTION,
  QUERY_ERROR_CODE_LIMIT,
  QUERY_ERROR_CODE_NO_INDEX,
  QUERY_ERROR_CODE_DOC_EXISTS,
  QUERY_ERROR_CODE_DOC_NOT_ADDED,
  QUERY_ERROR_CODE_DUP_FIELD,
  QUERY_ERROR_CODE_GEO_FORMAT,
  QUERY_ERROR_CODE_NO_DISTRIBUTE,
  QUERY_ERROR_CODE_UNSUPP_TYPE,
  QUERY_ERROR_CODE_NOT_NUMERIC,
  QUERY_ERROR_CODE_TIMED_OUT,
  QUERY_ERROR_CODE_NO_PARAM,
  QUERY_ERROR_CODE_DUP_PARAM,
  QUERY_ERROR_CODE_BAD_VAL,
  QUERY_ERROR_CODE_NON_HYBRID,
  QUERY_ERROR_CODE_HYBRID_NON_EXIST,
  QUERY_ERROR_CODE_ADHOC_WITH_BATCH_SIZE,
  QUERY_ERROR_CODE_ADHOC_WITH_EF_RUNTIME,
  QUERY_ERROR_CODE_NON_RANGE,
  QUERY_ERROR_CODE_MISSING,
  QUERY_ERROR_CODE_MISMATCH,
  QUERY_ERROR_CODE_UNKNOWN_INDEX,
  QUERY_ERROR_CODE_DROPPED_BACKGROUND,
  QUERY_ERROR_CODE_ALIAS_CONFLICT,
  QUERY_ERROR_CODE_INDEX_BG_OOM_FAIL,
  QUERY_ERROR_CODE_WEIGHT_NOT_ALLOWED,
  QUERY_ERROR_CODE_VECTOR_NOT_ALLOWED,
  QUERY_ERROR_CODE_OUT_OF_MEMORY,
  QUERY_ERROR_CODE_UNAVAILABLE_SLOTS,
};
#ifndef __cplusplus
typedef uint8_t QueryErrorCode;
#endif // __cplusplus

enum QueryWarningCode
#ifdef __cplusplus
  : uint8_t
#endif // __cplusplus
 {
  QUERY_WARNING_CODE_OK = 0,
  QUERY_WARNING_CODE_TIMED_OUT,
  QUERY_WARNING_CODE_REACHED_MAX_PREFIX_EXPANSIONS,
  QUERY_WARNING_CODE_OUT_OF_MEMORY_SHARD,
  QUERY_WARNING_CODE_OUT_OF_MEMORY_COORD,
};
#ifndef __cplusplus
typedef uint8_t QueryWarningCode;
#endif // __cplusplus

/**
 * A type with size `N`.
 */
typedef uint8_t Size_38[38];

/**
 * An opaque query error which can be passed by value to C.
 *
 * The size and alignment of this struct must match the Rust `QueryError`
 * structure exactly.
 */
typedef struct ALIGNED(8) QueryError {
  Size_38 _0;
} QueryError;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Returns the default [`QueryError`].
 */
struct QueryError QueryError_Default(void);

/**
 * Returns true if `query_error` has no error code set.
 *
 * # Safety
 *
 * `query_error` must have been created by [`QueryError_Default`].
 */
bool QueryError_IsOk(const struct QueryError *query_error);

/**
 * Returns true if `query_error` has an error code set.
 *
 * # Safety
 *
 * `query_error` must have been created by [`QueryError_Default`].
 */
bool QueryError_HasError(const struct QueryError *query_error);

/**
 * Returns a human-readable string representing the provided [`QueryErrorCode`].
 *
 * This function should always return without a panic for any value provided.
 * It is unique among the `QueryError_*` API as the only function which allows
 * an invalid [`QueryErrorCode`] to be provided.
 */
const char *QueryError_Strerror(uint8_t maybe_code);

/**
 * Returns a [`QueryErrorCode`] given an error message.
 *
 * This only supports the query error codes [`QueryErrorCode::TimedOut`] and
 * [`QueryErrorCode::OutOfMemory`]. If another message is provided,
 * [`QueryErrorCode::Generic`] is returned.
 *
 * # Safety
 *
 * - `message` must be a valid C string or a NULL pointer.
 */
QueryErrorCode QueryError_GetCodeFromMessage(const char *message);

/**
 * Sets the [`QueryErrorCode`] and error message for a [`QueryError`].
 *
 * This does not mutate `query_error` if it already has an error set.
 *
 * # Panics
 *
 * - `code` must be a valid variant of [`QueryErrorCode`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 * - `message` must be a valid C string or a NULL pointer.
 */
void QueryError_SetError(struct QueryError *query_error, uint8_t code, const char *message);

/**
 * Sets the [`QueryErrorCode`] for a [`QueryError`].
 *
 * This does not mutate `query_error` if it already has an error set.
 *
 * # Panics
 *
 * - `code` must be a valid variant of [`QueryErrorCode`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
void QueryError_SetCode(struct QueryError *query_error, uint8_t code);

/**
 * Always sets the private message for a [`QueryError`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 * - `detail` must be a valid C string or a NULL pointer.
 */
void QueryError_SetDetail(struct QueryError *query_error, const char *detail);

/**
 * Clones the `src` [`QueryError`] into `dest`.
 *
 * This does nothing if `dest` already has an error set.
 *
 * # Safety
 *
 * - `src` must have been created by [`QueryError_Default`].
 * - `dest` must have been created by [`QueryError_Default`].
 */
void QueryError_CloneFrom(const struct QueryError *src, struct QueryError *dest);

/**
 * Returns the private message set for a [`QueryError`]. If no private message
 * is set, this returns the string error message for the code that is set,
 * like [`QueryError_Strerror`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
const char *QueryError_GetUserError(const struct QueryError *query_error);

/**
 * Returns an message of a [`QueryError`].
 *
 * This preferentially returns the private message if any, or the public
 * message if any, lastly defaulting to the error code's string error.
 *
 * If `obfuscate` is set, the private message is not returned. The public
 * message is returned, if any, defaulting to the error code's string error.
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
const char *QueryError_GetDisplayableError(const struct QueryError *query_error, bool obfuscate);

/**
 * Returns the [`QueryErrorCode`] set for a [`QueryError`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
QueryErrorCode QueryError_GetCode(const struct QueryError *query_error);

/**
 * Clears any error set on a [`QueryErrorCode`].
 *
 * This is equivalent to resetting `query_error` to the value returned by
 * [`QueryError_Default`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
void QueryError_ClearError(struct QueryError *query_error);

/**
 * Sets the [`QueryErrorCode`] for a [`QueryError`].
 *
 * This does not mutate `query_error` if it already has an error set, or
 * if the private message is set. This differs from [`QueryError_SetCode`],
 * as that function does not care if the private message is set.
 *
 * # Panics
 *
 * - `code` must be a valid variant of [`QueryErrorCode`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
void QueryError_MaybeSetCode(struct QueryError *query_error, uint8_t code);

/**
 * Returns whether the [`QueryError`] has the `reached_max_prefix_expansions`
 * warning set.
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
bool QueryError_HasReachedMaxPrefixExpansionsWarning(const struct QueryError *query_error);

/**
 * Sets the `reached_max_prefix_expansions` warning on the [`QueryError`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
void QueryError_SetReachedMaxPrefixExpansionsWarning(struct QueryError *query_error);

/**
 * Returns whether the [`QueryError`] has the `out_of_memory` warning set.
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
bool QueryError_HasQueryOOMWarning(const struct QueryError *query_error);

/**
 * Sets the `out_of_memory` warning on the [`QueryError`].
 *
 * # Safety
 *
 * - `query_error` must have been created by [`QueryError_Default`].
 */
void QueryError_SetQueryOOMWarning(struct QueryError *query_error);

/**
 * Returns a [`QueryWarningCode`] given an warnings message.
 *
 * This only supports the query error codes [`QueryWarningCode::TimedOut`], [`QueryWarningCode::ReachedMaxPrefixExpansions`],
 * [`QueryWarningCode::OutOfMemoryShard`] and [`QueryWarningCode::OutOfMemoryCoord`]. If another message is provided,
 * [`QueryWarningCode::Ok`] is returned.
 *
 * # Safety
 *
 * - `message` must be a valid C string or a NULL pointer.
 */
QueryWarningCode QueryWarningCode_GetCodeFromMessage(const char *message);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Set the error code using a custom-formatted string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithUserDataFmt(QueryError *status, QueryErrorCode code, const char* message, const char *fmt, ...);

/**
 * Set the error code using a custom-formatted string
 * Only use this function if you are certain that no user data is leaked in the format string
 *
 * Not implemented in Rust as variadic functions are not supported across an FFI boundary.
 */
void QueryError_SetWithoutUserDataFmt(QueryError *status, QueryErrorCode code, const char *fmt, ...);

/**
 * Not implemented in Rust yet as mocking ArgsCursor would be a large lift.
 */
void QueryError_FmtUnknownArg(QueryError *err, ArgsCursor *ac, const char *name);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
