#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/iterators_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "iterators/iterator_api.h"
#include "iterators/inverted_index_iterator.h"
#include "query.h"


/**
 * The different types of metrics.
 * At the moment, only vector distance is supported.
 */
typedef enum MetricType {
  VECTOR_DISTANCE,
} MetricType;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new empty iterator.
 */
QueryIterator *NewEmptyIterator(void);

/**
 * Creates a new iterator over a list of sorted document IDs.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 *    The array must be sorted in ascending order.
 * 2. The caller must ensure that `ids` is not null unless `num` is zero.
 * 3. The memory pointed to by `ids` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that the pointer was allocated in a compatible manner.
 */
QueryIterator *NewSortedIdListIterator(t_docId *ids, uint64_t num, double weight);

/**
 * Creates a new iterator over a list of unsorted document IDs.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 * 2. The caller must ensure that `ids` is not null unless `num` is zero.
 * 3. The memory pointed to by `ids` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that the pointer was allocated in a compatible manner.
 */
QueryIterator *NewUnsortedIdListIterator(t_docId *ids, uint64_t num, double weight);

/**
 * Creates a new numeric inverted index iterator for querying numeric fields.
 *
 * # Parameters
 *
 * * `idx` - Pointer to the inverted index to query.
 * * `sctx` - Pointer to the Redis search context for expiration checking.
 * * `field_ctx` - Pointer to the field filter context (field index and expiration predicate).
 * * `flt` - Optional pointer to a numeric filter for value filtering (can be NULL).
 * * `rt` - Optional pointer to the numeric range tree for revalidation (can be NULL).
 * * `range_min` - Minimum value of the numeric range.
 * * `range_max` - Maximum value of the numeric range.
 *
 * # Returns
 *
 * A pointer to a `QueryIterator` that can be used from C code.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 *
 * 1. `idx` must be a valid pointer to a numeric `InvertedIndex` and cannot be NULL.
 * 2. `idx` must remain valid for the lifetime of the returned iterator.
 * 3. `sctx` must be a valid pointer to a `RedisSearchCtx` and cannot be NULL.
 * 4. `sctx` and `sctx.spec` must remain valid for the lifetime of the returned iterator.
 * 5. `field_ctx` must be a valid pointer to a `FieldFilterContext` and cannot be NULL.
 * 6. `field_ctx.field` must be a field index (tag == FieldMaskOrIndex_Index), not a field mask.
 *    Numeric queries require a specific field index.
 * 7. If `flt` is not NULL, it must be a valid pointer to a `NumericFilter` and must
 *    remain valid for the lifetime of the returned iterator.
 * 8. If `rt` is not NULL, it must be a valid pointer to a `NumericRangeTree` and must
 *    remain valid for the lifetime of the returned iterator.
 * 9. `range_min` is smaller or equal to `range_max`.
 */
QueryIterator *NewInvIndIterator_NumericQuery(const InvertedIndex *idx,
                                              const RedisSearchCtx *sctx,
                                              const FieldFilterContext *field_ctx,
                                              const NumericFilter *flt,
                                              const NumericRangeTree *rt,
                                              double range_min,
                                              double range_max);

/**
 * Gets the flags of the underlying IndexReader from a numeric inverted index iterator.
 *
 * # Safety
 *
 * 1. `it` must be a valid non-NULL pointer to a `QueryIterator`.
 * 2. If `it` iterator type is IteratorType_INV_IDX_NUMERIC_ITERATOR, it has been created using `NewInvIndIterator_NumericQuery`.
 * 3. If `it` iterator type is IteratorType_INV_IDX_WILDCARD_ITERATOR, it has been created using `NewInvIndIterator_WildcardQuery`.
 * 4. If `it` has a different iterator type, its `reader` field must be a valid non-NULL pointer to an `IndexReader`.
 *
 * # Returns
 *
 * The flags of the `IndexReader`.
 */
IndexFlags InvIndIterator_GetReaderFlags(const InvIndIterator *it);

/**
 * Gets the numeric filter from a numeric inverted index iterator.
 *
 * # Safety
 *
 * 1. `it` must be a valid pointer to a `NumericInvIndIterator` created by `NewInvIndIterator_NumericQuery`.
 *
 * # Returns
 *
 * A pointer to the numeric filter, or NULL if no filter was provided when creating the iterator.
 */
const NumericFilter *NumericInvIndIterator_GetNumericFilter(const NumericInvIndIterator *it);

/**
 * Gets the minimum range value for profiling a numeric iterator.
 *
 * # Safety
 *
 * 1. `it` must be a valid pointer to a `QueryIterator` created by `NewInvIndIterator_NumericQuery`.
 *
 * # Returns
 *
 * The minimum range value from the filter, or negative infinity if no filter was provided.
 */
double NumericInvIndIterator_GetProfileRangeMin(const NumericInvIndIterator *it);

/**
 * Gets the maximum range value for profiling a numeric iterator.
 *
 * # Safety
 *
 * 1. `it` must be a valid pointer to a `QueryIterator` created by `NewInvIndIterator_NumericQuery`.
 *
 * # Returns
 *
 * The maximum range value from the filter, or positive infinity if no filter was provided.
 */
double NumericInvIndIterator_GetProfileRangeMax(const NumericInvIndIterator *it);

/**
 * Swap the inverted index of an inverted index iterator. This is only used by C tests
 * to trigger revalidation on the iterator's underlying reader.
 *
 * # Safety
 *
 * 1. `it` must be a valid non-NULL pointer to an `InvIndIterator`.
 * 2. If `it` iterator type is `IteratorType_INV_IDX_WILDCARD_ITERATOR`, it has been created
 *    using `NewInvIndIterator_WildcardQuery`.
 * 3. If `it` is a C iterator, its `reader` field must be a valid non-NULL
 *    pointer to an `IndexReader`.
 * 4. `ii` must be a valid non-NULL pointer to an `InvertedIndex` whose type matches the
 *    iterator's underlying index type.
 */
void InvIndIterator_Rs_SwapIndex(InvIndIterator *it, const InvertedIndex *ii);

/**
 * Creates a new wildcard inverted index iterator for querying all existing documents.
 *
 * # Parameters
 *
 * * `idx` - Pointer to the existingDocs inverted index (DocIdsOnly or RawDocIdsOnly encoded).
 * * `sctx` - Pointer to the Redis search context.
 * * `weight` - Weight to apply to all results.
 *
 * # Returns
 *
 * A pointer to a `QueryIterator` that can be used from C code.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 *
 * 1. `idx` must be a valid pointer to an `InvertedIndex` and cannot be NULL.
 * 2. `idx` must remain valid between `revalidate()` calls, since the revalidation
 *    mechanism detects when the index has been replaced via `spec.existingDocs` pointer
 *    comparison.
 * 3. `sctx` must be a valid pointer to a `RedisSearchCtx` and cannot be NULL.
 * 4. `sctx` and `sctx.spec` must remain valid for the lifetime of the returned iterator.
 */
QueryIterator *NewInvIndIterator_WildcardQuery(const InvertedIndex *idx,
                                               const RedisSearchCtx *sctx,
                                               double weight);

/**
 * Creates a new metric iterator sorted by ID.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 *    The array must be sorted in ascending order.
 * 2. `metric_list` must be a valid pointer to an array of `f64` with at least `num` elements.
 * 3. The caller must ensure that `ids` and `metric_list` are not null unless `num` is zero.
 * 4. The memory pointed to by `ids` and `metric_list` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that these pointers were allocated in a compatible manner.
 */
QueryIterator *NewMetricIteratorSortedById(t_docId *ids,
                                           double *metric_list,
                                           uintptr_t num,
                                           enum MetricType type_);

/**
 * Creates a new metric iterator sorted by score.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 * 2. `metric_list` must be a valid pointer to an array of `f64` with at least `num` elements.
 * 3. The caller must ensure that `ids` and `metric_list` are not null unless `num` is zero.
 * 4. The memory pointed to by `ids` and `metric_list` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that these pointers were allocated in a compatible manner.
 */
QueryIterator *NewMetricIteratorSortedByScore(t_docId *ids,
                                              double *metric_list,
                                              uintptr_t num,
                                              enum MetricType type_);

/**
 * Sets the [`RLookupKeyHandle`] for this metric iterator.
 *
 * # Safety
 *
 * 1. `header` is a valid non-null pointer to a [`QueryIterator`].
 * 2. `header` was built via [`NewMetricIteratorSortedByScore`] or [`NewMetricIteratorSortedById`].
 * 3. `key_handle` is either a null pointer or a valid non-null pointer to a [`RLookupKeyHandle`] instance.
 */
void SetMetricRLookupHandle(QueryIterator *header,
                            RLookupKeyHandle *key_handle);

/**
 * Get a mutable reference to the [`RLookupKey`] stored inside this metric iterator.
 *
 * # Safety
 *
 * 1. `header` is a valid non-null pointer to a [`QueryIterator`].
 * 2. `header` was built via [`NewMetricIteratorSortedByScore`] or [`NewMetricIteratorSortedById`].
 */
RLookupKey **GetMetricOwnKeyRef(QueryIterator *header);

/**
 * Get the metric type used by this metric iterator.
 *
 * # Safety
 *
 * 1. `header` is a valid non-null pointer to a [`QueryIterator`].
 * 2. `header` was built via [`NewMetricIteratorSortedByScore`] or [`NewMetricIteratorSortedById`].
 */
enum MetricType GetMetricType(QueryIterator *header);

/**
 * Creates a new non-optimized wildcard iterator over the `[0, max_id]` document id range.
 */
QueryIterator *NewWildcardIterator_NonOptimized(t_docId max_id, double weight);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
