#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/iterators_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "iterators/iterator_api.h"
#include "query.h"


/**
 * The different types of metrics.
 * At the moment, only vector distance is supported.
 */
typedef enum MetricType {
  VectorDistance,
} MetricType;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new iterator over a list of sorted document IDs.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 *    The array must be sorted in ascending order.
 * 2. The caller must ensure that `ids` is not null unless `num` is zero.
 * 3. The memory pointed to by `ids` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that the pointer was allocated in a compatible manner.
 */
QueryIterator *NewSortedIdListIterator(const t_docId *ids, uint64_t num, double weight);

/**
 * Creates a new iterator over a list of unsorted document IDs.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 * 2. The caller must ensure that `ids` is not null unless `num` is zero.
 * 3. The memory pointed to by `ids` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that the pointer was allocated in a compatible manner.
 */
QueryIterator *NewUnsortedIdListIterator(const t_docId *ids, uint64_t num, double weight);

/**
 * Creates a new metric iterator sorted by ID.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 *    The array must be sorted in ascending order.
 * 2. `metric_list` must be a valid pointer to an array of `f64` with at least `num` elements.
 * 3. The caller must ensure that `ids` and `metric_list` are not null unless `num` is zero.
 * 4. The memory pointed to by `ids` and `metric_list` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that these pointers were allocated in a compatible manner.
 */
QueryIterator *NewMetricIteratorSortedById(const t_docId *ids,
                                           const double *metric_list,
                                           uintptr_t num,
                                           enum MetricType type_);

/**
 * Creates a new metric iterator sorted by score.
 *
 * # Safety
 *
 * 1. `ids` must be a valid pointer to an array of `t_docId` with at least `num` elements.
 * 2. `metric_list` must be a valid pointer to an array of `f64` with at least `num` elements.
 * 3. The caller must ensure that `ids` and `metric_list` are not null unless `num` is zero.
 * 4. The memory pointed to by `ids` and `metric_list` will be freed using `RedisModule_Free`,
 *    so the caller must ensure that these pointers were allocated in a compatible manner.
 */
QueryIterator *NewMetricIteratorSortedByScore(const t_docId *ids,
                                              const double *metric_list,
                                              uintptr_t num,
                                              enum MetricType type_);

/**
 * Sets the [`RLookupKeyHandle`] for this metric iterator.
 *
 * # Safety
 *
 * 1. `header` is a valid non-null pointer to a [`QueryIterator`].
 * 2. `header` was built via [`NewMetricIteratorSortedByScore`] or [`NewMetricIteratorSortedById`].
 * 3. `key_handle` is either a null pointer or a valid non-null pointer to a [`RLookupKeyHandle`] instance.
 */
void SetMetricRLookupHandle(QueryIterator *header,
                            RLookupKeyHandle *key_handle);

/**
 * Get a mutable reference to the [`RLookupKey`] stored inside this metric iterator.
 *
 * # Safety
 *
 * 1. `header` is a valid non-null pointer to a [`QueryIterator`].
 * 2. `header` was built via [`NewMetricIteratorSortedByScore`] or [`NewMetricIteratorSortedById`].
 */
RLookupKey **GetMetricOwnKeyRef(QueryIterator *header);

/**
 * Get the metric type used by this metric iterator.
 *
 * # Safety
 *
 * 1. `header` is a valid non-null pointer to a [`QueryIterator`].
 * 2. `header` was built via [`NewMetricIteratorSortedByScore`] or [`NewMetricIteratorSortedById`].
 */
enum MetricType GetMetricType(QueryIterator *header);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
