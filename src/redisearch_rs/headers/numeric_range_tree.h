#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/numeric_range_tree_ffi/build.rs`. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "types_rs.h"
#include "redisearch.h"
#include "inverted_index.h"
#include "redismodule.h"
/**
 * Opaque type for the Rust numeric inverted index.
 *
 * This is intentionally incompatible with the C InvertedIndex type.
 * Use accessor functions to interact with this type.
 */
typedef struct InvertedIndexNumeric InvertedIndexNumeric;


/**
 * Minimum cardinality before considering splitting (at depth 0).
 *
 * At depth 0, we require at least this many distinct values before splitting.
 * This prevents excessive splitting for low-cardinality fields.
 */
#define NumericRangeTree_MINIMUM_RANGE_CARDINALITY 16

/**
 * Maximum cardinality threshold for splitting.
 *
 * Once the split threshold reaches this value, it stays constant regardless
 * of depth. This caps the maximum number of distinct values in any leaf range.
 */
#define NumericRangeTree_MAXIMUM_RANGE_CARDINALITY 2500

/**
 * Maximum number of entries in a range before forcing a split (if cardinality > 1).
 *
 * Even if cardinality is below the threshold, we split if a range accumulates
 * too many entries. This handles cases where many documents share few values.
 * The cardinality > 1 check prevents splitting single-value ranges indefinitely.
 */
#define NumericRangeTree_MAXIMUM_RANGE_SIZE 10000

/**
 * Maximum depth imbalance before rebalancing.
 *
 * We use AVL-like rotations when one subtree's depth exceeds the other by
 * more than this value.
 */
#define NumericRangeTree_MAXIMUM_DEPTH_IMBALANCE 2

/**
 * Cardinality growth factor per depth level.
 *
 * The split cardinality threshold multiplies by this factor for each depth
 * level, capped at [`Self::MAXIMUM_RANGE_CARDINALITY`].
 */
#define NumericRangeTree_CARDINALITY_GROWTH_FACTOR 4

/**
 * Status of a [`NumericRangeTree_ApplyGcEntry`] call.
 */
typedef enum ApplyGcEntryStatus {
  /**
   * The node was found and GC was applied successfully.
   * `gc_result` contains the result.
   */
  Ok,
  /**
   * The target node no longer exists in the tree
   * (e.g. removed between scan and apply).
   */
  NodeNotFound,
  /**
   * The entry data could not be deserialized.
   * The child probably crashed or corrupted the pipe.
   */
  DeserializationError,
} ApplyGcEntryStatus;

/**
 * Opaque streaming scanner that yields one node's GC delta at a time.
 *
 * Created by [`NumericGcScanner_New`], advanced by [`NumericGcScanner_Next`],
 * and freed by [`NumericGcScanner_Free`].
 *
 * Each call to `Next` scans the next node in DFS order via
 * [`NumericRangeNode::scan_gc`][numeric_range_tree::NumericRangeNode::scan_gc]
 * and serializes the delta + HLL registers into an internal buffer.
 * The caller can then write the entry data to the pipe immediately,
 * avoiding buffering all deltas in memory.
 */
typedef struct NumericGcScanner NumericGcScanner;

/**
 * A numeric range is a leaf-level storage unit in the numeric range tree.
 *
 * It stores document IDs and their associated numeric values in an inverted index,
 * along with metadata for range queries and cardinality estimation.
 *
 * # Structure
 *
 * - **Bounds** (`min_val`, `max_val`): Track the actual value range for overlap
 *   and containment tests during queries.
 * - **Cardinality** (`hll`): HyperLogLog estimator for the number of distinct
 *   values, used to decide when to split.
 * - **Entries** (`entries`): Inverted index storing (docId, value) pairs.
 *
 * # Initialization
 *
 * New ranges start with inverted bounds (`min_val = +∞`, `max_val = -∞`) so
 * the first added value correctly sets both bounds.
 */
typedef struct NumericRange NumericRange;

/**
 * A node in the numeric range tree.
 *
 * Nodes are either:
 * - **Leaf nodes**: Have a range but no children.
 * - **Internal nodes**: Have both children, a split value, depth tracking,
 *   and optionally retain a range for query efficiency.
 *
 * When part of a [`NumericRangeTree`](crate::NumericRangeTree), nodes are
 * stored in a [`generational_slab::Slab`] arena and referenced by [`NodeIndex`].
 */
typedef struct NumericRangeNode NumericRangeNode;

/**
 * A numeric range tree for efficient range queries over numeric values.
 *
 * The tree organizes documents by their numeric field values into a balanced
 * binary tree of ranges. Each leaf node contains a range of values, and
 * internal nodes may optionally retain their ranges for query efficiency.
 *
 * # Arena Storage
 *
 * All nodes are stored in a [`NodeArena`]. Children are referenced by
 * [`NodeIndex`] instead of `Box<NumericRangeNode>`. This provides better
 * cache locality, eliminates per-node heap allocation overhead, and makes
 * pruning cheaper (index swaps and a single `realloc` rather than a dealloc
 * for every deleted node).
 *
 * # Splitting Strategy
 *
 * Nodes split based on two conditions:
 *
 * - **Cardinality threshold**: When the HyperLogLog-estimated cardinality exceeds
 *   a depth-dependent limit. The threshold is [`Self::MINIMUM_RANGE_CARDINALITY`] at depth 0,
 *   growing by a factor of [`Self::CARDINALITY_GROWTH_FACTOR`] per depth level until capped
 *   at [`Self::MAXIMUM_RANGE_CARDINALITY`].
 *
 * - **Size overflow**: When entry count exceeds [`Self::MAXIMUM_RANGE_SIZE`] and
 *   cardinality > 1. This handles cases where many documents share few values.
 *   The cardinality check prevents splitting single-value ranges indefinitely.
 *
 * # Balancing
 *
 * The tree uses AVL-like single rotations when depth imbalance exceeds
 * [`Self::MAXIMUM_DEPTH_IMBALANCE`].
 */
typedef struct NumericRangeTree NumericRangeTree;

/**
 * An iterator that performs a depth-first traversal of the numeric range tree.
 *
 * This iterator visits all nodes in the tree, yielding each node exactly once.
 * The traversal is done iteratively using an explicit stack to avoid recursion,
 * which is important for deeply nested trees that might overflow the call stack.
 *
 * # Traversal Order
 *
 * Nodes are visited in reverse pre-order (parent -> right child -> left child).
 */
typedef struct ReversePreOrderDfsIterator ReversePreOrderDfsIterator;

/**
 * Result of adding a value to the tree.
 *
 * This captures the changes that occurred during the add operation,
 * including memory growth and structural changes. The delta fields use
 * signed types to support both growth (positive) and shrinkage (negative)
 * during operations like trimming empty leaves.
 */
typedef struct AddResult {
  /**
   * The change in the tree's inverted index memory usage, in bytes.
   * Positive values indicate growth, negative values indicate shrinkage.
   * This tracks only inverted index memory, not node/range struct overhead.
   */
  int64_t size_delta;
  /**
   * The net change in the number of records (document, value entries).
   * When splitting, this counts re-added entries to child ranges.
   * When trimming, this is negative for removed entries.
   */
  int32_t num_records_delta;
  /**
   * Whether the tree structure changed (splits or rotations occurred).
   * When true, the tree's `revision_id` should be incremented to
   * invalidate any concurrent iterators.
   */
  bool changed;
  /**
   * The net change in the number of ranges (nodes with inverted indexes).
   * Splitting a leaf adds one or two new ranges. Trimming removes ranges.
   */
  int32_t num_ranges_delta;
  /**
   * The net change in the number of leaf nodes.
   * Splitting a leaf adds one new leaf. Trimming decreases this.
   */
  int32_t num_leaves_delta;
} AddResult;

/**
 * Result of [`NumericRangeTree_Find`] - an array of range pointers.
 *
 * The caller is responsible for freeing this result using
 * [`NumericRangeTreeFindResult_Free`]. The ranges themselves are owned by
 * the tree and must not be freed individually.
 */
typedef struct NumericRangeTreeFindResult {
  /**
   * Pointer to array of range pointers.
   */
  const struct NumericRange *const *ranges;
  /**
   * Number of ranges in the array.
   */
  uintptr_t len;
} NumericRangeTreeFindResult;

/**
 * Result of trimming empty leaves from the tree.
 *
 * Similar to [`AddResult`] but without `num_records_delta`, since trimming
 * only removes empty nodes and does not change the number of entries
 * (entries are removed by GC before trimming).
 */
typedef struct TrimEmptyLeavesResult {
  /**
   * The change in the tree's inverted index memory usage, in bytes.
   * Positive values indicate growth, negative values indicate shrinkage.
   */
  int64_t size_delta;
  /**
   * Whether the tree structure changed (nodes were removed or rotated).
   * When true, the tree's `revision_id` should be incremented to
   * invalidate any concurrent iterators.
   */
  bool changed;
  /**
   * The net change in the number of ranges (nodes with inverted indexes).
   */
  int32_t num_ranges_delta;
  /**
   * The net change in the number of leaf nodes.
   */
  int32_t num_leaves_delta;
} TrimEmptyLeavesResult;

/**
 * Returned by [`NumericRangeTree::compact_if_sparse`].
 */
typedef struct CompactIfSparseResult {
  /**
   * The change in the tree's inverted index memory usage, in bytes.
   * Positive values indicate growth, negative values indicate shrinkage.
   * This tracks only inverted index memory, not node/range struct overhead.
   */
  int64_t inverted_index_size_delta;
  /**
   * The change in the tree's node memory usage, in bytes.
   * Positive values indicate growth, negative values indicate shrinkage.
   */
  int64_t node_size_delta;
} CompactIfSparseResult;

/**
 * A single node's GC scan result, returned by [`NumericGcScanner_Next`].
 *
 * The `data` pointer points into the scanner's internal buffer and is valid
 * until the next call to [`NumericGcScanner_Next`] or [`NumericGcScanner_Free`].
 */
typedef struct NumericGcNodeEntry {
  /**
   * The node's slab position.
   */
  uint32_t node_position;
  /**
   * The node's slab generation.
   */
  uint32_t node_generation;
  /**
   * Pointer to the serialized entry data (msgpack delta + HLL registers).
   */
  const uint8_t *data;
  /**
   * Length of the serialized entry data in bytes.
   */
  uintptr_t data_len;
} NumericGcNodeEntry;

/**
 * Result of applying GC to a single node.
 *
 * Returned by [`NumericRangeTree::apply_gc_to_node`].
 */
typedef struct SingleNodeGcResult {
  /**
   * Information about the outcome of garbage collection on
   * the inverted index stored within this node.
   */
  II_GCScanStats index_gc_info;
  /**
   * Whether this node became empty after GC.
   */
  bool became_empty;
} SingleNodeGcResult;

/**
 * Result of [`NumericRangeTree_ApplyGcEntry`].
 *
 * Wraps [`SingleNodeGcResult`] with a [`status`](ApplyGcEntryStatus) field
 * so C callers can distinguish success, node-not-found, and deserialization
 * errors.
 */
typedef struct ApplyGcEntryResult {
  /**
   * The GC result for the node. Only meaningful when `status` is
   * [`ApplyGcEntryStatus::Ok`].
   */
  struct SingleNodeGcResult gc_result;
  /**
   * Whether the operation succeeded, the node was missing, or the data
   * could not be deserialized.
   */
  enum ApplyGcEntryStatus status;
} ApplyGcEntryResult;

/**
 * Type alias for the tree iterator, providing a C-friendly name.
 *
 * The iterator holds references to nodes in the tree. The tree must not be
 * freed or mutated while this iterator exists.
 */
typedef struct ReversePreOrderDfsIterator NumericRangeTreeIterator;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new [`NumericRangeTree`].
 *
 * Returns an opaque pointer to the newly created tree.
 * To free the tree, use [`NumericRangeTree_Free`].
 *
 * If `compress_floats` is true, the tree will use float compression which
 * attempts to store f64 values as f32 when precision loss is acceptable (< 0.01).
 * This corresponds to the `RSGlobalConfig.numericCompress` setting.
 */
struct NumericRangeTree *NewNumericRangeTree(bool compress_floats);

/**
 * Add a (docId, value) pair to the tree.
 *
 * If `isMulti` is non-zero, duplicate document IDs are allowed.
 * `maxDepthRange` specifies the maximum depth at which to retain ranges on inner nodes.
 *
 * Returns information about what changed during the add operation.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
struct AddResult NumericRangeTree_Add(struct NumericRangeTree *t,
                                      t_docId doc_id,
                                      double value,
                                      int isMulti,
                                      uintptr_t maxDepthRange);

/**
 * Free a [`NumericRangeTree`] and all its contents.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`], or be NULL (in which case this is a no-op).
 * - After calling this function, `t` must not be used again.
 * - Any iterators obtained from this tree must be freed before calling this.
 */
void NumericRangeTree_Free(struct NumericRangeTree *t);

/**
 * Get the total memory usage of the tree in bytes.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_MemUsage(const struct NumericRangeTree *t);

/**
 * Find all numeric ranges that match the given filter.
 *
 * Returns a [`NumericRangeTreeFindResult`] containing pointers to the matching
 * ranges. The ranges are owned by the tree and must not be freed individually.
 * The result itself must be freed using [`NumericRangeTreeFindResult_Free`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 * - `nf` must point to a valid [`NumericFilter`] and cannot be NULL.
 */
struct NumericRangeTreeFindResult NumericRangeTree_Find(const struct NumericRangeTree *t,
                                                        const NumericFilter *nf);

/**
 * Free a [`NumericRangeTreeFindResult`].
 *
 * This frees the array allocation but NOT the ranges themselves (they are
 * owned by the tree).
 *
 * # Safety
 *
 * - `result` must have been obtained from [`NumericRangeTree_Find`].
 * - After calling this function, the result must not be used again.
 */
void NumericRangeTreeFindResult_Free(struct NumericRangeTreeFindResult result);

/**
 * Trim empty leaves from the tree (garbage collection).
 *
 * Removes leaf nodes that have no documents and prunes the tree structure
 * accordingly.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 * - No iterators should be active on this tree while calling this function.
 */
struct TrimEmptyLeavesResult NumericRangeTree_TrimEmptyLeaves(struct NumericRangeTree *t);

/**
 * Get the base size of a NumericRangeTree struct (not including contents).
 *
 * This is used for memory overhead calculations.
 */
uintptr_t NumericRangeTree_BaseSize(void);

/**
 * Reply with a summary of the numeric range tree (for NUMIDX_SUMMARY).
 *
 * This outputs the tree statistics in the format expected by FT.DEBUG NUMIDX_SUMMARY.
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must point to a valid [`NumericRangeTree`].
 */
void NumericRangeTree_DebugSummary(RedisModuleCtx *ctx, const struct NumericRangeTree *t);

/**
 * Reply with a dump of the numeric index entries (for DUMP_NUMIDX).
 *
 * This outputs all entries from all ranges in the tree. If `with_headers` is true,
 * each range's entries are prefixed with header information (numDocs, numEntries, etc).
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must point to a valid [`NumericRangeTree`].
 */
void NumericRangeTree_DebugDumpIndex(RedisModuleCtx *ctx,
                                     const struct NumericRangeTree *t,
                                     bool with_headers);

/**
 * Reply with a dump of the numeric index tree structure (for DUMP_NUMIDXTREE).
 *
 * This outputs the tree structure as a nested map. If `minimal` is true,
 * range entry details are omitted (only tree structure is shown).
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must point to a valid [`NumericRangeTree`].
 */
void NumericRangeTree_DebugDumpTree(RedisModuleCtx *ctx,
                                    const struct NumericRangeTree *t,
                                    bool minimal);

/**
 * Conditionally trim empty leaves and compact the node slab.
 *
 * Checks if the number of empty leaves exceeds half the total number of
 * leaves. If so, trims empty leaves, compacts the slab to reclaim freed
 * slots, and returns the number of bytes freed. Returns 0 if no trimming
 * was needed.
 *
 * # Safety
 *
 * - `t` must point to a valid mutable [`NumericRangeTree`] and cannot be NULL.
 * - No iterators should be active on this tree while calling this function.
 */
struct CompactIfSparseResult NumericRangeTree_CompactIfSparse(struct NumericRangeTree *t);

/**
 * Create a new [`NumericGcScanner`] for streaming GC scans.
 *
 * The scanner traverses the tree in pre-order DFS, scanning one node at a
 * time. Call [`NumericGcScanner_Next`] to advance.
 *
 * # Safety
 *
 * - `sctx` must point to a valid [`RedisSearchCtx`] and cannot be NULL.
 * - `tree` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 * - Both `sctx` and `tree` must remain valid for the lifetime of the scanner.
 */
struct NumericGcScanner *NumericGcScanner_New(RedisSearchCtx *sctx, struct NumericRangeTree *tree);

/**
 * Advance the scanner to the next node with GC work.
 *
 * Scans nodes in DFS order, skipping those without GC work. When a node
 * with work is found, its delta and HLL registers are serialized into the
 * scanner's internal buffer.
 *
 * Returns `true` if an entry was produced (and `*entry` is populated),
 * `false` when all nodes have been visited.
 *
 * The `entry.data` pointer is valid until the next call to `Next` or `Free`.
 *
 * # Wire format for `entry.data`
 *
 * ```text
 * [delta_msgpack][64-byte hll_with][64-byte hll_without]
 * ```
 *
 * # Safety
 *
 * - `scanner` must be a valid pointer returned by [`NumericGcScanner_New`].
 * - `entry` must be a valid pointer to a [`NumericGcNodeEntry`].
 */
bool NumericGcScanner_Next(struct NumericGcScanner *scanner, struct NumericGcNodeEntry *entry);

/**
 * Free a [`NumericGcScanner`].
 *
 * # Safety
 *
 * - `scanner` must be a valid pointer returned by [`NumericGcScanner_New`],
 *   or NULL (in which case this is a no-op).
 */
void NumericGcScanner_Free(struct NumericGcScanner *scanner);

/**
 * Parse a serialized GC entry and apply it to the specified node.
 *
 * The entry data must have the wire format produced by [`NumericGcScanner_Next`]:
 * ```text
 * [delta_msgpack][64-byte hll_with][64-byte hll_without]
 * ```
 *
 * Returns an [`ApplyGcEntryResult`] whose [`status`](ApplyGcEntryStatus)
 * indicates success, node-not-found, or deserialization error.
 *
 * # Safety
 *
 * - `tree` must point to a valid mutable [`NumericRangeTree`] and cannot be NULL.
 * - `entry_data` must point to a valid byte buffer of at least `entry_len` bytes.
 */
struct ApplyGcEntryResult NumericRangeTree_ApplyGcEntry(struct NumericRangeTree *tree,
                                                        uint32_t node_position,
                                                        uint32_t node_generation,
                                                        const uint8_t *entry_data,
                                                        uintptr_t entry_len);

/**
 * Create a new iterator over all nodes in the tree.
 *
 * The iterator performs a depth-first traversal, visiting each node exactly once.
 * Use [`NumericRangeTreeIterator_Next`] to advance the iterator.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`crate::NewNumericRangeTree`] and cannot be NULL.
 * - `t` must not be freed while the iterator lives.
 * - The tree must not be mutated while the iterator lives.
 */
NumericRangeTreeIterator *NumericRangeTreeIterator_New(const struct NumericRangeTree *t);

/**
 * Advance the iterator and return the next node.
 *
 * Returns a pointer to the next [`NumericRangeNode`] in the traversal,
 * or NULL if the iteration is complete.
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator`] obtained from
 *   [`NumericRangeTreeIterator_New`] and cannot be NULL.
 * - The tree from which this iterator was created must still be valid.
 */
const struct NumericRangeNode *NumericRangeTreeIterator_Next(NumericRangeTreeIterator *it);

/**
 * Free a [`NumericRangeTreeIterator`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator`] obtained from
 *   [`NumericRangeTreeIterator_New`], or be NULL (in which case this is a no-op).
 * - After calling this function, `it` must not be used again.
 */
void NumericRangeTreeIterator_Free(NumericRangeTreeIterator *it);

/**
 * Get the [`NumericRange`] from a node, if present.
 *
 * Returns a pointer to the range, or NULL if the node has no range
 * (e.g., an internal node whose range has been trimmed).
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `node` must point to a valid [`NumericRangeNode`] obtained from
 *   [`crate::iterator::NumericRangeTreeIterator_Next`] and cannot be NULL.
 * - The tree from which this node came must still be valid.
 */
const struct NumericRange *NumericRangeNode_GetRange(const struct NumericRangeNode *node);

/**
 * Get the estimated cardinality (number of distinct values) for a range.
 *
 * This uses HyperLogLog estimation and may have some error margin.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `range` must point to a valid [`NumericRange`] obtained from
 *   [`crate::node::NumericRangeNode_GetRange`] and cannot be NULL.
 * - The tree from which this range came must still be valid.
 */
uintptr_t NumericRange_GetCardinality(const struct NumericRange *range);

/**
 * Get the minimum value in a range.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
double NumericRange_MinVal(const struct NumericRange *range);

/**
 * Get the maximum value in a range.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
double NumericRange_MaxVal(const struct NumericRange *range);

/**
 * Get the inverted index size in bytes.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
uintptr_t NumericRange_InvertedIndexSize(const struct NumericRange *range);

/**
 * Get the inverted index entries from a range.
 *
 * Returns a pointer to the [`InvertedIndexNumeric`] (which is a `NumericIndex` enum)
 * stored inside the range. The returned pointer is valid until the tree is modified or freed.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 * - The returned pointer points to memory owned by the range; do not free it.
 */
const InvertedIndexNumeric *NumericRange_GetEntries(const struct NumericRange *range);

/**
 * Create an [`IndexReader`] for iterating over a [`NumericRange`]'s entries.
 *
 * This is the primary way to iterate over numeric index entries from C code.
 * The returned reader can be used with `IndexReader_Next()`, `IndexReader_Seek()`, etc.
 * from `inverted_index_ffi`.
 *
 * If `filter` is NULL, all entries are returned. Otherwise, entries are filtered
 * according to the numeric filter (or geo filter if the filter's `geo_filter` is set).
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 * - `filter` may be NULL for no filtering, or must point to a valid [`NumericFilter`].
 * - The returned reader holds a reference to the range's inverted index. The range
 *   must not be freed or modified while the reader exists.
 * - The filter (if non-NULL) must remain valid for the lifetime of the reader.
 * - Free the returned reader with `IndexReader_Free()` when done.
 */
IndexReader *NumericRange_NewIndexReader(const struct NumericRange *range,
                                         const NumericFilter *filter);

/**
 * Get the revision ID of the tree.
 *
 * The revision ID changes whenever the tree structure is modified (nodes split, etc.).
 * This is used by iterators to detect concurrent modifications.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uint32_t NumericRangeTree_GetRevisionId(const struct NumericRangeTree *t);

/**
 * Increment the revision ID.
 *
 * This method is never needed in production code: the tree
 * revision ID is automatically incremented when the tree structure changes.
 *
 * This method is provided primarily for testing purposes—e.g. to force the invalidation
 * of an iterator built on top of this tree in GC tests.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 * - The caller must have unique access to `t`.
 */
uint32_t NumericRangeTree_IncrementRevisionId(struct NumericRangeTree *t);

/**
 * Get the unique ID of the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uint32_t NumericRangeTree_GetUniqueId(const struct NumericRangeTree *t);

/**
 * Get the number of entries in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetNumEntries(const struct NumericRangeTree *t);

/**
 * Get the number of ranges in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetNumRanges(const struct NumericRangeTree *t);

/**
 * Get the total size of inverted indexes in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetInvertedIndexesSize(const struct NumericRangeTree *t);

/**
 * Get the root node of the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 * - The returned pointer is valid until the tree is modified or freed.
 */
const struct NumericRangeNode *NumericRangeTree_GetRoot(const struct NumericRangeTree *t);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
