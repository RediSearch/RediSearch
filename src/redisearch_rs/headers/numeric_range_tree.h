#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/numeric_range_tree_ffi/build.rs`. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "types_rs.h"
#include "redisearch.h"
#include "inverted_index.h"
#include "redismodule.h"
/**
 * Opaque type for the Rust numeric inverted index.
 *
 * This is intentionally incompatible with the C InvertedIndex type.
 * Use accessor functions to interact with this type.
 */
typedef struct InvertedIndexNumeric InvertedIndexNumeric;


/**
 * Opaque reader that iterates over index-tagged GC entries from a pre-read buffer.
 *
 * Created by [`NumericGcBatchReader_New`], advanced by [`NumericGcBatchReader_Next`],
 * and freed by [`NumericGcBatchReader_Free`].
 */
typedef struct NumericGcBatchReader NumericGcBatchReader;

/**
 * A numeric range is a leaf-level storage unit in the numeric range tree.
 *
 * It stores document IDs and their associated numeric values in an inverted index,
 * along with metadata for range queries and cardinality estimation.
 *
 * # Structure
 *
 * - **Bounds** (`min_val`, `max_val`): Track the actual value range for overlap
 *   and containment tests during queries.
 * - **Cardinality** (`hll`): HyperLogLog estimator for the number of distinct
 *   values, used to decide when to split.
 * - **Entries** (`entries`): Inverted index storing (docId, value) pairs.
 *
 * # Initialization
 *
 * New ranges start with inverted bounds (`min_val = +∞`, `max_val = -∞`) so
 * the first added value correctly sets both bounds.
 */
typedef struct NumericRange NumericRange;

/**
 * A node in the numeric range tree.
 *
 * Nodes are either:
 * - **Leaf nodes**: Have a range but no children.
 * - **Internal nodes**: Have both children, a split value, depth tracking,
 *   and optionally retain a range for query efficiency.
 *
 * When part of a [`NumericRangeTree`](crate::NumericRangeTree), nodes are
 * stored in a [`slab::Slab`] arena and referenced by [`NodeIndex`].
 */
typedef struct NumericRangeNode NumericRangeNode;

/**
 * Opaque wrapper around the Rust [`NumericRangeTreeInner`].
 */
typedef struct NumericRangeTree NumericRangeTree;

/**
 * Opaque wrapper around a [`IteratorInner`].
 *
 * The iterator holds references to nodes in the tree. The tree must not be
 * freed or mutated while this iterator exists.
 */
typedef struct NumericRangeTreeIterator NumericRangeTreeIterator;

/**
 * Result of adding a value to a [`NumericRangeTree`].
 *
 * This struct is C-compatible and mirrors the information returned by
 * [`numeric_range_tree::AddResult`].
 */
typedef struct NRN_AddRv {
  /**
   * The number of bytes the tree's memory usage changed by.
   */
  int sz;
  /**
   * The number of records added.
   */
  int numRecords;
  /**
   * Whether the tree structure changed (1 if splits occurred, 0 otherwise).
   */
  int changed;
  /**
   * The change in the number of ranges.
   */
  int numRanges;
  /**
   * The change in the number of leaves.
   */
  int numLeaves;
} NRN_AddRv;

/**
 * Result of [`NumericRangeTree_Find`] - an array of range pointers.
 *
 * The caller is responsible for freeing this result using
 * [`NumericRangeTreeFindResult_Free`]. The ranges themselves are owned by
 * the tree and must not be freed individually.
 */
typedef struct NumericRangeTreeFindResult {
  /**
   * Pointer to array of range pointers.
   */
  const struct NumericRange *const *ranges;
  /**
   * Number of ranges in the array.
   */
  uintptr_t len;
  /**
   * Capacity of the array (for deallocation).
   */
  uintptr_t capacity;
} NumericRangeTreeFindResult;

/**
 * Result of a batch GC scan. Contains the serialized index-tagged deltas.
 *
 * If `has_work` is false, the buffer is empty and should not be sent.
 * Free with [`NumericGcScanBuffer_Free`].
 */
typedef struct NumericGcScanBuffer {
  /**
   * Pointer to the buffer data. NULL if no work.
   */
  const uint8_t *data;
  /**
   * Length of the buffer in bytes.
   */
  uintptr_t len;
  /**
   * Whether any node had GC work.
   */
  bool has_work;
  /**
   * Capacity (for deallocation).
   */
  uintptr_t capacity;
} NumericGcScanBuffer;

/**
 * Result of applying GC to a single node in a numeric range tree.
 *
 * Returned by [`NumericRangeTree_ApplyGcToNode`].
 */
typedef struct NumericSingleNodeGcResult {
  /**
   * Number of entries removed from this node.
   */
  uintptr_t entries_removed;
  /**
   * Bytes freed from this node.
   */
  uintptr_t bytes_freed;
  /**
   * Bytes allocated (for new compacted blocks) in this node.
   */
  uintptr_t bytes_allocated;
  /**
   * Blocks ignored in this node.
   */
  uint64_t blocks_ignored;
  /**
   * Whether this node became empty after GC.
   */
  bool became_empty;
} NumericSingleNodeGcResult;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new [`NumericRangeTree`].
 *
 * Returns an opaque pointer to the newly created tree.
 * To free the tree, use [`NumericRangeTree_Free`].
 *
 * If `compress_floats` is true, the tree will use float compression which
 * attempts to store f64 values as f32 when precision loss is acceptable (< 0.01).
 * This corresponds to the `RSGlobalConfig.numericCompress` setting.
 */
struct NumericRangeTree *NewNumericRangeTree(bool compress_floats);

/**
 * Add a (docId, value) pair to the tree.
 *
 * If `isMulti` is non-zero, duplicate document IDs are allowed.
 * `maxDepthRange` specifies the maximum depth at which to retain ranges on inner nodes.
 *
 * Returns an [`NRN_AddRv`] struct containing information about what changed
 * during the add operation.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
struct NRN_AddRv NumericRangeTree_Add(struct NumericRangeTree *t,
                                      t_docId doc_id,
                                      double value,
                                      int isMulti,
                                      uintptr_t maxDepthRange);

/**
 * Free a [`NumericRangeTree`] and all its contents.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`], or be NULL (in which case this is a no-op).
 * - After calling this function, `t` must not be used again.
 * - Any iterators obtained from this tree must be freed before calling this.
 */
void NumericRangeTree_Free(struct NumericRangeTree *t);

/**
 * Get the total memory usage of the tree in bytes.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_MemUsage(const struct NumericRangeTree *t);

/**
 * Find all numeric ranges that match the given filter.
 *
 * Returns a [`NumericRangeTreeFindResult`] containing pointers to the matching
 * ranges. The ranges are owned by the tree and must not be freed individually.
 * The result itself must be freed using [`NumericRangeTreeFindResult_Free`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 * - `nf` must point to a valid [`NumericFilter`] and cannot be NULL.
 */
struct NumericRangeTreeFindResult NumericRangeTree_Find(const struct NumericRangeTree *t,
                                                        const NumericFilter *nf);

/**
 * Free a [`NumericRangeTreeFindResult`].
 *
 * This frees the array allocation but NOT the ranges themselves (they are
 * owned by the tree).
 *
 * # Safety
 *
 * - `result` must have been obtained from [`NumericRangeTree_Find`].
 * - After calling this function, the result must not be used again.
 */
void NumericRangeTreeFindResult_Free(struct NumericRangeTreeFindResult result);

/**
 * Trim empty leaves from the tree (garbage collection).
 *
 * Removes leaf nodes that have no documents and prunes the tree structure
 * accordingly.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 * - No iterators should be active on this tree while calling this function.
 */
struct NRN_AddRv NumericRangeTree_TrimEmptyLeaves(struct NumericRangeTree *t);

/**
 * Get the base size of a NumericRangeTree struct (not including contents).
 *
 * This is used for memory overhead calculations.
 */
uintptr_t NumericRangeTree_BaseSize(void);

/**
 * Reply with a summary of the numeric range tree (for NUMIDX_SUMMARY).
 *
 * This outputs the tree statistics in the format expected by FT.DEBUG NUMIDX_SUMMARY.
 * If `t` is NULL, outputs zeros for all fields (empty tree).
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must either point to a valid [`NumericRangeTree`] or be NULL.
 */
void NumericRangeTree_DebugSummary(RedisModuleCtx *ctx, const struct NumericRangeTree *t);

/**
 * Reply with a dump of the numeric index entries (for DUMP_NUMIDX).
 *
 * This outputs all entries from all ranges in the tree. If `with_headers` is true,
 * each range's entries are prefixed with header information (numDocs, numEntries, etc).
 * If `t` is NULL, outputs an empty array.
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must either point to a valid [`NumericRangeTree`] or be NULL.
 */
void NumericRangeTree_DebugDumpIndex(RedisModuleCtx *ctx,
                                     const struct NumericRangeTree *t,
                                     bool with_headers);

/**
 * Reply with a dump of the numeric index tree structure (for DUMP_NUMIDXTREE).
 *
 * This outputs the tree structure as a nested map. If `minimal` is true,
 * range entry details are omitted (only tree structure is shown).
 * If `t` is NULL, outputs an empty tree structure with all zeros.
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must either point to a valid [`NumericRangeTree`] or be NULL.
 */
void NumericRangeTree_DebugDumpTree(RedisModuleCtx *ctx,
                                    const struct NumericRangeTree *t,
                                    bool minimal);

/**
 * Conditionally trim empty leaves and compact the node slab.
 *
 * Checks if the number of empty leaves exceeds half the total number of
 * leaves. If so, trims empty leaves, compacts the slab to reclaim freed
 * slots, and returns the number of bytes freed. Returns 0 if no trimming
 * was needed.
 *
 * # Safety
 *
 * - `t` must point to a valid mutable [`NumericRangeTree`] and cannot be NULL.
 * - No iterators should be active on this tree while calling this function.
 */
uintptr_t NumericRangeTree_CompactIfSparse(struct NumericRangeTree *t);

/**
 * Free a [`NumericGcScanBuffer`] returned by [`NumericRangeTree_GcScanBatch`].
 *
 * # Safety
 *
 * - `buf` must have been obtained from [`NumericRangeTree_GcScanBatch`].
 */
void NumericGcScanBuffer_Free(struct NumericGcScanBuffer buf);

/**
 * Scan all nodes in a numeric range tree for GC work (child-side batch scan).
 *
 * Traverses the tree in pre-order DFS and scans each node's range for deleted
 * documents. Returns a [`NumericGcScanBuffer`] containing the serialized
 * index-tagged deltas. The caller should check `has_work` and, if true, send
 * the header followed by the buffer content to the pipe.
 *
 * # Wire format per entry (in the buffer)
 *
 * Only nodes with actual GC work are written:
 * ```text
 * [node_index: u32 LE][delta_msgpack][64-byte hll_with][64-byte hll_without]
 * ```
 *
 * End of buffer is determined by buffer length (already known from header).
 *
 * # Safety
 *
 * - `sctx` must point to a valid [`RedisSearchCtx`] and cannot be NULL.
 * - `tree` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
struct NumericGcScanBuffer NumericRangeTree_GcScanBatch(RedisSearchCtx *sctx,
                                                        const struct NumericRangeTree *tree);

/**
 * Create a new [`NumericGcBatchReader`] from a pre-read buffer.
 *
 * The reader takes ownership of a copy of the data. The caller retains
 * ownership of the original `data` pointer.
 *
 * # Safety
 *
 * - `data` must point to a valid byte buffer of at least `len` bytes,
 *   or be NULL if `len` is 0.
 */
struct NumericGcBatchReader *NumericGcBatchReader_New(const uint8_t *data, uintptr_t len);

/**
 * Read the next entry from the batch reader.
 *
 * Returns `true` if an entry was read, `false` when the buffer is exhausted.
 * On success, `*node_index` is set to the node's slab index and the delta
 * is stored internally for use by [`NumericRangeTree_ApplyGcToNode`].
 *
 * # Safety
 *
 * - `reader` must be a valid pointer returned by [`NumericGcBatchReader_New`].
 * - `node_index` must be a valid pointer to a `u32`.
 */
bool NumericGcBatchReader_Next(struct NumericGcBatchReader *reader, uint32_t *node_index);

/**
 * Apply the most recently read delta to the given node in the tree.
 *
 * The delta is consumed from the reader's internal state (set by the
 * most recent successful [`NumericGcBatchReader_Next`] call).
 *
 * # Safety
 *
 * - `tree` must point to a valid mutable [`NumericRangeTree`] and cannot be NULL.
 * - `reader` must be a valid pointer returned by [`NumericGcBatchReader_New`],
 *   and [`NumericGcBatchReader_Next`] must have returned `true` immediately before.
 */
struct NumericSingleNodeGcResult NumericRangeTree_ApplyGcToNode(struct NumericRangeTree *tree,
                                                                struct NumericGcBatchReader *reader);

/**
 * Get the number of bytes consumed so far from the reader's buffer.
 *
 * # Safety
 *
 * - `reader` must be a valid pointer returned by [`NumericGcBatchReader_New`].
 */
uintptr_t NumericGcBatchReader_BytesConsumed(const struct NumericGcBatchReader *reader);

/**
 * Free a [`NumericGcBatchReader`].
 *
 * # Safety
 *
 * - `reader` must be a valid pointer returned by [`NumericGcBatchReader_New`],
 *   or NULL (in which case this is a no-op).
 */
void NumericGcBatchReader_Free(struct NumericGcBatchReader *reader);

/**
 * Create a new iterator over all nodes in the tree.
 *
 * The iterator performs a depth-first traversal, visiting each node exactly once.
 * Use [`NumericRangeTreeIterator_Next`] to advance the iterator.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`crate::NewNumericRangeTree`] and cannot be NULL.
 * - `t` must not be freed while the iterator lives.
 * - The tree must not be mutated while the iterator lives.
 */
struct NumericRangeTreeIterator *NumericRangeTreeIterator_New(const struct NumericRangeTree *t);

/**
 * Advance the iterator and return the next node.
 *
 * Returns a pointer to the next [`NumericRangeNode`] in the traversal,
 * or NULL if the iteration is complete.
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator`] obtained from
 *   [`NumericRangeTreeIterator_New`] and cannot be NULL.
 * - The tree from which this iterator was created must still be valid.
 */
const struct NumericRangeNode *NumericRangeTreeIterator_Next(struct NumericRangeTreeIterator *it);

/**
 * Free a [`NumericRangeTreeIterator`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator`] obtained from
 *   [`NumericRangeTreeIterator_New`], or be NULL (in which case this is a no-op).
 * - After calling this function, `it` must not be used again.
 */
void NumericRangeTreeIterator_Free(struct NumericRangeTreeIterator *it);

/**
 * Get the [`NumericRange`] from a node, if present.
 *
 * Returns a pointer to the range, or NULL if the node has no range
 * (e.g., an internal node whose range has been trimmed).
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `node` must point to a valid [`NumericRangeNode`] obtained from
 *   [`crate::iterator::NumericRangeTreeIterator_Next`] and cannot be NULL.
 * - The tree from which this node came must still be valid.
 */
const struct NumericRange *NumericRangeNode_GetRange(const struct NumericRangeNode *node);

/**
 * Get the estimated cardinality (number of distinct values) for a range.
 *
 * This uses HyperLogLog estimation and may have some error margin.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `range` must point to a valid [`NumericRange`] obtained from
 *   [`crate::node::NumericRangeNode_GetRange`] and cannot be NULL.
 * - The tree from which this range came must still be valid.
 */
uintptr_t NumericRange_GetCardinality(const struct NumericRange *range);

/**
 * Get the minimum value in a range.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
double NumericRange_MinVal(const struct NumericRange *range);

/**
 * Get the maximum value in a range.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
double NumericRange_MaxVal(const struct NumericRange *range);

/**
 * Get the inverted index size in bytes.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
uintptr_t NumericRange_InvertedIndexSize(const struct NumericRange *range);

/**
 * Get the inverted index entries from a range.
 *
 * Returns a pointer to the [`InvertedIndexNumeric`] (which is a `NumericIndex` enum)
 * stored inside the range. The returned pointer is valid until the tree is modified or freed.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 * - The returned pointer points to memory owned by the range; do not free it.
 */
const InvertedIndexNumeric *NumericRange_GetEntries(const struct NumericRange *range);

/**
 * Create an [`IndexReader`] for iterating over a [`NumericRange`]'s entries.
 *
 * This is the primary way to iterate over numeric index entries from C code.
 * The returned reader can be used with `IndexReader_Next()`, `IndexReader_Seek()`, etc.
 * from `inverted_index_ffi`.
 *
 * If `filter` is NULL, all entries are returned. Otherwise, entries are filtered
 * according to the numeric filter (or geo filter if the filter's `geo_filter` is set).
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 * - `filter` may be NULL for no filtering, or must point to a valid [`NumericFilter`].
 * - The returned reader holds a reference to the range's inverted index. The range
 *   must not be freed or modified while the reader exists.
 * - The filter (if non-NULL) must remain valid for the lifetime of the reader.
 * - Free the returned reader with `IndexReader_Free()` when done.
 */
IndexReader *NumericRange_NewIndexReader(const struct NumericRange *range,
                                         const NumericFilter *filter);

/**
 * Get the revision ID of the tree.
 *
 * The revision ID changes whenever the tree structure is modified (nodes split, etc.).
 * This is used by iterators to detect concurrent modifications.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uint32_t NumericRangeTree_GetRevisionId(const struct NumericRangeTree *t);

/**
 * Increment the revision ID.
 *
 * This method is never needed in production code: the tree
 * revision ID is automatically incremented when the tree structure changes.
 *
 * This method is provided primarily for testing purposes—e.g. to force the invalidation
 * of an iterator built on top of this tree in GC tests.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 * - The caller must have unique access to `t`.
 */
uint32_t NumericRangeTree_IncrementRevisionId(struct NumericRangeTree *t);

/**
 * Get the unique ID of the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uint32_t NumericRangeTree_GetUniqueId(const struct NumericRangeTree *t);

/**
 * Get the number of entries in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetNumEntries(const struct NumericRangeTree *t);

/**
 * Get the number of ranges in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetNumRanges(const struct NumericRangeTree *t);

/**
 * Get the total size of inverted indexes in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetInvertedIndexesSize(const struct NumericRangeTree *t);

/**
 * Get the root node of the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 * - The returned pointer is valid until the tree is modified or freed.
 */
const struct NumericRangeNode *NumericRangeTree_GetRoot(const struct NumericRangeTree *t);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
