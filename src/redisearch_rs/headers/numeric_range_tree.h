#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/numeric_range_tree_ffi/build.rs`. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Opaque wrapper around a [`NumericRangeTreeIterator`].
 *
 * The iterator holds references to nodes in the tree. The tree must not be
 * freed or mutated while this iterator exists.
 */
typedef struct NumericRangeTreeIterator_FFI NumericRangeTreeIterator_FFI;

/**
 * Opaque wrapper around a [`NumericRangeTree`].
 */
typedef struct NumericRangeTree_FFI NumericRangeTree_FFI;

/**
 * Result of adding a value to a [`NumericRangeTree`].
 *
 * This struct is C-compatible and mirrors the information returned by
 * [`numeric_range_tree::AddResult`].
 */
typedef struct NRN_AddRv {
  /**
   * The number of bytes the tree's memory usage changed by.
   */
  int sz;
  /**
   * The number of records added.
   */
  int numRecords;
  /**
   * Whether the tree structure changed (1 if splits occurred, 0 otherwise).
   */
  int changed;
  /**
   * The change in the number of ranges.
   */
  int numRanges;
  /**
   * The change in the number of leaves.
   */
  int numLeaves;
} NRN_AddRv;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new [`NumericRangeTree`].
 *
 * Returns an opaque pointer to the newly created tree.
 * To free the tree, use [`NumericRangeTree_Free`].
 */
struct NumericRangeTree_FFI *NewNumericRangeTree(void);

/**
 * Add a (docId, value) pair to the tree.
 *
 * If `isMulti` is non-zero, duplicate document IDs are allowed.
 *
 * Returns an [`NRN_AddRv`] struct containing information about what changed
 * during the add operation.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree_FFI`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
struct NRN_AddRv NumericRangeTree_Add(struct NumericRangeTree_FFI *t,
                                      t_docId doc_id,
                                      double value,
                                      int isMulti);

/**
 * Free a [`NumericRangeTree`] and all its contents.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree_FFI`] obtained from
 *   [`NewNumericRangeTree`], or be NULL (in which case this is a no-op).
 * - After calling this function, `t` must not be used again.
 * - Any iterators obtained from this tree must be freed before calling this.
 */
void NumericRangeTree_Free(struct NumericRangeTree_FFI *t);

/**
 * Get the total memory usage of the tree in bytes.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree_FFI`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_MemUsage(const struct NumericRangeTree_FFI *t);

/**
 * Create a new iterator over all nodes in the tree.
 *
 * The iterator performs a depth-first traversal, visiting each node exactly once.
 * Use [`NumericRangeTreeIterator_Next`] to advance the iterator.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree_FFI`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 * - `t` must not be freed while the iterator lives.
 * - The tree must not be mutated while the iterator lives.
 */
struct NumericRangeTreeIterator_FFI *NumericRangeTreeIterator_New(const struct NumericRangeTree_FFI *t);

/**
 * Advance the iterator and return the next node.
 *
 * Returns a pointer to the next [`NumericRangeNode`] in the traversal,
 * or NULL if the iteration is complete.
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator_FFI`] obtained from
 *   [`NumericRangeTreeIterator_New`] and cannot be NULL.
 * - The tree from which this iterator was created must still be valid.
 */
const NumericRangeNode *NumericRangeTreeIterator_Next(struct NumericRangeTreeIterator_FFI *it);

/**
 * Free a [`NumericRangeTreeIterator_FFI`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator_FFI`] obtained from
 *   [`NumericRangeTreeIterator_New`], or be NULL (in which case this is a no-op).
 * - After calling this function, `it` must not be used again.
 */
void NumericRangeTreeIterator_Free(struct NumericRangeTreeIterator_FFI *it);

/**
 * Get the [`NumericRange`] from a node, if present.
 *
 * Returns a pointer to the range, or NULL if the node has no range
 * (e.g., an internal node whose range has been trimmed).
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `node` must point to a valid [`NumericRangeNode`] obtained from
 *   [`NumericRangeTreeIterator_Next`] and cannot be NULL.
 * - The tree from which this node came must still be valid.
 */
const NumericRange *NumericRangeNode_GetRange(const NumericRangeNode *node);

/**
 * Get the estimated cardinality (number of distinct values) for a range.
 *
 * This uses HyperLogLog estimation and may have some error margin.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `range` must point to a valid [`NumericRange`] obtained from
 *   [`NumericRangeNode_GetRange`] and cannot be NULL.
 * - The tree from which this range came must still be valid.
 */
uintptr_t NumericRange_GetCardinality(const NumericRange *range);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
