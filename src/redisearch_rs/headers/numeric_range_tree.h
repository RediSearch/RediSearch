#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/numeric_range_tree_ffi/build.rs`. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "spec.h"
#include "types_rs.h"
#include "inverted_index.h"

/**
 * A numeric range is a leaf node in a numeric range tree, representing a range
 * of values bunched together. Since we do not know the distribution of scores
 * ahead, we use a splitting approach - we start with single value nodes, and
 * when a node passes some cardinality we split it.
 *
 * We save the minimum and maximum values inside the node, and when we split we
 * split by finding the median value.
 */
typedef struct NumericRange NumericRange;

/**
 * A node in the numeric range tree. Can be either a leaf node (with a range)
 * or an internal node with left/right children.
 */
typedef struct NumericRangeNode NumericRangeNode;

/**
 * A self-balancing binary search tree with adaptive range bucketing for
 * numeric value indexing.
 *
 * The tree provides efficient range queries and automatically splits ranges
 * when they exceed cardinality thresholds based on depth.
 */
typedef struct NumericRangeTree NumericRangeTree;

/**
 * Tree iterator wrapper for C.
 */
typedef struct NumericRangeTreeIteratorWrapper NumericRangeTreeIteratorWrapper;

typedef struct Vec______NumericRange Vec______NumericRange;

/**
 * Result of an add operation on the NumericRangeTree.
 * This matches the C struct NRN_AddRv.
 */
typedef struct NRN_AddRv {
  /**
   * Change in memory size
   */
  int32_t sz;
  /**
   * Number of records affected
   */
  int32_t num_records;
  /**
   * Whether the tree structure changed
   */
  int32_t changed;
  /**
   * Change in number of ranges
   */
  int32_t num_ranges;
  /**
   * Change in number of leaves
   */
  int32_t num_leaves;
} NRN_AddRv;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a new NumericRangeTree.
 *
 * # Returns
 *
 * A pointer to the newly created tree. The caller is responsible for
 * freeing it with [`NumericRangeTree_Free`].
 */
struct NumericRangeTree *NewNumericRangeTree(void);

/**
 * Frees a NumericRangeTree and all its resources.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer returned by [`NewNumericRangeTree`].
 * - After calling this function, `tree` must not be used.
 */
void NumericRangeTree_Free(struct NumericRangeTree *tree);

/**
 * Adds a value to the NumericRangeTree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 *
 * # Arguments
 *
 * * `tree` - Pointer to the tree
 * * `doc_id` - The document ID
 * * `value` - The numeric value to add
 * * `is_multi` - Non-zero if this is a multi-value field (allows duplicate doc IDs)
 *
 * # Returns
 *
 * The result of the add operation.
 */
struct NRN_AddRv NumericRangeTree_Add(struct NumericRangeTree *tree,
                                      t_docId doc_id,
                                      double value,
                                      int is_multi);

/**
 * Finds all ranges that match the given filter.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 * - `filter` must be a valid pointer to a NumericFilter.
 * - The returned Vector must be freed by the caller.
 *
 * # Returns
 *
 * A C vector containing pointers to matching NumericRange objects.
 * The caller must free the vector but NOT the ranges (they are owned by the tree).
 */
struct Vec______NumericRange *NumericRangeTree_Find(const struct NumericRangeTree *tree,
                                                    const NumericFilter *filter);

/**
 * Frees a vector returned by NumericRangeTree_Find.
 *
 * # Safety
 *
 * - `vec` must be a valid pointer returned by [`NumericRangeTree_Find`], or null.
 */
void NumericRangeTree_FreeVector(struct Vec______NumericRange *vec);

/**
 * Gets the number of elements in a vector returned by NumericRangeTree_Find.
 *
 * # Safety
 *
 * - `vec` must be a valid pointer returned by [`NumericRangeTree_Find`], or null.
 */
uintptr_t NumericRangeTree_VectorSize(const struct Vec______NumericRange *vec);

/**
 * Gets an element from a vector returned by NumericRangeTree_Find.
 *
 * # Safety
 *
 * - `vec` must be a valid pointer returned by [`NumericRangeTree_Find`].
 * - `index` must be less than the vector's size.
 */
const struct NumericRange *NumericRangeTree_VectorGet(const struct Vec______NumericRange *vec,
                                                      uintptr_t index);

/**
 * Trims empty leaves from the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
struct NRN_AddRv NumericRangeTree_TrimEmptyLeaves(struct NumericRangeTree *tree);

/**
 * Gets the cardinality of a NumericRange.
 *
 * # Safety
 *
 * - `range` must be a valid pointer to a NumericRange.
 */
uintptr_t NumericRange_GetCardinality(const struct NumericRange *range);

/**
 * Gets the memory usage of the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
uintptr_t NumericIndexType_MemUsage(const struct NumericRangeTree *tree);

/**
 * Creates a new iterator for the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 * - The tree must outlive the iterator.
 *
 * # Returns
 *
 * A pointer to the iterator. The caller must free it with [`NumericRangeTreeIterator_Free`].
 */
struct NumericRangeTreeIteratorWrapper *NumericRangeTreeIterator_New(const struct NumericRangeTree *tree);

/**
 * Gets the next node from the iterator.
 *
 * # Safety
 *
 * - `iter` must be a valid pointer to an iterator.
 *
 * # Returns
 *
 * A pointer to the next node, or null if there are no more nodes.
 */
const struct NumericRangeNode *NumericRangeTreeIterator_Next(struct NumericRangeTreeIteratorWrapper *iter);

/**
 * Frees a tree iterator.
 *
 * # Safety
 *
 * - `iter` must be a valid pointer returned by [`NumericRangeTreeIterator_New`], or null.
 */
void NumericRangeTreeIterator_Free(struct NumericRangeTreeIteratorWrapper *iter);

/**
 * Checks if a node is a leaf.
 *
 * # Safety
 *
 * - `node` must be a valid pointer to a NumericRangeNode.
 */
bool NumericRangeNode_IsLeaf(const struct NumericRangeNode *node);

/**
 * Gets the range from a node, if present.
 *
 * # Safety
 *
 * - `node` must be a valid pointer to a NumericRangeNode.
 *
 * # Returns
 *
 * A pointer to the range, or null if the node has no range.
 */
const struct NumericRange *NumericRangeNode_GetRange(const struct NumericRangeNode *node);

/**
 * Gets the min value of a range.
 *
 * # Safety
 *
 * - `range` must be a valid pointer to a NumericRange.
 */
double NumericRange_GetMinVal(const struct NumericRange *range);

/**
 * Gets the max value of a range.
 *
 * # Safety
 *
 * - `range` must be a valid pointer to a NumericRange.
 */
double NumericRange_GetMaxVal(const struct NumericRange *range);

/**
 * Gets the number of entries in a range.
 *
 * # Safety
 *
 * - `range` must be a valid pointer to a NumericRange.
 */
uintptr_t NumericRange_GetNumEntries(const struct NumericRange *range);

/**
 * Gets the number of unique docs in a range.
 *
 * # Safety
 *
 * - `range` must be a valid pointer to a NumericRange.
 */
uint32_t NumericRange_GetNumDocs(const struct NumericRange *range);

/**
 * Gets the inverted index size of a range.
 *
 * # Safety
 *
 * - `range` must be a valid pointer to a NumericRange.
 */
uintptr_t NumericRange_GetInvertedIndexSize(const struct NumericRange *range);

/**
 * Gets the number of ranges in the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
uintptr_t NumericRangeTree_GetNumRanges(const struct NumericRangeTree *tree);

/**
 * Gets the number of leaves in the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
uintptr_t NumericRangeTree_GetNumLeaves(const struct NumericRangeTree *tree);

/**
 * Gets the number of entries in the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
uintptr_t NumericRangeTree_GetNumEntries(const struct NumericRangeTree *tree);

/**
 * Gets the revision ID of the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
uint32_t NumericRangeTree_GetRevisionId(const struct NumericRangeTree *tree);

/**
 * Gets the unique ID of the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
uint32_t NumericRangeTree_GetUniqueId(const struct NumericRangeTree *tree);

/**
 * Gets the last doc ID added to the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
t_docId NumericRangeTree_GetLastDocId(const struct NumericRangeTree *tree);

/**
 * Gets the inverted indexes size of the tree.
 *
 * # Safety
 *
 * - `tree` must be a valid pointer to a NumericRangeTree.
 */
uintptr_t NumericRangeTree_GetInvertedIndexesSize(const struct NumericRangeTree *tree);

/**
 * Creates an IndexReader for a NumericRange's inverted index entries.
 *
 * This function allows C code to create an IndexReader to iterate over
 * the entries in a NumericRange. The filter parameter can be used to
 * filter entries by numeric value or geo coordinates.
 *
 * # Safety
 *
 * - `range` must be a valid pointer to a NumericRange.
 * - If `filter` is non-null, it must be a valid pointer to a NumericFilter.
 * - The returned IndexReader must be freed using `IndexReader_Free` from inverted_index_ffi.
 * - The NumericRange must outlive the returned IndexReader.
 *
 * # Returns
 *
 * A pointer to a new IndexReader, or null if `range` is null.
 */
IndexReader *NumericRange_CreateReader(const struct NumericRange *range,
                                       const NumericFilter *filter);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
