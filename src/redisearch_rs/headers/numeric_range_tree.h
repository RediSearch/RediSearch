#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/numeric_range_tree_ffi/build.rs`. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "types_rs.h"
#include "redisearch.h"
#include "inverted_index.h"
#include "redismodule.h"
/**
 * Opaque type for the Rust numeric inverted index.
 *
 * This is intentionally incompatible with the C InvertedIndex type.
 * Use accessor functions to interact with this type.
 */
typedef struct InvertedIndexNumeric InvertedIndexNumeric;


/**
 * Minimum cardinality before considering splitting (at depth 0).
 *
 * At depth 0, we require at least this many distinct values before splitting.
 * This prevents excessive splitting for low-cardinality fields.
 */
#define NumericRangeTree_MINIMUM_RANGE_CARDINALITY 16

/**
 * Maximum cardinality threshold for splitting.
 *
 * Once the split threshold reaches this value, it stays constant regardless
 * of depth. This caps the maximum number of distinct values in any leaf range.
 */
#define NumericRangeTree_MAXIMUM_RANGE_CARDINALITY 2500

/**
 * Maximum number of entries in a range before forcing a split (if cardinality > 1).
 *
 * Even if cardinality is below the threshold, we split if a range accumulates
 * too many entries. This handles cases where many documents share few values.
 * The cardinality > 1 check prevents splitting single-value ranges indefinitely.
 */
#define NumericRangeTree_MAXIMUM_RANGE_SIZE 10000

/**
 * Maximum depth imbalance before rebalancing.
 *
 * We use AVL-like rotations when one subtree's depth exceeds the other by
 * more than this value.
 */
#define NumericRangeTree_MAXIMUM_DEPTH_IMBALANCE 2

/**
 * Cardinality growth factor per depth level.
 *
 * The split cardinality threshold multiplies by this factor for each depth
 * level, capped at [`Self::MAXIMUM_RANGE_CARDINALITY`].
 */
#define NumericRangeTree_CARDINALITY_GROWTH_FACTOR 4

/**
 * A numeric range is a leaf-level storage unit in the numeric range tree.
 *
 * It stores document IDs and their associated numeric values in an inverted index,
 * along with metadata for range queries and cardinality estimation.
 *
 * # Structure
 *
 * - **Bounds** (`min_val`, `max_val`): Track the actual value range for overlap
 *   and containment tests during queries.
 * - **Cardinality** (`hll`): HyperLogLog estimator for the number of distinct
 *   values, used to decide when to split.
 * - **Entries** (`entries`): Inverted index storing (docId, value) pairs.
 *
 * # Initialization
 *
 * New ranges start with inverted bounds (`min_val = +∞`, `max_val = -∞`) so
 * the first added value correctly sets both bounds.
 */
typedef struct NumericRange NumericRange;

/**
 * A node in the numeric range tree.
 *
 * Nodes are either:
 * - **Leaf nodes**: Have a range but no children.
 * - **Internal nodes**: Have both children, a split value, depth tracking,
 *   and optionally retain a range for query efficiency.
 *
 * When part of a [`NumericRangeTree`](crate::NumericRangeTree), nodes are
 * stored in a [`generational_slab::Slab`] arena and referenced by [`NodeIndex`].
 */
typedef struct NumericRangeNode NumericRangeNode;

/**
 * A numeric range tree for efficient range queries over numeric values.
 *
 * The tree organizes documents by their numeric field values into a balanced
 * binary tree of ranges. Each leaf node contains a range of values, and
 * internal nodes may optionally retain their ranges for query efficiency.
 *
 * # Arena Storage
 *
 * All nodes are stored in a [`NodeArena`]. Children are referenced by
 * [`NodeIndex`] instead of `Box<NumericRangeNode>`. This provides better
 * cache locality, eliminates per-node heap allocation overhead, and makes
 * pruning cheaper (index swaps and a single `realloc` rather than a dealloc
 * for every deleted node).
 *
 * # Splitting Strategy
 *
 * Nodes split based on two conditions:
 *
 * - **Cardinality threshold**: When the HyperLogLog-estimated cardinality exceeds
 *   a depth-dependent limit. The threshold is [`Self::MINIMUM_RANGE_CARDINALITY`] at depth 0,
 *   growing by a factor of [`Self::CARDINALITY_GROWTH_FACTOR`] per depth level until capped
 *   at [`Self::MAXIMUM_RANGE_CARDINALITY`].
 *
 * - **Size overflow**: When entry count exceeds [`Self::MAXIMUM_RANGE_SIZE`] and
 *   cardinality > 1. This handles cases where many documents share few values.
 *   The cardinality check prevents splitting single-value ranges indefinitely.
 *
 * # Balancing
 *
 * The tree uses AVL-like single rotations when depth imbalance exceeds
 * [`Self::MAXIMUM_DEPTH_IMBALANCE`].
 */
typedef struct NumericRangeTree NumericRangeTree;

/**
 * An iterator that performs a depth-first traversal of the numeric range tree.
 *
 * This iterator visits all nodes in the tree, yielding each node exactly once.
 * The traversal is done iteratively using an explicit stack to avoid recursion,
 * which is important for deeply nested trees that might overflow the call stack.
 *
 * # Traversal Order
 *
 * Nodes are visited in reverse pre-order (parent -> right child -> left child).
 */
typedef struct ReversePreOrderDfsIterator ReversePreOrderDfsIterator;

/**
 * Result of adding a value to a [`NumericRangeTree`].
 *
 * This struct is C-compatible and mirrors the information returned by
 * [`numeric_range_tree::AddResult`].
 */
typedef struct NRN_AddRv {
  /**
   * The number of bytes the tree's memory usage changed by.
   */
  int sz;
  /**
   * The number of records added.
   */
  int numRecords;
  /**
   * Whether the tree structure changed (1 if splits occurred, 0 otherwise).
   */
  int changed;
  /**
   * The change in the number of ranges.
   */
  int numRanges;
  /**
   * The change in the number of leaves.
   */
  int numLeaves;
} NRN_AddRv;

/**
 * Result of [`NumericRangeTree_Find`] - an array of range pointers.
 *
 * The caller is responsible for freeing this result using
 * [`NumericRangeTreeFindResult_Free`]. The ranges themselves are owned by
 * the tree and must not be freed individually.
 */
typedef struct NumericRangeTreeFindResult {
  /**
   * Pointer to array of range pointers.
   */
  const struct NumericRange *const *ranges;
  /**
   * Number of ranges in the array.
   */
  uintptr_t len;
} NumericRangeTreeFindResult;

/**
 * Type alias for the tree iterator, providing a C-friendly name.
 *
 * The iterator holds references to nodes in the tree. The tree must not be
 * freed or mutated while this iterator exists.
 */
typedef struct ReversePreOrderDfsIterator NumericRangeTreeIterator;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new [`NumericRangeTree`].
 *
 * Returns an opaque pointer to the newly created tree.
 * To free the tree, use [`NumericRangeTree_Free`].
 *
 * If `compress_floats` is true, the tree will use float compression which
 * attempts to store f64 values as f32 when precision loss is acceptable (< 0.01).
 * This corresponds to the `RSGlobalConfig.numericCompress` setting.
 */
struct NumericRangeTree *NewNumericRangeTree(bool compress_floats);

/**
 * Add a (docId, value) pair to the tree.
 *
 * If `isMulti` is non-zero, duplicate document IDs are allowed.
 * `maxDepthRange` specifies the maximum depth at which to retain ranges on inner nodes.
 *
 * Returns an [`NRN_AddRv`] struct containing information about what changed
 * during the add operation.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
struct NRN_AddRv NumericRangeTree_Add(struct NumericRangeTree *t,
                                      t_docId doc_id,
                                      double value,
                                      int isMulti,
                                      uintptr_t maxDepthRange);

/**
 * Free a [`NumericRangeTree`] and all its contents.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`], or be NULL (in which case this is a no-op).
 * - After calling this function, `t` must not be used again.
 * - Any iterators obtained from this tree must be freed before calling this.
 */
void NumericRangeTree_Free(struct NumericRangeTree *t);

/**
 * Get the total memory usage of the tree in bytes.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_MemUsage(const struct NumericRangeTree *t);

/**
 * Find all numeric ranges that match the given filter.
 *
 * Returns a [`NumericRangeTreeFindResult`] containing pointers to the matching
 * ranges. The ranges are owned by the tree and must not be freed individually.
 * The result itself must be freed using [`NumericRangeTreeFindResult_Free`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`NewNumericRangeTree`] and cannot be NULL.
 * - `nf` must point to a valid [`NumericFilter`] and cannot be NULL.
 */
struct NumericRangeTreeFindResult NumericRangeTree_Find(const struct NumericRangeTree *t,
                                                        const NumericFilter *nf);

/**
 * Free a [`NumericRangeTreeFindResult`].
 *
 * This frees the array allocation but NOT the ranges themselves (they are
 * owned by the tree).
 *
 * # Safety
 *
 * - `result` must have been obtained from [`NumericRangeTree_Find`].
 * - After calling this function, the result must not be used again.
 */
void NumericRangeTreeFindResult_Free(struct NumericRangeTreeFindResult result);

/**
 * Get the base size of a NumericRangeTree struct (not including contents).
 *
 * This is used for memory overhead calculations.
 */
uintptr_t NumericRangeTree_BaseSize(void);

/**
 * Reply with a summary of the numeric range tree (for NUMIDX_SUMMARY).
 *
 * This outputs the tree statistics in the format expected by FT.DEBUG NUMIDX_SUMMARY.
 * If `t` is NULL, outputs zeros for all fields (empty tree).
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must either point to a valid [`NumericRangeTree`] or be NULL.
 */
void NumericRangeTree_DebugSummary(RedisModuleCtx *ctx, const struct NumericRangeTree *t);

/**
 * Reply with a dump of the numeric index entries (for DUMP_NUMIDX).
 *
 * This outputs all entries from all ranges in the tree. If `with_headers` is true,
 * each range's entries are prefixed with header information (numDocs, numEntries, etc).
 * If `t` is NULL, outputs an empty array.
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must either point to a valid [`NumericRangeTree`] or be NULL.
 */
void NumericRangeTree_DebugDumpIndex(RedisModuleCtx *ctx,
                                     const struct NumericRangeTree *t,
                                     bool with_headers);

/**
 * Reply with a dump of the numeric index tree structure (for DUMP_NUMIDXTREE).
 *
 * This outputs the tree structure as a nested map. If `minimal` is true,
 * range entry details are omitted (only tree structure is shown).
 * If `t` is NULL, outputs an empty tree structure with all zeros.
 *
 * # Safety
 *
 * - `ctx` must be a valid Redis module context.
 * - `t` must either point to a valid [`NumericRangeTree`] or be NULL.
 */
void NumericRangeTree_DebugDumpTree(RedisModuleCtx *ctx,
                                    const struct NumericRangeTree *t,
                                    bool minimal);

/**
 * Create a new iterator over all nodes in the tree.
 *
 * The iterator performs a depth-first traversal, visiting each node exactly once.
 * Use [`NumericRangeTreeIterator_Next`] to advance the iterator.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `t` must point to a valid [`NumericRangeTree`] obtained from
 *   [`crate::NewNumericRangeTree`] and cannot be NULL.
 * - `t` must not be freed while the iterator lives.
 * - The tree must not be mutated while the iterator lives.
 */
NumericRangeTreeIterator *NumericRangeTreeIterator_New(const struct NumericRangeTree *t);

/**
 * Advance the iterator and return the next node.
 *
 * Returns a pointer to the next [`NumericRangeNode`] in the traversal,
 * or NULL if the iteration is complete.
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator`] obtained from
 *   [`NumericRangeTreeIterator_New`] and cannot be NULL.
 * - The tree from which this iterator was created must still be valid.
 */
const struct NumericRangeNode *NumericRangeTreeIterator_Next(NumericRangeTreeIterator *it);

/**
 * Free a [`NumericRangeTreeIterator`].
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `it` must point to a valid [`NumericRangeTreeIterator`] obtained from
 *   [`NumericRangeTreeIterator_New`], or be NULL (in which case this is a no-op).
 * - After calling this function, `it` must not be used again.
 */
void NumericRangeTreeIterator_Free(NumericRangeTreeIterator *it);

/**
 * Get the [`NumericRange`] from a node, if present.
 *
 * Returns a pointer to the range, or NULL if the node has no range
 * (e.g., an internal node whose range has been trimmed).
 *
 * The returned pointer is valid until the tree is modified or freed.
 * Do NOT free the returned pointer - it points to memory owned by the tree.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `node` must point to a valid [`NumericRangeNode`] obtained from
 *   [`crate::iterator::NumericRangeTreeIterator_Next`] and cannot be NULL.
 * - The tree from which this node came must still be valid.
 */
const struct NumericRange *NumericRangeNode_GetRange(const struct NumericRangeNode *node);

/**
 * Get the estimated cardinality (number of distinct values) for a range.
 *
 * This uses HyperLogLog estimation and may have some error margin.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `range` must point to a valid [`NumericRange`] obtained from
 *   [`crate::node::NumericRangeNode_GetRange`] and cannot be NULL.
 * - The tree from which this range came must still be valid.
 */
uintptr_t NumericRange_GetCardinality(const struct NumericRange *range);

/**
 * Get the minimum value in a range.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
double NumericRange_MinVal(const struct NumericRange *range);

/**
 * Get the maximum value in a range.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
double NumericRange_MaxVal(const struct NumericRange *range);

/**
 * Get the inverted index size in bytes.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 */
uintptr_t NumericRange_InvertedIndexSize(const struct NumericRange *range);

/**
 * Get the inverted index entries from a range.
 *
 * Returns a pointer to the [`InvertedIndexNumeric`] (which is a `NumericIndex` enum)
 * stored inside the range. The returned pointer is valid until the tree is modified or freed.
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 * - The returned pointer points to memory owned by the range; do not free it.
 */
const InvertedIndexNumeric *NumericRange_GetEntries(const struct NumericRange *range);

/**
 * Create an [`IndexReader`] for iterating over a [`NumericRange`]'s entries.
 *
 * This is the primary way to iterate over numeric index entries from C code.
 * The returned reader can be used with `IndexReader_Next()`, `IndexReader_Seek()`, etc.
 * from `inverted_index_ffi`.
 *
 * If `filter` is NULL, all entries are returned. Otherwise, entries are filtered
 * according to the numeric filter (or geo filter if the filter's `geo_filter` is set).
 *
 * # Safety
 *
 * - `range` must point to a valid [`NumericRange`] and cannot be NULL.
 * - `filter` may be NULL for no filtering, or must point to a valid [`NumericFilter`].
 * - The returned reader holds a reference to the range's inverted index. The range
 *   must not be freed or modified while the reader exists.
 * - The filter (if non-NULL) must remain valid for the lifetime of the reader.
 * - Free the returned reader with `IndexReader_Free()` when done.
 */
IndexReader *NumericRange_NewIndexReader(const struct NumericRange *range,
                                         const NumericFilter *filter);

/**
 * Get the revision ID of the tree.
 *
 * The revision ID changes whenever the tree structure is modified (nodes split, etc.).
 * This is used by iterators to detect concurrent modifications.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uint32_t NumericRangeTree_GetRevisionId(const struct NumericRangeTree *t);

/**
 * Increment the revision ID.
 *
 * This method is never needed in production code: the tree
 * revision ID is automatically incremented when the tree structure changes.
 *
 * This method is provided primarily for testing purposes—e.g. to force the invalidation
 * of an iterator built on top of this tree in GC tests.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 * - The caller must have unique access to `t`.
 */
uint32_t NumericRangeTree_IncrementRevisionId(struct NumericRangeTree *t);

/**
 * Get the unique ID of the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uint32_t NumericRangeTree_GetUniqueId(const struct NumericRangeTree *t);

/**
 * Get the number of entries in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetNumEntries(const struct NumericRangeTree *t);

/**
 * Get the number of ranges in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetNumRanges(const struct NumericRangeTree *t);

/**
 * Get the total size of inverted indexes in the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 */
uintptr_t NumericRangeTree_GetInvertedIndexesSize(const struct NumericRangeTree *t);

/**
 * Get the root node of the tree.
 *
 * # Safety
 *
 * - `t` must point to a valid [`NumericRangeTree`] and cannot be NULL.
 * - The returned pointer is valid until the tree is modified or freed.
 */
const struct NumericRangeNode *NumericRangeTree_GetRoot(const struct NumericRangeTree *t);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
