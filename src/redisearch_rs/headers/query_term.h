#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/query_term_ffi/build.rs`. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
typedef struct RSToken RSToken;


/**
 * Flags associated with query tokens and terms.
 *
 * Extension-set token flags â€” up to 31 bits are available for extensions,
 * since 1 bit is reserved for the `expanded` flag on [`RSToken`].
 *
 * [`RSToken`]: https://github.com/RediSearch/RediSearch
 */
typedef uint32_t RSTokenFlags;

/**
 * A single term being evaluated at query time.
 *
 * Each term carries scoring metadata ([`idf`](RSQueryTerm::idf),
 * [`bm25_idf`](RSQueryTerm::bm25_idf)) and a unique
 * [`id`](RSQueryTerm::id) assigned during query parsing.
 *
 * # Memory layout
 *
 * This struct is `#[repr(C)]` so that C code can access its fields directly.
 */
typedef struct RSQueryTerm {
  /**
   * The term string, always NULL-terminated.
   */
  char *str;
  /**
   * The term length in bytes.
   *
   * It doesn't count the null terminator.
   */
  uintptr_t len;
  /**
   * Inverse document frequency of the term in the index.
   *
   * See <https://en.wikipedia.org/wiki/Tf%E2%80%93idf>.
   */
  double idf;
  /**
   * Each term in the query gets an incremental id.
   */
  int32_t id;
  /**
   * Flags given by the engine or by the query expander.
   */
  RSTokenFlags flags;
  /**
   * Inverse document frequency for BM25 scoring.
   */
  double bm25_idf;
} RSQueryTerm;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Allocate a new [`RSQueryTerm`] from an [`RSToken`](ffi::RSToken).
 *
 * The term string is copied into a Rust-owned allocation (`Box<[u8]>`).
 * The returned pointer must be freed with [`Term_Free`].
 *
 * # Safety
 *
 * - `tok` must point to a valid `RSToken` and cannot be NULL.
 * - `tok->str` may be NULL, in which case the resulting term will have a
 *   NULL `str` field.
 * - If not NULL, tok->str should be a valid byte slice of tok->len bytes.
 * - The returned pointer is heap-allocated and must be freed with
 *   [`Term_Free`].
 */
struct RSQueryTerm *NewQueryTerm(const RSToken *tok, int id);

/**
 * Free an [`RSQueryTerm`] previously allocated by [`NewQueryTerm`].
 *
 * # Safety
 *
 * - `t` may be NULL (in which case this is a no-op).
 * - If non-NULL, `t` must have been allocated by [`NewQueryTerm`].
 * - After this call, `t` is dangling and must not be used.
 */
void Term_Free(struct RSQueryTerm *t);

/**
 * Get the IDF (inverse document frequency) value from a query term.
 *
 * # Safety
 *
 * `term` must be a valid, non-null pointer to an [`RSQueryTerm`] previously
 * allocated by [`NewQueryTerm`].
 */
double QueryTerm_GetIDF(const struct RSQueryTerm *term);

/**
 * Set the IDF (inverse document frequency) value on a query term.
 *
 * # Safety
 *
 * `term` must be a valid, non-null pointer to an [`RSQueryTerm`] previously
 * allocated by [`NewQueryTerm`].
 */
void QueryTerm_SetIDF(struct RSQueryTerm *term, double value);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
