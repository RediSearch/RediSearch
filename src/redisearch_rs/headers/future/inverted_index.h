#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/inverted_index_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "config.h"
#include "spec.h"
#include "types_rs.h"

/**
 * An opaque inverted index structure. The actual implementation is determined at runtime based on
 * the index flags provided when creating the index. This allows us to have a single interface for
 * all index types while still being able to optimize the storage and performance for each index
 * type.
 */
typedef struct InvertedIndex InvertedIndex;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new inverted index instance based on the provided flags and options. `raw_doc_encoding`
 * controls whether document IDs only encoding should use raw encoding (true) or varint encoding
 * (false). `compress_floats` controls whether numeric encoding should have its floating point
 * numbers compressed (true) or not (false). Compressing floating point numbers saves memory
 * but lowers precision.
 *
 * The output parameter `mem_size` will be set to the memory usage of the created index. The
 * inverted index should be freed using [`InvertedIndex_Free`] when no longer needed.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `mem_size` must be a valid pointer to a `usize`.
 *
 * # Panics
 * This function will panic if the provided flags does not set at least one of the following
 * storage flags:
 * - `StoreFreqs`
 * - `StoreFieldFlags`
 * - `StoreTermOffsets`
 * - `StoreNumeric`
 * - `DocIdsOnly`
 */
struct InvertedIndex *NewInvertedIndex_Ex(IndexFlags flags,
                                          bool raw_doc_id_encoding,
                                          bool compress_floats,
                                          uintptr_t *mem_size);

/**
 * Free the memory associated with an inverted index instance created using [`NewInvertedIndex_Ex`].
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance created using
 *   [`NewInvertedIndex_Ex`] or `NewInvertedIndex`.
 */
void InvertedIndex_Free(struct InvertedIndex *ii);

/**
 * Get the memory usage of the inverted index instance in bytes.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and must not be NULL.
 */
uintptr_t InvertedIndex_MemUsage(const struct InvertedIndex *ii);

/**
 * Write a new numeric entry to the inverted index. This is only valid for numeric indexes created
 * with the `StoreNumeric` flag. The function returns the number of bytes the memory usage of the
 * index grew by.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_WriteNumericEntry(struct InvertedIndex *ii, t_docId doc_id, double value);

/**
 * Write a new entry to the inverted index. The function returns the number of bytes the memory
 * usage of the index grew by.
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 * - `record` must be a valid pointer to an `RSIndexResult` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_WriteEntryGeneric(struct InvertedIndex *ii, const RSIndexResult *record);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

// Create a new inverted index object, with the given flag.
// The out parameter memsize must be not NULL, the total of allocated memory
// will be returned in it
//
// The inverted index should be freed using [`InvertedIndex_Free`] when no longer needed.
InvertedIndex *NewInvertedIndex(IndexFlags flags, size_t *memsize) {
  return NewInvertedIndex_Ex(flags, RSGlobalConfig.invertedIndexRawDocidEncoding, RSGlobalConfig.numericCompress, memsize);
}
