#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/inverted_index_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "config.h"
#include "search_ctx.h"
#include "spec.h"
#include "types_rs.h"

/**
 * Result of scanning the index for garbage collection
 */
typedef struct InvertedIndexGcDelta InvertedIndexGcDelta;

/**
 * Each `IndexBlock` contains a set of entries for a specific range of document IDs. The entries
 * are ordered by document ID, so the first entry in the block has the lowest document ID, and the
 * last entry has the highest document ID. The block also contains a buffer that is used to
 * store the encoded entries. The buffer is dynamically resized as needed when new entries are
 * added to the block.
 */
typedef struct IndexBlock IndexBlock;

/**
 * An opaque inverted index reader structure. The actual implementation is determined at runtime
 * based on the index type and filter provided when creating the reader. This allows us to have a
 * single interface for all index reader types while still being able to optimize the storage
 * and performance for each index reader type.
 */
typedef struct IndexReader IndexReader;

/**
 * An opaque inverted index structure. The actual implementation is determined at runtime based on
 * the index flags provided when creating the index. This allows us to have a single interface for
 * all index types while still being able to optimize the storage and performance for each index
 * type.
 */
typedef struct InvertedIndex InvertedIndex;

typedef uintptr_t c_size_t;

/**
 * A writer that calls a C function to write data.
 */
typedef struct II_GCWriter {
  /**
   * Context pointer passed to the write function.
   */
  void *ctx;
  /**
   * Function pointer to the write function.
   */
  void (*write)(void *ctx, const void *buf, c_size_t len);
} II_GCWriter;

/**
 * A callback structure to trigger garbage collection operations.
 */
typedef struct II_GCCallback {
  /**
   * Context pointer passed to the call function.
   */
  void *ctx;
  /**
   * Function pointer to the call function.
   */
  void (*call)(void *ctx);
} II_GCCallback;

/**
 * Setting to pass to the GC scan function
 */
typedef struct IndexRepairParams {
  /**
   * Callback to call for each entry that is still valid
   */
  void (*repair_callback)(const RSIndexResult *res, const struct IndexBlock *ib, void*);
  /**
   * Argument to pass to the repair callback
   */
  void *repair_arg;
} IndexRepairParams;

/**
 * A reader that calls a C function to read data.
 */
typedef struct II_GCReader {
  /**
   * Context pointer passed to the read function.
   */
  void *ctx;
  /**
   * Function pointer to the read function.
   */
  int (*read)(void *ctx, void *buf, c_size_t len);
} II_GCReader;

/**
 * Information about the result of applying a garbage collection scan to the index
 */
typedef struct II_GCScanStats {
  /**
   * The number of bytes that were freed
   */
  uintptr_t bytes_freed;
  /**
   * The number of bytes that were allocated
   */
  uintptr_t bytes_allocated;
  /**
   * The number of entries that were removed from the index including duplicates
   */
  uintptr_t entries_removed;
  /**
   * The number of blocks that were ignored because the index changed since the scan was performed
   */
  uintptr_t blocks_ignored;
} II_GCScanStats;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the total number of index blocks allocated across all inverted index instances.
 */
uintptr_t TotalIIBlocks(void);

/**
 * Create a new inverted index instance based on the provided flags and options. `raw_doc_encoding`
 * controls whether document IDs only encoding should use raw encoding (true) or varint encoding
 * (false). `compress_floats` controls whether numeric encoding should have its floating point
 * numbers compressed (true) or not (false). Compressing floating point numbers saves memory
 * but lowers precision.
 *
 * The output parameter `mem_size` will be set to the memory usage of the created index. The
 * inverted index should be freed using [`InvertedIndex_Free`] when no longer needed.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `mem_size` must be a valid pointer to a `usize`.
 *
 * # Panics
 * This function will panic if the provided flags does not set at least one of the following
 * storage flags:
 * - `StoreFreqs`
 * - `StoreFieldFlags`
 * - `StoreTermOffsets`
 * - `StoreNumeric`
 * - `DocIdsOnly`
 */
struct InvertedIndex *NewInvertedIndex_Ex(IndexFlags flags,
                                          bool raw_doc_id_encoding,
                                          bool compress_floats,
                                          uintptr_t *mem_size);

/**
 * Free the memory associated with an inverted index instance created using [`NewInvertedIndex_Ex`].
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance created using
 *   [`NewInvertedIndex_Ex`] or `NewInvertedIndex`.
 */
void InvertedIndex_Free(struct InvertedIndex *ii);

/**
 * Get the memory usage of the inverted index instance in bytes.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and must not be NULL.
 */
uintptr_t InvertedIndex_MemUsage(const struct InvertedIndex *ii);

/**
 * Write a new numeric entry to the inverted index. This is only valid for numeric indexes created
 * with the `StoreNumeric` flag. The function returns the number of bytes the memory usage of the
 * index grew by.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_WriteNumericEntry(struct InvertedIndex *ii, t_docId doc_id, double value);

/**
 * Write a new entry to the inverted index. The function returns the number of bytes the memory
 * usage of the index grew by.
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 * - `record` must be a valid pointer to an `RSIndexResult` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_WriteEntryGeneric(struct InvertedIndex *ii, const RSIndexResult *record);

/**
 * Return the number of blocks in the inverted index.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_NumBlocks(const struct InvertedIndex *ii);

/**
 * Get the flags used to create the inverted index.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
IndexFlags InvertedIndex_Flags(const struct InvertedIndex *ii);

/**
 * Get the number of unique documents in the inverted index.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_NumDocs(const struct InvertedIndex *ii);

/**
 * Get a summary of the inverted index for debugging purposes.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
IISummary InvertedIndex_Summary(const struct InvertedIndex *ii);

/**
 * Get an array of summaries of all blocks in the inverted index. The output parameter `count` will
 * be set to the number of blocks in the index. The returned pointer must be freed using
 * [`InvertedIndex_BlocksSummaryFree`].
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 * - `count` must be a valid pointer to a `usize` and cannot be NULL.
 */
IIBlockSummary *InvertedIndex_BlocksSummary(const struct InvertedIndex *ii, uintptr_t *count);

/**
 * Free the memory associated with the array of block summaries returned by [`InvertedIndex_BlocksSummary`].
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `blocks` must be a valid pointer to an array of `BlockSummary` instances returned by
 *   [`InvertedIndex_BlocksSummary`].
 * - `count` must have the same value as the `count` output parameter passed to
 *   [`InvertedIndex_BlocksSummary`].
 */
void InvertedIndex_BlocksSummaryFree(IIBlockSummary *blocks,
                                     uintptr_t count);

/**
 * Get the field mask used in the inverted index. This is only valid for indexes created with the
 * `StoreFieldFlags` flag. For other index types, this function will return 0.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
t_fieldMask InvertedIndex_FieldMask(const struct InvertedIndex *ii);

/**
 * Get the number of entries in the inverted index. This is only valid for numeric indexes created
 * with the `StoreNumeric` flag. For other index types, this function will return 0.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_NumEntries(const struct InvertedIndex *ii);

/**
 * Get a reference to the block at the specified index. Returns NULL if the index is out of bounds.
 * This is used by some C tests.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
const struct IndexBlock *InvertedIndex_BlockRef(const struct InvertedIndex *ii,
                                                uintptr_t block_idx);

/**
 * Get ID of the last document in the index. Returns 0 if the index is empty.
 * This is used by some C tests.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
t_docId InvertedIndex_LastId(const struct InvertedIndex *ii);

/**
 * Get the garbage collector marker of the inverted index. This is used by some C tests.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance.
 */
uintptr_t InvertedIndex_GcMarker(const struct InvertedIndex *ii);

/**
 * Increment the garbage collector marker of the inverted index. This is used by some C tests.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance.
 */
void InvertedIndex_GcMarkerInc(struct InvertedIndex *ii);

/**
 * Scan the inverted index for garbage and write the GC delta to the provided writer. The function
 * returns true if the scan was successful and false otherwise.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `wr` must be a valid, non NULL, pointer to an `InvertedIndexGCWriter` instance.
 * - `sctx` must be a valid, non NULL, pointer to a `RedisSearchCtx` instance.
 * - `idx` must be a valid, non NULL, pointer to an `InvertedIndex` instance.
 * - `cb` must be a valid, non NULL, pointer to an `InvertedIndexGCCallback` instance.
 * - `params` must be a valid, NULLable, pointer to an `IndexRepairParams` instance.
 * - The `spec` field of the `RedisSearchCtx` must be a valid, non NULL, pointer to an
 *   `IndexSpec` instance.
 */
bool InvertedIndex_GcDelta_Scan(struct II_GCWriter *wr,
                                RedisSearchCtx *sctx,
                                struct InvertedIndex *idx,
                                struct II_GCCallback *cb,
                                struct IndexRepairParams *params);

/**
 * Read a GC delta from the provided reader. The returned pointer must be freed using
 * [`InvertedIndex_GcDelta_Free`] or should be passed to [`InvertedIndex_ApplyGcDelta`].
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `rd` must be a valid, non NULL, pointer to an `InvertedIndexGCReader` instance.
 */
struct InvertedIndexGcDelta *InvertedIndex_GcDelta_Read(struct II_GCReader *rd);

/**
 * Free the memory associated with a GC delta instance created using [`InvertedIndex_GcDelta_Read`].
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `deltas` must be a valid, non NULL, pointer to a `GcScanDelta` instance created using
 *   [`InvertedIndex_GcDelta_Read`].
 */
void InvertedIndex_GcDelta_Free(struct InvertedIndexGcDelta *deltas);

/**
 * Apply a GC delta to the inverted index. The output parameter `apply_info` will be set to
 * information about the applied delta.
 *
 * This will take ownership of the `deltas` pointer and free it. Therefore, it should not be
 * used or freed after calling this function.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance.
 * - `deltas` must be a valid, non NULL, pointer to a `GcScanDelta` instance created using
 *   [`InvertedIndex_GcDelta_Read`].
 * - `apply_info` must be a valid, non NULL, pointer to a `GcApplyInfo` instance.
 */
void InvertedIndex_ApplyGcDelta(struct InvertedIndex *ii,
                                struct InvertedIndexGcDelta *deltas,
                                struct II_GCScanStats *apply_info);

/**
 * Get the index of the last block in the GC delta.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `gc_scan_delta` must be a valid, non NULL, pointer to a `GcScanDelta` instance.
 */
uintptr_t GcScanDelta_LastBlockIdx(const struct InvertedIndexGcDelta *gc_scan_delta);

/**
 * Get ID of the first document in the index block. This is used by some C tests.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ib` must be a valid pointer to an `IndexBlock` instance and cannot be NULL.
 */
t_docId IndexBlock_FirstId(const struct IndexBlock *ib);

/**
 * Get ID of the last document in the index block. This is used by some C tests.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ib` must be a valid pointer to an `IndexBlock` instance and cannot be NULL.
 */
t_docId IndexBlock_LastId(const struct IndexBlock *ib);

/**
 * Get the number of entries in the index block. This is used by some C tests.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ib` must be a valid pointer to an `IndexBlock` instance and cannot be NULL.
 */
uintptr_t IndexBlock_NumEntries(const struct IndexBlock *ib);

/**
 * Get a pointer to the raw data of the index block. This is used by some C tests.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ib` must be a valid pointer to an `IndexBlock` instance and cannot be NULL.
 */
const char *IndexBlock_Data(const struct IndexBlock *ib);

/**
 * Create a new inverted index reader for the given inverted index and filter. The returned pointer
 * must be freed using [`IndexReader_Free`] when no longer needed.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance.
 *
 * # Panics
 * This function will panic if the provided filter is not compatible with the `InvertedIndex` type.
 */
struct IndexReader *NewIndexReader(const struct InvertedIndex *ii, IndexDecoderCtx ctx);

/**
 * Free the memory associated with an index reader instance created using [`NewIndexReader`].
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance created using
 *   [`NewIndexReader`].
 */
void IndexReader_Free(struct IndexReader *ir);

/**
 * Reset the index reader to the beginning of the index.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
void IndexReader_Reset(struct IndexReader *ir);

/**
 * Get the estimated number of documents in the index reader.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
uintptr_t IndexReader_NumEstimated(const struct IndexReader *ir);

/**
 * Check if the index reader can read from the given inverted index. This is true if the index
 * reader was created for the same type of index as the given inverted index.
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance.
 */
bool IndexReader_IsIndex(const struct IndexReader *ir, const struct InvertedIndex *ii);

/**
 * Check if the index reader supports seeking to a specific document ID. This is true for all
 * index reader types.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
bool IndexReader_HasSeeker(const struct IndexReader *_ir);

/**
 * Advance the index reader to the next entry in the index. If there is a next entry, it will be
 * written to the output parameter `res` and the function will return true. If there are no more
 * entries, the function will return false.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 * - `res` must be a valid pointer to an `RSIndexResult` instance.
 */
bool IndexReader_Next(struct IndexReader *ir, RSIndexResult *res);

/**
 * Skip the internal block of the inverted index reader to the block that may contain the given
 * document ID. If such a block exists, the function returns true and the next call to
 * `IndexReader_Seek` will return the entry for the given document ID or the next higher document
 * ID. If the document ID is beyond the last document in the index, the function returns false.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
bool IndexReader_SkipTo(struct IndexReader *ir, t_docId doc_id);

/**
 * Seek the index reader to the entry with the given document ID. If such an entry exists, it will be
 * written to the output parameter `res` and the function will return true. If there is no entry
 * with the given document ID, but there are entries with higher document IDs, the next higher
 * entry will be written to `res` and the function will return true. If there are no more entries
 * with document IDs greater than or equal to the given document ID, the function will return false.
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 * - `res` must be a valid pointer to an `RSIndexResult` instance.
 */
bool IndexReader_Seek(struct IndexReader *ir,
                      t_docId doc_id,
                      RSIndexResult *res);

/**
 * Check if the index reader can return multiple entries for the same document ID.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
bool IndexReader_HasMulti(const struct IndexReader *ir);

/**
 * Get the flags used to create the inverted index of the reader.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
IndexFlags IndexReader_Flags(const struct IndexReader *ir);

/**
 * Get a pointer to the numeric filter used by the index reader. If the index reader does not use
 * a numeric filter, the function will return NULL.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
const NumericFilter *IndexReader_NumericFilter(const struct IndexReader *ir);

/**
 * Swap the inverted index of the reader with the given inverted index. This is only used by some
 * C tests to trigger revalidation on the reader.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance.
 */
void IndexReader_SwapIndex(struct IndexReader *ir, const struct InvertedIndex *ii);

/**
 * Revalidate the index reader against its inverted index. This is only needed if the inverted index
 * has been modified since the last time the reader was used. The function returns true if the
 * reader needs revalidation, false otherwise.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `ir` must be a valid, non NULL, pointer to an `IndexReader` instance.
 */
bool IndexReader_Revalidate(const struct IndexReader *ir);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

// Create a new inverted index object, with the given flag.
// The out parameter memsize must be not NULL, the total of allocated memory
// will be returned in it
//
// The inverted index should be freed using [`InvertedIndex_Free`] when no longer needed.
inline static InvertedIndex *NewInvertedIndex(IndexFlags flags, size_t *memsize) {
  return NewInvertedIndex_Ex(flags, RSGlobalConfig.invertedIndexRawDocidEncoding, RSGlobalConfig.numericCompress, memsize);
}
