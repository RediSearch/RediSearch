#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/inverted_index_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "config.h"
#include "spec.h"
#include "types_rs.h"

/**
 * Each `IndexBlock` contains a set of entries for a specific range of document IDs. The entries
 * are ordered by document ID, so the first entry in the block has the lowest document ID, and the
 * last entry has the highest document ID. The block also contains a buffer that is used to
 * store the encoded entries. The buffer is dynamically resized as needed when new entries are
 * added to the block.
 */
typedef struct IndexBlock IndexBlock;

/**
 * An opaque inverted index structure. The actual implementation is determined at runtime based on
 * the index flags provided when creating the index. This allows us to have a single interface for
 * all index types while still being able to optimize the storage and performance for each index
 * type.
 */
typedef struct InvertedIndex InvertedIndex;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new inverted index instance based on the provided flags and options. `raw_doc_encoding`
 * controls whether document IDs only encoding should use raw encoding (true) or varint encoding
 * (false). `compress_floats` controls whether numeric encoding should have its floating point
 * numbers compressed (true) or not (false). Compressing floating point numbers saves memory
 * but lowers precision.
 *
 * The output parameter `mem_size` will be set to the memory usage of the created index. The
 * inverted index should be freed using [`InvertedIndex_Free`] when no longer needed.
 *
 * # Safety
 *
 * The following invariant must be upheld when calling this function:
 * - `mem_size` must be a valid pointer to a `usize`.
 *
 * # Panics
 * This function will panic if the provided flags does not set at least one of the following
 * storage flags:
 * - `StoreFreqs`
 * - `StoreFieldFlags`
 * - `StoreTermOffsets`
 * - `StoreNumeric`
 * - `DocIdsOnly`
 */
struct InvertedIndex *NewInvertedIndex_Ex(IndexFlags flags,
                                          bool raw_doc_id_encoding,
                                          bool compress_floats,
                                          uintptr_t *mem_size);

/**
 * Free the memory associated with an inverted index instance created using [`NewInvertedIndex_Ex`].
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid, non NULL, pointer to an `InvertedIndex` instance created using
 *   [`NewInvertedIndex_Ex`] or `NewInvertedIndex`.
 */
void InvertedIndex_Free(struct InvertedIndex *ii);

/**
 * Get the memory usage of the inverted index instance in bytes.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and must not be NULL.
 */
uintptr_t InvertedIndex_MemUsage(const struct InvertedIndex *ii);

/**
 * Write a new numeric entry to the inverted index. This is only valid for numeric indexes created
 * with the `StoreNumeric` flag. The function returns the number of bytes the memory usage of the
 * index grew by.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_WriteNumericEntry(struct InvertedIndex *ii, t_docId doc_id, double value);

/**
 * Write a new entry to the inverted index. The function returns the number of bytes the memory
 * usage of the index grew by.
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 * - `record` must be a valid pointer to an `RSIndexResult` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_WriteEntryGeneric(struct InvertedIndex *ii, const RSIndexResult *record);

/**
 * Return the number of blocks in the inverted index.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_NumBlocks(const struct InvertedIndex *ii);

/**
 * Get the flags used to create the inverted index.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
IndexFlags InvertedIndex_Flags(const struct InvertedIndex *ii);

/**
 * Get the number of unique documents in the inverted index.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_NumDocs(const struct InvertedIndex *ii);

/**
 * Get a summary of the inverted index for debugging purposes.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
IISummary InvertedIndex_Summary(const struct InvertedIndex *ii);

/**
 * Get an array of summaries of all blocks in the inverted index. The output parameter `count` will
 * be set to the number of blocks in the index. The returned pointer must be freed using
 * [`InvertedIndex_BlocksSummaryFree`].
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 * - `count` must be a valid pointer to a `usize` and cannot be NULL.
 */
IIBlockSummary *InvertedIndex_BlocksSummary(const struct InvertedIndex *ii, uintptr_t *count);

/**
 * Free the memory associated with the array of block summaries returned by [`InvertedIndex_BlocksSummary`].
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * - `blocks` must be a valid pointer to an array of `BlockSummary` instances returned by
 *   [`InvertedIndex_BlocksSummary`].
 * - `count` must have the same value as the `count` output parameter passed to
 *   [`InvertedIndex_BlocksSummary`].
 */
void InvertedIndex_BlocksSummaryFree(IIBlockSummary *blocks,
                                     uintptr_t count);

/**
 * Get the field mask used in the inverted index. This is only valid for indexes created with the
 * `StoreFieldFlags` flag. For other index types, this function will return 0.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
t_fieldMask InvertedIndex_FieldMask(const struct InvertedIndex *ii);

/**
 * Get the number of entries in the inverted index. This is only valid for numeric indexes created
 * with the `StoreNumeric` flag. For other index types, this function will return 0.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
uintptr_t InvertedIndex_NumEntries(const struct InvertedIndex *ii);

/**
 * Get a reference to the block at the specified index. Returns NULL if the index is out of bounds.
 * This is used by some C tests.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
const struct IndexBlock *InvertedIndex_BlockRef(const struct InvertedIndex *ii,
                                                uintptr_t block_idx);

/**
 * Get ID of the last document in the index. Returns 0 if the index is empty.
 * This is used by some C tests.
 *
 * # Safety
 * The following invariant must be upheld when calling this function:
 * - `ii` must be a valid pointer to an `InvertedIndex` instance and cannot be NULL.
 */
t_docId InvertedIndex_LastId(const struct InvertedIndex *ii);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

// Create a new inverted index object, with the given flag.
// The out parameter memsize must be not NULL, the total of allocated memory
// will be returned in it
//
// The inverted index should be freed using [`InvertedIndex_Free`] when no longer needed.
InvertedIndex *NewInvertedIndex(IndexFlags flags, size_t *memsize) {
  return NewInvertedIndex_Ex(flags, RSGlobalConfig.invertedIndexRawDocidEncoding, RSGlobalConfig.numericCompress, memsize);
}
