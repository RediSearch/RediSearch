#pragma once

/* Warning, this file is autogenerated by cbindgen from `src/redisearch_rs/c_entrypoint/varint/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "buffer.h"
#include "redisearch.h"

/**
 * A structure to encode multiple integers into a single byte buffer,
 * trying to minimize the size of the encoded data.
 *
 * # Delta Encoding
 *
 * Rather than encoding each integer individually, we rely on **delta encoding**.
 * We encode the difference between the current value and the previous value.
 * This approach can significantly reduce the size of the encoded data,
 * under the assumption that values are of a similar magnitude.
 *
 * The delta is encoded using **variable-length integer encoding** (VarInt).
 */
typedef struct VarintVectorWriter VarintVectorWriter;

typedef t_fieldMask FieldMask;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Read a varint-encoded field mask from the given buffer.
 *
 * # Panics
 *
 * Panics if the buffer doesn't contain a valid varint-encoded field mask.
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * 1. `b` must point to a valid `BufferReader` instance and cannot be NULL.
 * 2. The caller must have exclusive access to the buffer reader.
 */
FieldMask ReadVarintFieldMask(BufferReader *b);

/**
 * Write a varint-encoded field mask into the given buffer writer.
 * It returns the number of bytes that have been added to the capacity of
 * the underlying buffer.
 *
 * # Panics
 *
 * Panics if the buffer can't grow its capacity to fit the encoded field mask.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid `BufferWriter` instance and cannot be NULL.
 * 2. The caller must have exclusive access to the buffer writer.
 */
uintptr_t WriteVarintFieldMask(FieldMask value, BufferWriter *writer);

/**
 * Read a varint-encoded value from the given buffer.
 *
 * # Panics
 *
 * Panics if the buffer doesn't contain a valid varint-encoded value.
 *
 * # Safety
 * The following invariants must be upheld when calling this function:
 * 1. `b` must point to a valid `BufferReader` instance and cannot be NULL.
 * 2. The caller must have exclusive access to the buffer reader.
 */
uint32_t ReadVarint(BufferReader *b);

/**
 * Write a varint-encoded value into the given buffer writer.
 * It returns the number of bytes that have been added to the capacity of
 * the underlying buffer.
 *
 * # Panics
 *
 * Panics if the buffer can't grow its capacity to fit the encoded field value.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid `BufferWriter` instance and cannot be NULL.
 * 2. The caller must have exclusive access to the buffer writer.
 */
uintptr_t WriteVarint(uint32_t value, BufferWriter *writer);

/**
 * Create a new [`VectorWriter`] with the given capacity.
 *
 * Use [`VVW_Free`] to free the memory allocated for the [`VectorWriter`].
 */
struct VarintVectorWriter *NewVarintVectorWriter(uintptr_t cap);

/**
 * Delta-encode an integer and write it into the vector.
 *
 * # Return value
 *
 * The varint's actual size, if the operation is successful. 0 in case of failure.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`] and cannot be NULL.
 * 2. The caller must have exclusive access to the [`VectorWriter`] pointed to by `writer`.
 */
uintptr_t VVW_Write(struct VarintVectorWriter *writer,
                    uint32_t value);

/**
 * Get a reference to the underlying byte buffer.
 * It returns a NULL pointer if the writer is NULL.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`]
 */
const uint8_t *VVW_GetByteData(const struct VarintVectorWriter *writer);

/**
 * Get the length of the underlying byte buffer.
 * It returns 0 if the writer is NULL.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`]
 */
uintptr_t VVW_GetByteLength(const struct VarintVectorWriter *writer);

/**
 * Get the number of encoded values in the writer.
 * It returns 0 if the writer is NULL.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`]
 */
uintptr_t VVW_GetCount(const struct VarintVectorWriter *writer);

/**
 * Reset the vector writer.
 *
 * All encoded values are dropped, but the buffer capacity is preserved.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`] and cannot be NULL.
 * 2. The caller must have exclusive access to the [`VectorWriter`] pointed to by `writer`.
 */
void VVW_Reset(struct VarintVectorWriter *writer);

/**
 * Free the memory allocated for the [`VectorWriter`].
 *
 * After calling this function, the pointer is invalidated and should not be used.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`] and cannot be NULL.
 * 2. The caller must have exclusive access to the [`VectorWriter`] pointed to by `writer`.
 */
void VVW_Free(struct VarintVectorWriter *writer);

/**
 * Resize the vector, dropping any excess capacity.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`] and cannot be NULL.
 * 2. The caller must have exclusive access to the [`VectorWriter`] pointed to by `writer`.
 */
uintptr_t VVW_Truncate(struct VarintVectorWriter *writer);

/**
 * Take ownership of the byte buffer stored in the vector.
 * After this call, `len` will be set to the length of the byte buffer while `writer`
 * will be left holding a fresh empty buffer.
 *
 * # Safety
 *
 * The following invariants must be upheld when calling this function:
 * 1. `writer` must point to a valid [`VectorWriter`] obtained from [`NewVarintVectorWriter`] and cannot be NULL.
 * 2. The caller must have exclusive access to the [`VectorWriter`] pointed to by `writer`.
 * 3. The caller must have exclusive access to `len`.
 */
uint8_t *VVW_TakeByteData(struct VarintVectorWriter *writer,
                          uintptr_t *len);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
