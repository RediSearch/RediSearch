#pragma once

/* Warning, this file is auto-generated by cbindgen from `src/redisearch_rs/c_entrypoint/rlookup_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
// forward declarations for bitflags type names
typedef uint32_t RLookupKeyFlags;
typedef uint32_t RLookupOptions;

// forward declarations for types that are only used as a pointer
typedef struct RSValue RSValue;

#define RLOOKUP_F_NOFLAGS 0


enum RLookupCoerceType
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  RLOOKUPCOERCETYPE_STR = 0,
  RLOOKUPCOERCETYPE_INT = 1,
  RLOOKUPCOERCETYPE_DBL = 2,
  RLOOKUPCOERCETYPE_BOOL = 3,
};
#ifndef __cplusplus
typedef uint32_t RLookupCoerceType;
#endif // __cplusplus

enum RLookupKeyFlag
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * This field is (or assumed to be) part of the document itself.
   * This is a basic flag for a loaded key.
   */
  RLOOKUPKEYFLAG_DOCSRC = 1,
  /**
   * This field is part of the index schema.
   */
  RLOOKUPKEYFLAG_SCHEMASRC = 2,
  /**
   * Check the sorting table, if necessary, for the index of the key.
   */
  RLOOKUPKEYFLAG_SVSRC = 4,
  /**
   * This key was created by the query itself (not in the document)
   */
  RLOOKUPKEYFLAG_QUERYSRC = 8,
  /**
   * Copy the key string via strdup. `name` may be freed
   */
  RLOOKUPKEYFLAG_NAMEALLOC = 16,
  /**
   * If the key is already present, then overwrite it (relevant only for LOAD or WRITE modes)
   */
  RLOOKUPKEYFLAG_OVERRIDE = 32,
  /**
   * Request that the key is returned for loading even if it is already loaded.
   */
  RLOOKUPKEYFLAG_FORCELOAD = 64,
  /**
   * This key is unresolved. Its source needs to be derived from elsewhere
   */
  RLOOKUPKEYFLAG_UNRESOLVED = 128,
  /**
   * This field is hidden within the document and is only used as a transient
   * field for another consumer. Don't output this field.
   */
  RLOOKUPKEYFLAG_HIDDEN = 256,
  /**
   * The opposite of [`RLookupKeyFlag::Hidden`]. This field is specified as an explicit return in
   * the RETURN list, so ensure that this gets emitted. Only set if
   * explicitReturn is true in the aggregation request.
   */
  RLOOKUPKEYFLAG_EXPLICITRETURN = 512,
  /**
   * This key's value is already available in the RLookup table,
   * if it was opened for read but the field is sortable and not normalized,
   * so the data should be exactly the same as in the doc.
   */
  RLOOKUPKEYFLAG_VALAVAILABLE = 1024,
  /**
   * This key's value was loaded (by a loader) from the document itself.
   */
  RLOOKUPKEYFLAG_ISLOADED = 2048,
  /**
   * This key type is numeric
   */
  RLOOKUPKEYFLAG_NUMERIC = 4096,
};
#ifndef __cplusplus
typedef uint32_t RLookupKeyFlag;
#endif // __cplusplus

/**
 * Three Loading modes for RLookup
 */
enum RLookupLoadMode
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * Use keylist to load a number of `RLookupLoadOptions::n_keys` from `RLookupLoadOptions::keys`
   */
  RLOOKUPLOADMODE_KEYLIST = 0,
  /**
   * Load only cached keys from the [sorting_vector::RSSortingVector] and do not load from [crate::row::RLookupRow]
   */
  RLOOKUPLOADMODE_SORTINGVECTORKEYS = 1,
  /**
   * Load all keys from both the [sorting_vector::RSSortingVector] and from the [crate::row::RLookupRow]
   */
  RLOOKUPLOADMODE_ALLKEYS = 2,
};
#ifndef __cplusplus
typedef uint32_t RLookupLoadMode;
#endif // __cplusplus

enum RLookupOption
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * If the key cannot be found, do not mark it as an error, but create it and
   * mark it as F_UNRESOLVED
   */
  RLOOKUPOPTION_ALLOWUNRESOLVED = 1,
  /**
   * If a loader was added to load the entire document, this flag will allow
   * later calls to GetKey in read mode to create a key (from the schema) even if it is not sortable
   */
  RLOOKUPOPTION_ALLLOADED = 2,
};
#ifndef __cplusplus
typedef uint32_t RLookupOption;
#endif // __cplusplus

typedef struct IndexSpecCache IndexSpecCache;

typedef struct RLookupKey {
  /**
   * Index into the dynamic values array within the associated `RLookupRow`.
   */
  uint16_t dstidx;
  /**
   * If the source for this key is a sorting vector, this is the index
   * into the `RSSortingVector` within the associated `RLookupRow`.
   */
  uint16_t svidx;
  /**
   * Various flags dictating the behavior of looking up the value of this key.
   * Most notably, `Flags::SVSRC` means the source is an `RSSortingVector` and
   * `Self::svidx` should be used to look up the value.
   */
  RLookupKeyFlags flags;
  /**
   * The path of this key.
   *
   * For fields *not* loaded from a [`FieldSpec`][ffi::FieldSpec], this points to the *same* string
   * as `Self::path`.
   */
  const char *path;
  /**
   * The name of this key.
   */
  const char *name;
  /**
   * The length of this key in bytes, without the null-terminator.
   * Should be used to avoid repeated `strlen` computations.
   */
  uintptr_t name_len;
  /**
   * Pointer to next field in the list
   */
  struct RLookupKey *next;
} RLookupKey;

typedef struct KeyList {
  struct RLookupKey *head;
  struct RLookupKey *tail;
  uint32_t rowlen;
} KeyList;

typedef struct RLookupHeader {
  struct KeyList keys;
} RLookupHeader;

/**
 * An append-only list of [`RLookupKey`]s.
 *
 * This type maintains a mapping from string names to [`RLookupKey`]s.
 */
typedef struct RLookup {
  /**
   * This is a temporary field that should not be accessed. It ensures correct
   * initialization in case of FFI usage.
   */
  uint64_t _canary;
  /**
   * RLookup fields exposed to C.
   */
  struct RLookupHeader header;
  RLookupOptions options;
  IndexSpecCache* index_spec_cache;
  uint64_t id;
} RLookup;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Read(struct RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_ReadEx(struct RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Write(struct RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_WriteEx(struct RLookup *lookup,
                                          const char *name,
                                          size_t name_len,
                                          uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of these `CStr` must be contained within a single allocation!
 *     2. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Load(struct RLookup *lookup,
                                       const char *name,
                                       const char *field_name,
                                       uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of these `CStr` must be contained within a single allocation!
 *     3. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_LoadEx(struct RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         const char *field_name,
                                         uint32_t flags);

/**
 * Initialize the lookup. If cache is provided, then it will be used as an
 * alternate source for lookups whose fields are absent.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `spcache` must be a [valid] pointer to a [`ffi::IndexSpecCache`]
 * 3. The [`ffi::IndexSpecCache`] being pointed MUST NOT get mutated
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Init(struct RLookup *lookup, struct IndexSpecCache *spcache);

/**
 * Releases any resources created by this lookup object. Note that if there are
 * lookup keys created with RLOOKUP_F_NOINCREF, those keys will no longer be
 * valid after this call!
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `lookup` **must not** be used again after this function is called.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Cleanup(struct RLookup *lookup);

/**
 * Add all non-overridden keys from `lookup` to `dest`.
 *
 * For each key in `lookup`, check if it already exists *by name*.
 * - If it does the `flag` argument controls the behaviour (skip with `RLookupKeyFlags::empty()`, override with `RLookupKeyFlag::Override`).
 * - If it doesn't a new key will be created.
 *
 * Flag handling:
 *  * - Preserves persistent source key properties (F_SVSRC, F_HIDDEN, F_EXPLICITRETURN, etc.)
 *  * - Filters out transient flags from source keys (F_OVERRIDE, F_FORCE_LOAD)
 *  * - Respects caller's control flags for behavior (F_OVERRIDE, F_FORCE_LOAD, etc.)
 *  * - Target flags = caller_flags | (source_flags & ~RLOOKUP_TRANSIENT_FLAGS)
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a [`RLookup`]
 * 2. `dest` must be a [valid], non-null pointer to a [`RLookup`]
 * 3. All bits set in `flags` must correspond to a value of [`RLookupKeyFlags`]
 */
void RLookup_AddKeysFrom(struct RLookup *lookup,
                         struct RLookup *dest,
                         uint32_t flags);

/**
 * Find a [`RLookupKey`] in `lookup`' by its `name`.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a [`RLookup`]
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the end of the string
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 */
struct RLookupKey *RLookup_FindKey(struct RLookup *lookup, const char *name, size_t name_len);

/**
 * Search the IndexSpecCache for a field by name.
 *
 * A FieldSpec is returned if the provided lookup contains an IndexSpecCache and there is a field
 * with the given name.
 *
 * # Safety
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `field_name` must contain a valid nul terminator at the end of the string.
 * 3. `field_name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `field_name` must be non-null even for a zero-length cstr.
 */
const FieldSpec *RLookup_FindFieldInSpecCache(struct RLookup *lookup,
                                              const char *field_name);

/**
 * Create a new RLookupKey and add it to the RLookup.
 *
 * # Safety
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The given `flags` must correspond to a value of the enum `RLookupKeyFlags`.
 */
struct RLookupKey *RLookup_CreateKey(struct RLookup *lookup,
                                     const char *name,
                                     size_t name_len,
                                     uint32_t flags);

/**
 * Create a new RLookup as a value type. We can use this in C code as the size and alignment is known at compile time.
 */
struct RLookup RLookup_New_Value(void);

/**
 * Create a new RLookup on the heap. The returned pointer must be freed with `RLookup_Free_Heap`.
 *
 * # Safety
 * 1. The returned pointer must be freed with `RLookup_Free_Heap` and not used after that.
 */
struct RLookup *RLookup_New_Heap(void);

/**
 * Free a RLookup created with `RLookup_New_Heap`.
 *
 * # Safety
 * 1. `lookup` must be a [valid] pointe to `RLookup` created with `RLookup_New_Heap`
 * 2. `lookup` **must not** be used again after this function is called.
 */
void RLookup_Free_Heap(struct RLookup *lookup);

/**
 * Set the path of a RLookupKey. This is not doable via direct field access from C, as Rust tracks with _path and path field.
 *
 * # Safety
 * 1. `rlk` must be a [valid], non-null pointer to a `RLookupKey`
 * 2. The memory pointed to by `path` must contain a valid nul terminator at the end of the string.
 * 3. `path` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `path` must be non-null even for a zero-length cstr.
 */
void RLookup_KeySetPath(struct RLookupKey *rlk,
                        const char *path);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
