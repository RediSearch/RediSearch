#pragma once

/* Warning, this file is auto-generated by cbindgen from `src/redisearch_rs/c_entrypoint/rlookup_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
// forward declarations for bitflags type names
typedef uint32_t RLookupKeyFlags;
typedef uint32_t RLookupOptions;

// forward declarations for types that are only used as a pointer
typedef struct RLookupRow RLookupRow;
typedef struct RSValue RSValue;


enum RLookupKeyFlag
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * This field is (or assumed to be) part of the document itself.
   * This is a basic flag for a loaded key.
   */
  DocSrc = 1,
  /**
   * This field is part of the index schema.
   */
  SchemaSrc = 2,
  /**
   * Check the sorting table, if necessary, for the index of the key.
   */
  SvSrc = 4,
  /**
   * This key was created by the query itself (not in the document)
   */
  QuerySrc = 8,
  /**
   * Copy the key string via strdup. `name` may be freed
   */
  NameAlloc = 16,
  /**
   * If the key is already present, then overwrite it (relevant only for LOAD or WRITE modes)
   */
  Override = 32,
  /**
   * Request that the key is returned for loading even if it is already loaded.
   */
  ForceLoad = 64,
  /**
   * This key is unresolved. Its source needs to be derived from elsewhere
   */
  Unresolved = 128,
  /**
   * This field is hidden within the document and is only used as a transient
   * field for another consumer. Don't output this field.
   */
  Hidden = 256,
  /**
   * The opposite of [`RLookupKeyFlag::Hidden`]. This field is specified as an explicit return in
   * the RETURN list, so ensure that this gets emitted. Only set if
   * explicitReturn is true in the aggregation request.
   */
  ExplicitReturn = 512,
  /**
   * This key's value is already available in the RLookup table,
   * if it was opened for read but the field is sortable and not normalized,
   * so the data should be exactly the same as in the doc.
   */
  ValAvailable = 1024,
  /**
   * This key's value was loaded (by a loader) from the document itself.
   */
  IsLoaded = 2048,
  /**
   * This key type is numeric
   */
  Numeric = 4096,
};
#ifndef __cplusplus
typedef uint32_t RLookupKeyFlag;
#endif // __cplusplus

enum RLookupOption
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * If the key cannot be found, do not mark it as an error, but create it and
   * mark it as F_UNRESOLVED
   */
  AllowUnresolved = 1,
  /**
   * If a loader was added to load the entire document, this flag will allow
   * later calls to GetKey in read mode to create a key (from the schema) even if it is not sortable
   */
  AllLoaded = 2,
};
#ifndef __cplusplus
typedef uint32_t RLookupOption;
#endif // __cplusplus

typedef struct IndexSpecCache IndexSpecCache;

/**
 * Row data for a lookup key. This abstracts the question of if the data comes from a borrowed [RSSortingVector]
 * or from dynamic values stored in the row during processing.
 *
 * The type itself exposes the dynamic values, [`RLookupRow::dyn_values`], as a vector of `Option<T>`, where `T` is the type
 * of the value and it also provides methods to get the length of the dynamic values and check if they are empty.
 *
 * The type `T` is the type of the value stored in the row, which must implement the [`RSValueTrait`].
 * [`RSValueTrait`] is a temporary trait that will be replaced by a type implementing `RSValue` in Rust, see MOD-10347.
 *
 * The C-side allocations of values in [`RLookupRow::dyn_values`] and [`RLookupRow::sorting_vector`] are released on drop.
 */
typedef struct RLookupRow RLookupRow;

typedef struct RLookupKey {
  /**
   * Index into the dynamic values array within the associated `RLookupRow`.
   */
  uint16_t dstidx;
  /**
   * If the source for this key is a sorting vector, this is the index
   * into the `RSSortingVector` within the associated `RLookupRow`.
   */
  uint16_t svidx;
  /**
   * Various flags dictating the behavior of looking up the value of this key.
   * Most notably, `Flags::SVSRC` means the source is an `RSSortingVector` and
   * `Self::svidx` should be used to look up the value.
   */
  RLookupKeyFlags flags;
  /**
   * The path of this key.
   *
   * For fields *not* loaded from a [`FieldSpec`][ffi::FieldSpec], this points to the *same* string
   * as `Self::path`.
   */
  const char *path;
  /**
   * The name of this key.
   */
  const char *name;
  /**
   * The length of this key in bytes, without the null-terminator.
   * Should be used to avoid repeated `strlen` computations.
   */
  uintptr_t name_len;
  /**
   * Pointer to next field in the list
   */
  struct RLookupKey *next;
} RLookupKey;

typedef struct KeyList {
  struct RLookupKey *head;
  struct RLookupKey *tail;
  uint32_t rowlen;
} KeyList;

typedef struct RLookup {
  struct KeyList keys;
} RLookup;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Read(struct RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_ReadEx(struct RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Write(struct RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_WriteEx(struct RLookup *lookup,
                                          const char *name,
                                          size_t name_len,
                                          uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of these `CStr` must be contained within a single allocation!
 *     2. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Load(struct RLookup *lookup,
                                       const char *name,
                                       const char *field_name,
                                       uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of these `CStr` must be contained within a single allocation!
 *     3. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_LoadEx(struct RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         const char *field_name,
                                         uint32_t flags);

/**
 * Initialize the lookup. If cache is provided, then it will be used as an
 * alternate source for lookups whose fields are absent.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `spcache` must be a [valid] pointer to a [`ffi::IndexSpecCache`]
 * 3. The [`ffi::IndexSpecCache`] being pointed MUST NOT get mutated
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Init(struct RLookup *lookup, struct IndexSpecCache *spcache);

/**
 * Releases any resources created by this lookup object. Note that if there are
 * lookup keys created with RLOOKUP_F_NOINCREF, those keys will no longer be
 * valid after this call!
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `lookup` **must not** be used again after this function is called.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Cleanup(struct RLookup *lookup);

/**
 * Writes a key to the row but increments the value reference count before writing it thus having shared ownership.
 *
 * Safety:
 * 1. `key` must be a valid pointer to an [`RLookupKey`].
 * 2. `row` must be a valid pointer to an [`RLookupRow`].
 * 3. `value` must be a valid pointer to an [`ffi::RSValue`].
 */
void RLookup_WriteKey(const struct RLookupKey *key,
                      struct RLookupRow *row,
                      RSValue *value);

/**
 * Writes a key to the row without incrementing the value reference count, thus taking ownership of the value.
 *
 * Safety:
 * 1. `key` must be a valid pointer to an [`RLookupKey`].
 * 2. `row` must be a valid pointer to an [`RLookupRow`].
 * 3. `value` must be a valid pointer to an [`ffi::RSValue`].
 */
void RLookup_WriteOwnKey(const struct RLookupKey *key,
                         struct RLookupRow *row,
                         RSValue *value);

/**
 * Wipes a RLookupRow by decrementing all values and resetting the row.
 *
 * Safety:
 * 1. The pointer must be a valid pointer to an [`RLookupRow`].
 */
void RLookupRow_Wipe(struct RLookupRow *row);

/**
 * Resets a RLookupRow by wiping it (see [`RLookupRow_Wipe`]) and deallocating the memory of the dynamic values.
 *
 * This does not affect the sorting vector.
 *
 * Safety:
 * 1. The pointer must be a valid pointer to an [`RLookupRow`].
 */
void RLookupRow_Reset(struct RLookupRow *row);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
