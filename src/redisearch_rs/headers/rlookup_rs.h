#pragma once

/* Warning, this file is auto-generated by cbindgen from `src/redisearch_rs/c_entrypoint/rlookup_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
// forward declarations for bitflags type names
typedef uint32_t RLookupKeyFlags;
typedef uint32_t RLookupOptions;

// forward declarations for types that are only used as a pointer
typedef struct RLookupRow RLookupRow;
typedef struct RSValue RSValue;


enum RLookupKeyFlag
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * This field is (or assumed to be) part of the document itself.
   * This is a basic flag for a loaded key.
   */
  DocSrc = 1,
  /**
   * This field is part of the index schema.
   */
  SchemaSrc = 2,
  /**
   * Check the sorting table, if necessary, for the index of the key.
   */
  SvSrc = 4,
  /**
   * This key was created by the query itself (not in the document)
   */
  QuerySrc = 8,
  /**
   * Copy the key string via strdup. `name` may be freed
   */
  NameAlloc = 16,
  /**
   * If the key is already present, then overwrite it (relevant only for LOAD or WRITE modes)
   */
  Override = 32,
  /**
   * Request that the key is returned for loading even if it is already loaded.
   */
  ForceLoad = 64,
  /**
   * This key is unresolved. Its source needs to be derived from elsewhere
   */
  Unresolved = 128,
  /**
   * This field is hidden within the document and is only used as a transient
   * field for another consumer. Don't output this field.
   */
  Hidden = 256,
  /**
   * The opposite of [`RLookupKeyFlag::Hidden`]. This field is specified as an explicit return in
   * the RETURN list, so ensure that this gets emitted. Only set if
   * explicitReturn is true in the aggregation request.
   */
  ExplicitReturn = 512,
  /**
   * This key's value is already available in the RLookup table,
   * if it was opened for read but the field is sortable and not normalized,
   * so the data should be exactly the same as in the doc.
   */
  ValAvailable = 1024,
  /**
   * This key's value was loaded (by a loader) from the document itself.
   */
  IsLoaded = 2048,
  /**
   * This key type is numeric
   */
  Numeric = 4096,
};
#ifndef __cplusplus
typedef uint32_t RLookupKeyFlag;
#endif // __cplusplus

enum RLookupOption
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * If the key cannot be found, do not mark it as an error, but create it and
   * mark it as F_UNRESOLVED
   */
  AllowUnresolved = 1,
  /**
   * If a loader was added to load the entire document, this flag will allow
   * later calls to GetKey in read mode to create a key (from the schema) even if it is not sortable
   */
  AllLoaded = 2,
};
#ifndef __cplusplus
typedef uint32_t RLookupOption;
#endif // __cplusplus

/**
 * Row data for a lookup key. This abstracts the question of if the data comes from a borrowed [RSSortingVector]
 * or from dynamic values stored in the row during processing.
 *
 * The type itself exposes the dynamic values, [`RLookupRow::dyn_values`], as a vector of `Option<T>`, where `T` is the type
 * of the value and it also provides methods to get the length of the dynamic values and check if they are empty.
 *
 * The type `T` is the type of the value stored in the row, which must implement the [`RSValueTrait`].
 * [`RSValueTrait`] is a temporary trait that will be replaced by a type implementing `RSValue` in Rust, see MOD-10347.
 *
 * The C-side allocations of values in [`RLookupRow::dyn_values`] and [`RLookupRow::sorting_vector`] are released on drop.
 */
typedef struct RLookupRow RLookupRow;

typedef struct RLookupKey {
  /**
   * Index into the dynamic values array within the associated `RLookupRow`.
   */
  uint16_t dstidx;
  /**
   * If the source for this key is a sorting vector, this is the index
   * into the `RSSortingVector` within the associated `RLookupRow`.
   */
  uint16_t svidx;
  /**
   * Various flags dictating the behavior of looking up the value of this key.
   * Most notably, `Flags::SVSRC` means the source is an `RSSortingVector` and
   * `Self::svidx` should be used to look up the value.
   */
  RLookupKeyFlags flags;
  /**
   * The path of this key.
   *
   * For fields *not* loaded from a [`FieldSpec`][ffi::FieldSpec], this points to the *same* string
   * as `Self::path`.
   */
  const char *path;
  /**
   * The name of this key.
   */
  const char *name;
  /**
   * The length of this key in bytes, without the null-terminator.
   * Should be used to avoid repeated `strlen` computations.
   */
  uintptr_t name_len;
  /**
   * Pointer to next field in the list
   */
  struct RLookupKey *next;
} RLookupKey;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Writes a key to the row but increments the value reference count before writing it thus having shared ownership.
 *
 * Safety:
 * 1. `key` must be a valid pointer to an [`RLookupKey`].
 * 2. `row` must be a valid pointer to an [`RLookupRow`].
 * 3. `value` must be a valid pointer to an [`ffi::RSValue`].
 */
void RLookup_WriteKey(const struct RLookupKey *key,
                      struct RLookupRow *row,
                      RSValue *value);

/**
 * Writes a key to the row without incrementing the value reference count, thus taking ownership of the value.
 *
 * Safety:
 * 1. `key` must be a valid pointer to an [`RLookupKey`].
 * 2. `row` must be a valid pointer to an [`RLookupRow`].
 * 3. `value` must be a valid pointer to an [`ffi::RSValue`].
 */
void RLookup_WriteOwnKey(const struct RLookupKey *key,
                         struct RLookupRow *row,
                         RSValue *value);

/**
 * Wipes a RLookupRow by decrementing all values and resetting the row.
 *
 * Safety:
 * 1. The pointer must be a valid pointer to an [`RLookupRow`].
 */
void RLookupRow_Wipe(struct RLookupRow *row);

/**
 * Resets a RLookupRow by wiping it (see [`RLookupRow_Wipe`]) and deallocating the memory of the dynamic values.
 *
 * This does not affect the sorting vector.
 *
 * Safety:
 * 1. The pointer must be a valid pointer to an [`RLookupRow`].
 */
void RLookupRow_Reset(struct RLookupRow *row);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
