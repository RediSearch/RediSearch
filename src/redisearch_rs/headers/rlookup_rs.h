#pragma once

/* Warning, this file is auto-generated by cbindgen from `src/redisearch_rs/c_entrypoint/rlookup_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
// Required to ensure that the alignment declared by cbindgen is respected on
// the C/C++ side.
#define ALIGNED(n) __attribute__((aligned(n)))

// forward declarations for bitflags type names
typedef uint32_t RLookupKeyFlags;
typedef uint32_t RLookupOptions;

typedef struct RLookup {
  struct RLookupKey *head;
  struct RLookupKey *tail;
  // Length of the data row. This is not necessarily the number
  // of lookup keys
  uint32_t rowlen;
  // Flags/options
  uint32_t options;
  // If present, then GetKey will consult this list if the value is not found in
  // the existing list of keys.
  IndexSpecCache *spcache;
} RLookup;

// forward declarations for types that are only used as a pointer
typedef struct RSValue RSValue;


typedef struct IndexSpecCache IndexSpecCache;

typedef struct Option_Cow_CStr Option_Cow_CStr;

typedef struct Option_IndexSpecCache Option_IndexSpecCache;

#if defined(RUST_DEBUG)
typedef struct RLookupId RLookupId;
#endif

typedef struct RLookupKey {
  /**
   * Index into the dynamic values array within the associated `RLookupRow`.
   */
  uint16_t dstidx;
  /**
   * If the source for this key is a sorting vector, this is the index
   * into the `RSSortingVector` within the associated `RLookupRow`.
   */
  uint16_t svidx;
  /**
   * Various flags dictating the behavior of looking up the value of this key.
   * Most notably, `Flags::SVSRC` means the source is an `RSSortingVector` and
   * `Self::svidx` should be used to look up the value.
   */
  RLookupKeyFlags flags;
  /**
   * The path of this key.
   *
   * For fields *not* loaded from a [`FieldSpec`][ffi::FieldSpec], this points to the *same* string
   * as `Self::path`.
   */
  const char *path;
  /**
   * The name of this key.
   */
  const char *name;
  /**
   * The length of this key in bytes, without the null-terminator.
   * Should be used to avoid repeated `strlen` computations.
   */
  uintptr_t name_len;
  /**
   * Pointer to next field in the list
   */
  struct RLookupKey *next;
} RLookupKey;

typedef struct KeyList {
  struct RLookupKey *head;
  struct RLookupKey *tail;
  uint32_t rowlen;
} KeyList;

typedef struct RLookupHeader {
  struct KeyList keys;
} RLookupHeader;

#if !defined(RUST_DEBUG)
typedef struct ALIGNED(8) RLookupRow {
  uint8_t _0[40];
} RLookupRow;
#endif

#if defined(RUST_DEBUG)
typedef struct ALIGNED(8) RLookupRow {
  uint8_t _0[48];
} RLookupRow;
#endif

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Read(struct RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_ReadEx(struct RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Write(struct RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_WriteEx(struct RLookup *lookup,
                                          const char *name,
                                          size_t name_len,
                                          uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of these `CStr` must be contained within a single allocation!
 *     2. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Load(struct RLookup *lookup,
                                       const char *name,
                                       const char *field_name,
                                       uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of these `CStr` must be contained within a single allocation!
 *     3. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_LoadEx(struct RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         const char *field_name,
                                         uint32_t flags);

/**
 * Initialize the lookup. If cache is provided, then it will be used as an
 * alternate source for lookups whose fields are absent.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `spcache` must be a [valid] pointer to a [`ffi::IndexSpecCache`]
 * 3. The [`ffi::IndexSpecCache`] being pointed MUST NOT get mutated
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Init(struct RLookup *lookup, struct IndexSpecCache *spcache);

/**
 * Releases any resources created by this lookup object. Note that if there are
 * lookup keys created with RLOOKUP_F_NOINCREF, those keys will no longer be
 * valid after this call!
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `lookup` **must not** be used again after this function is called.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Cleanup(struct RLookup *lookup);

/**
 * Writes a key to the row but increments the value reference count before writing it thus having shared ownership.
 *
 * # Safety
 *
 * 1. `key` must be a [valid], non-null pointer to an [`RLookupKey`].
 * 2. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 3. `value` must be a [valid], non-null pointer to an [`ffi::RSValue`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_WriteKey(const struct RLookupKey *key,
                      struct RLookupRow *row,
                      RSValue *value);

/**
 * Writes a key to the row without incrementing the value reference count, thus taking ownership of the value.
 *
 * # Safety
 *
 * 1. `key` must be a [valid], non-null pointer to an [`RLookupKey`].
 * 2. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 3. `value` must be a [valid], non-null pointer to an [`ffi::RSValue`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_WriteOwnKey(const struct RLookupKey *key,
                         struct RLookupRow *row,
                         RSValue *value);

/**
 * Creates a RLookupRow on the stack associated with the given lookup.
 *
 * The lookup is only tracked in Debug builds
 *
 * # Safety
 * /// 1. `lookup` must be a [valid], non-null pointer to an [`RLookup`].
 */
struct RLookupRow RLookupRow_CreateOnStack(struct RLookup *lookup);

/**
 * Wipes a RLookupRow by decrementing all values and resetting the row.
 *
 * # Safety
 *
 * 1. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookupRow_Wipe(struct RLookupRow *row);

/**
 * Resets a RLookupRow by wiping it (see [`RLookupRow_Wipe`]) and deallocating the memory of the dynamic values.
 *
 * This does not affect the sorting vector.
 *
 * # Safety
 *
 * 1. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookupRow_Reset(struct RLookupRow *row);

/**
 * Move data from the source row to the destination row. The source row is cleared.
 * The destination row should be pre-cleared (though its cache may still exist).
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to an [`RLookup`].
 * 2. `src` must be a [valid], non-null pointer to an [`rlookup::RLookupRow`].
 * 3. `dst` must be a [valid], non-null pointer to an [`rlookup::RLookupRow`].
 * 4. `src` and `dst` must not be the same lookup row.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookupRow_Move(struct RLookup *lookup, struct RLookupRow *src, struct RLookupRow *dst);

/**
 * Write fields from a source row into a destination row, the fields must exist in both lookups (schemas).
 *
 * Iterate through the source lookup keys, if it finds a corresponding key in the destination
 * lookup by name, then it's value is written to this row as a destination.
 *
 * If a source key is not found in the destination lookup the function will panic (same as C behavior).
 *
 * If a source key has no value in the source row, it is skipped.
 *
 * # Safety
 * 1. `src_lookup` must be a [valid], non-null pointer to an [`RLookup`].
 * 2. `src_row` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 3. `dst_lookup` must be a [valid], non-null pointer to an [`RLookup`].
 * 4. `dst_row` must be a [valid], non-null pointer to an [`RLookupRow`].
 */
void RLookupRow_WriteFieldsFrom(struct RLookupRow *src_row,
                                struct RLookup *src_lookup,
                                struct RLookupRow *dst_row,
                                struct RLookup *dst_lookup);

/**
 * Add all on-overridden keys from `src` to `self`.
 *
 * For each key in src, check if it already exists *by name*.
 * - If it does the `flag` argument controls the behaviour (skip with `RLookupKeyFlags::empty()`, override with `RLookupKeyFlag::Override`).
 * - If it doesn't a new key will ne created.
 *
 * Flag handling:
 *  * - Preserves persistent source key properties (F_SVSRC, F_HIDDEN, F_EXPLICITRETURN, etc.)
 *  * - Filters out transient flags from source keys (F_OVERRIDE, F_FORCE_LOAD)
 *  * - Respects caller's control flags for behavior (F_OVERRIDE, F_FORCE_LOAD, etc.)
 *  * - Target flags = caller_flags | (source_flags & ~RLOOKUP_TRANSIENT_FLAGS)
 *
 * # Safety:
 * 1. `src` must be a [valid], non-null pointer to an [`RLookup`].
 * 2. `dst` must be a [valid], non-null pointer to an [`RLookup`].
 */
void RLookup_AddKeysFrom(struct RLookup *src,
                         struct RLookup *dst,
                         uint32_t flags);

/**
 * Retrieves an item from the given `RLookupRow` based on the provided `RLookupKey`.
 * The function first checks for dynamic values, and if not found, it checks the sorting vector
 * if the `SvSrc` flag is set in the key.
 * If the item is not found in either location, it returns `None`.
 *
 * # Safety
 * 1. `key` must be a [valid], non-null pointer to an [`RLookupKey`].
 * 2. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 */
const RSValue *RLookup_GetItem(struct RLookupKey *key, struct RLookupRow *row);

/**
 * Sets a sorting vector for the row.
 * Safety:
 * 1. `row` must be a valid pointer to an [`RLookupRow`].
 * 2. `sv` must be a valid pointer to an [`ffi::RSSortingVector`].
 */
void RLookupRow_SetSortingVector(struct RLookupRow *row, const RSSortingVector *sv);

/**
 * Returns a pointer to the sorting vector if it exists, or null otherwise.
 *
 * Safety:
 * 1. `row` must be a valid pointer to an [`RLookupRow`].
 */
const RSSortingVector *RLookupRow_GetSortingVector(struct RLookupRow *row);

/**
 * Returns the number of dynamic values in the row.
 *
 * # Safety
 * Safety:
 * 1. `row` must be a valid pointer to an [`RLookupRow`].
 */
uint32_t RLookupRow_GetDynLen(struct RLookupRow *row);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
