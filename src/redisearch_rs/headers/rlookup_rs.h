#pragma once

/* Warning, this file is auto-generated by cbindgen from `src/redisearch_rs/c_entrypoint/rlookup_ffi/build.rs. Don't modify it manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
// forward declarations for bitflags type names
typedef uint32_t RLookupKeyFlags;
typedef uint32_t RLookupOptions;

typedef struct RLookup {
  struct RLookupKey *head;
  struct RLookupKey *tail;
  // Length of the data row. This is not necessarily the number
  // of lookup keys
  uint32_t rowlen;
  // Flags/options
  uint32_t options;
  // If present, then GetKey will consult this list if the value is not found in
  // the existing list of keys.
  IndexSpecCache *spcache;
} RLookup;

typedef struct RLookupRow {
  uint8_t opaque;
} RLookupRow;

// forward declarations for types that are only used as a pointer
typedef struct RSValue RSValue;


enum RLookupKeyFlag
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * This field is (or assumed to be) part of the document itself.
   * This is a basic flag for a loaded key.
   */
  DocSrc = 1,
  /**
   * This field is part of the index schema.
   */
  SchemaSrc = 2,
  /**
   * Check the sorting table, if necessary, for the index of the key.
   */
  SvSrc = 4,
  /**
   * This key was created by the query itself (not in the document)
   */
  QuerySrc = 8,
  /**
   * Copy the key string via strdup. `name` may be freed
   */
  NameAlloc = 16,
  /**
   * If the key is already present, then overwrite it (relevant only for LOAD or WRITE modes)
   */
  Override = 32,
  /**
   * Request that the key is returned for loading even if it is already loaded.
   */
  ForceLoad = 64,
  /**
   * This key is unresolved. Its source needs to be derived from elsewhere
   */
  Unresolved = 128,
  /**
   * This field is hidden within the document and is only used as a transient
   * field for another consumer. Don't output this field.
   */
  Hidden = 256,
  /**
   * The opposite of [`RLookupKeyFlag::Hidden`]. This field is specified as an explicit return in
   * the RETURN list, so ensure that this gets emitted. Only set if
   * explicitReturn is true in the aggregation request.
   */
  ExplicitReturn = 512,
  /**
   * This key's value is already available in the RLookup table,
   * if it was opened for read but the field is sortable and not normalized,
   * so the data should be exactly the same as in the doc.
   */
  ValAvailable = 1024,
  /**
   * This key's value was loaded (by a loader) from the document itself.
   */
  IsLoaded = 2048,
  /**
   * This key type is numeric
   */
  Numeric = 4096,
};
#ifndef __cplusplus
typedef uint32_t RLookupKeyFlag;
#endif // __cplusplus

enum RLookupOption
#ifdef __cplusplus
  : uint32_t
#endif // __cplusplus
 {
  /**
   * If the key cannot be found, do not mark it as an error, but create it and
   * mark it as F_UNRESOLVED
   */
  AllowUnresolved = 1,
  /**
   * If a loader was added to load the entire document, this flag will allow
   * later calls to GetKey in read mode to create a key (from the schema) even if it is not sortable
   */
  AllLoaded = 2,
};
#ifndef __cplusplus
typedef uint32_t RLookupOption;
#endif // __cplusplus

typedef struct IndexSpecCache IndexSpecCache;

typedef struct RLookupKey {
  /**
   * Index into the dynamic values array within the associated `RLookupRow`.
   */
  uint16_t dstidx;
  /**
   * If the source for this key is a sorting vector, this is the index
   * into the `RSSortingVector` within the associated `RLookupRow`.
   */
  uint16_t svidx;
  /**
   * Various flags dictating the behavior of looking up the value of this key.
   * Most notably, `Flags::SVSRC` means the source is an `RSSortingVector` and
   * `Self::svidx` should be used to look up the value.
   */
  RLookupKeyFlags flags;
  /**
   * The path of this key.
   *
   * For fields *not* loaded from a [`FieldSpec`][ffi::FieldSpec], this points to the *same* string
   * as `Self::path`.
   */
  const char *path;
  /**
   * The name of this key.
   */
  const char *name;
  /**
   * The length of this key in bytes, without the null-terminator.
   * Should be used to avoid repeated `strlen` computations.
   */
  uintptr_t name_len;
  /**
   * Pointer to next field in the list
   */
  struct RLookupKey *next;
} RLookupKey;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Read(RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is returned only if it's already in the lookup table (available from the
 * pipeline upstream), it is part of the index schema and is sortable (and then it is created), or
 * if the lookup table accepts unresolved keys.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_ReadEx(RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of this `CStr` must be contained within a single allocation!
 *     2. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Write(RLookup *lookup, const char *name, uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table, unless the
 * override flag is set.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of this `CStr` must be contained within a single allocation!
 *     3. `name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_WriteEx(RLookup *lookup,
                                          const char *name,
                                          size_t name_len,
                                          uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. The entire memory range of these `CStr` must be contained within a single allocation!
 *     2. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_Load(RLookup *lookup,
                                       const char *name,
                                       const char *field_name,
                                       uint32_t flags);

/**
 * Get a RLookup key for a given name.
 *
 * A key is created and returned only if it's NOT in the lookup table (unless the
 * override flag is set), and it is not already loaded. It will override an existing key if it was
 * created for read out of a sortable field, and the field was normalized. A sortable un-normalized
 * field counts as loaded.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. The memory pointed to by `name` and `field_name` must contain a valid nul terminator at the
 *    end of the string.
 * 3. `name` and `field_name` must be [valid] for reads of `name_len` bytes up to and including the nul terminator.
 *    This means in particular:
 *     1. `name_len` must be same as `strlen(name)`
 *     2. The entire memory range of these `CStr` must be contained within a single allocation!
 *     3. `name` and `field_name` must be non-null even for a zero-length cstr.
 * 4. The memory referenced by the returned `CStr` must not be mutated for
 *    the duration of lifetime `'a`.
 * 5. The nul terminator must be within `isize::MAX` from `name` and `field_name`
 * 6. All bits set in `flags` must correspond to a value of the enum.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
struct RLookupKey *RLookup_GetKey_LoadEx(RLookup *lookup,
                                         const char *name,
                                         size_t name_len,
                                         const char *field_name,
                                         uint32_t flags);

/**
 * Initialize the lookup. If cache is provided, then it will be used as an
 * alternate source for lookups whose fields are absent.
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `spcache` must be a [valid] pointer to a [`ffi::IndexSpecCache`]
 * 3. The [`ffi::IndexSpecCache`] being pointed MUST NOT get mutated
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Init(RLookup *lookup, struct IndexSpecCache *spcache);

/**
 * Releases any resources created by this lookup object. Note that if there are
 * lookup keys created with RLOOKUP_F_NOINCREF, those keys will no longer be
 * valid after this call!
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to a `RLookup`
 * 2. `lookup` **must not** be used again after this function is called.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_Cleanup(RLookup *lookup);

/**
 * Writes a key to the row but increments the value reference count before writing it thus having shared ownership.
 *
 * # Safety
 *
 * 1. `key` must be a [valid], non-null pointer to an [`RLookupKey`].
 * 2. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 3. `value` must be a [valid], non-null pointer to an [`ffi::RSValue`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_WriteKey(const struct RLookupKey *key,
                      RLookupRow *row,
                      RSValue *value);

/**
 * Writes a key to the row without incrementing the value reference count, thus taking ownership of the value.
 *
 * # Safety
 *
 * 1. `key` must be a [valid], non-null pointer to an [`RLookupKey`].
 * 2. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 3. `value` must be a [valid], non-null pointer to an [`ffi::RSValue`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookup_WriteOwnKey(const struct RLookupKey *key,
                         RLookupRow *row,
                         RSValue *value);

/**
 * Wipes a RLookupRow by decrementing all values and resetting the row.
 *
 * # Safety
 *
 * 1. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookupRow_Wipe(RLookupRow *row);

/**
 * Resets a RLookupRow by wiping it (see [`RLookupRow_Wipe`]) and deallocating the memory of the dynamic values.
 *
 * This does not affect the sorting vector.
 *
 * # Safety
 *
 * 1. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookupRow_Reset(RLookupRow *row);

/**
 * Move data from the source row to the destination row. The source row is cleared.
 * The destination row should be pre-cleared (though its cache may still exist).
 *
 * # Safety
 *
 * 1. `lookup` must be a [valid], non-null pointer to an [`RLookup`].
 * 2. `src` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 3. `dst` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 4. `src` and `dst` must not be the same lookup row.
 *
 * [valid]: https://doc.rust-lang.org/std/ptr/index.html#safety
 */
void RLookupRow_Move(RLookup *lookup, RLookupRow *src, RLookupRow *dst);

/**
 * Write fields from a source row into a destination row, the fields must exist in both lookups (schemas).
 *
 * Iterate through the source lookup keys, if it finds a corresponding key in the destination
 * lookup by name, then it's value is written to this row as a destination.
 *
 * If a source key is not found in the destination lookup the function will panic (same as C behavior).
 *
 * If a source key has no value in the source row, it is skipped.
 *
 * # Safety
 * 1. `src_lookup` must be a [valid], non-null pointer to an [`RLookup`].
 * 2. `src_row` must be a [valid], non-null pointer to an [`RLookupRow`].
 * 3. `dst_lookup` must be a [valid], non-null pointer to an [`RLookup`].
 * 4. `dst_row` must be a [valid], non-null pointer to an [`RLookupRow`].
 */
void RLookupRow_WriteFieldsFrom(RLookupRow *src_row,
                                RLookup *src_lookup,
                                RLookupRow *dst_row,
                                RLookup *dst_lookup);

/**
 * Add all on-overridden keys from `src` to `self`.
 *
 * For each key in src, check if it already exists *by name*.
 * - If it does the `flag` argument controls the behaviour (skip with `RLookupKeyFlags::empty()`, override with `RLookupKeyFlag::Override`).
 * - If it doesn't a new key will ne created.
 *
 * Flag handling:
 *  * - Preserves persistent source key properties (F_SVSRC, F_HIDDEN, F_EXPLICITRETURN, etc.)
 *  * - Filters out transient flags from source keys (F_OVERRIDE, F_FORCE_LOAD)
 *  * - Respects caller's control flags for behavior (F_OVERRIDE, F_FORCE_LOAD, etc.)
 *  * - Target flags = caller_flags | (source_flags & ~RLOOKUP_TRANSIENT_FLAGS)
 *
 * # Safety:
 * 1. `src` must be a [valid], non-null pointer to an [`RLookup`].
 * 2. `dst` must be a [valid], non-null pointer to an [`RLookup`].
 */
void RLookup_AddKeysFrom(RLookup *src,
                         RLookup *dst,
                         uint32_t flags);

/**
 * Retrieves an item from the given `RLookupRow` based on the provided `RLookupKey`.
 * The function first checks for dynamic values, and if not found, it checks the sorting vector
 * if the `SvSrc` flag is set in the key.
 * If the item is not found in either location, it returns `None`.
 *
 * # Safety
 * 1. `key` must be a [valid], non-null pointer to an [`RLookupKey`].
 * 2. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 */
const RSValue *RLookup_GetItem(struct RLookupKey *key, RLookupRow *row);

/**
 * Sets a sorting vector for the row.
 * Safety:
 * 1. `row` must be a valid pointer to an [`RLookupRow`].
 * 2. `sv` must be a valid pointer to an [`ffi::RSSortingVector`].
 */
void RLookupRow_SetSortingVector(RLookupRow *row, const RSSortingVector *sv);

/**
 * Returns a pointer to the sorting vector if it exists, or null otherwise.
 *
 * Safety:
 * The caller does not own the returned pointer and must not attempt to free it.
 */
const RSSortingVector *RLookupRow_GetSortingVector(RLookupRow *row);

/**
 * Returns the number of dynamic values in the row.
 *
 * # Safety
 * 1. `row` must be a [valid], non-null pointer to an [`RLookupRow`].
 *
 */
uint32_t RLookupRow_GetDynLen(RLookupRow *row);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus
