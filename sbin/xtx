#!/usr/bin/env python3
"""
xtx.py - A minimal template renderer with {{VAR}} substitution from environment variables.
Replacing Readies xtx for pack.sh file.

DESCRIPTION:
    This script processes a template file and substitutes placeholders in the format {{VAR}}
    with corresponding values from environment variables. It is useful for generating configuration
    files or other templates dynamically based on the environment.

USAGE:
    python3 xtx.py -e VAR1 -e VAR2 [--strict] template_file

    -e VAR: Specifies the environment variable(s) to use for substitution.
    --strict: Ensures all placeholders in the template are defined in the environment.
              If any are missing, the script will terminate with an error.
    template_file: Path to the template file containing placeholders.

FEATURES:
    - Substitutes placeholders {{VAR}} with values from environment variables.
    - Leaves placeholders unchanged if the corresponding environment variable is not defined
      (unless --strict is used).
    - Pure Python implementation with no external dependencies.

EXAMPLES:
    1. Template file (template.txt):
        Hello, {{NAME}}!
        Welcome to {{PLACE}}.

    2. Environment variables:
        export NAME="Alice"
        export PLACE="Wonderland"

    3. Command:
        python3 xtx.py -e NAME -e PLACE template.txt

    4. Output:
        Hello, Alice!
        Welcome to Wonderland.

    5. Command with missing variable (without --strict):
        python3 xtx.py -e NAME template.txt

    6. Output:
        Hello, Alice!
        Welcome to {{PLACE}}.

    7. Command with missing variable (with --strict):
        python3 xtx.py -e NAME --strict template.txt

    8. Output:
        error: the following variables are undefined:
          PLACE

NOTES:
    - Placeholders must match the pattern {{VAR}}, where VAR is a valid Python identifier.
    - If --strict is not used, missing variables are replaced with an empty string.
"""

import os
import re
import sys
import argparse

parser = argparse.ArgumentParser(description="Minimal template renderer using {{VAR}} substitution.")
parser.add_argument('-e', '--env', action='append', metavar='VAR', help='Read variable from environment')
parser.add_argument('--strict', action='store_true', help='Fail on any undefined variable in the template')
parser.add_argument('template', help='Path to template file')
args = parser.parse_args()

# Read the template
try:
    with open(args.template, 'r') as f:
        template = f.read()
except Exception as e:
    print(f"error: failed to read template: {e}", file=sys.stderr)
    sys.exit(1)

# Regex to find {{ VAR }}
pattern = re.compile(r'{{\s*([A-Za-z_][A-Za-z0-9_]*)\s*}}')
used_vars = set(match.group(1) for match in pattern.finditer(template))

# Gather values from environment for requested variables
vars = {}
for var in args.env or []:
    val = os.environ.get(var)
    if val is not None:
        vars[var] = val

# --strict: fail on any missing variable used in the template
if args.strict:
    missing_vars = [var for var in used_vars if var not in vars]
    if missing_vars:
        print("error: the following variables are undefined:", file=sys.stderr)
        for var in sorted(missing_vars):
            print(f"  {var}", file=sys.stderr)
        sys.exit(1)

# Replace {{VAR}} with value or empty string if not defined (like Jinja2 DebugUndefined)
def replace(match):
    var = match.group(1)
    return vars.get(var, "")

output = pattern.sub(replace, template)
print(output)
